<!--
AI INSTRUCTIONS (MUST BE THE FIRST THING IN THIS FILE ‚Äî DO NOT PUT ANYTHING ABOVE THIS COMMENT)

When you (the AI) edit this file, you MUST update:
1) APP_META.appName: The human-readable app name shown on the top banner.
2) APP_META.appEmojis: EXACTLY TWO emojis appended to the app name.
   - These emojis should be SYMBOLIC of the app‚Äôs purpose (not random decoration).
3) APP_META.lastEditor: The chatbot/model that made the last edit (e.g., "GPT-5.2 Thinking").
4) The banner shows "Prompt time" and a live "Xh Ym ago".
   - Keep markPromptUsed(...) wired to whatever you consider the user‚Äôs "prompt" action(s).
   - Do not put anything before this comment block.
-->
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1,viewport-fit=cover" name="viewport"/>
<title>HH InstanceMap ‚Äî Material Outlines</title>
<style>
    :root{
      --bg:#0b0f14;
      --panel:#121822;
      --panel2:#0f1520;
      --text:#e8eef7;
      --muted:#9fb0c8;
      --line:#253246;
      --acc:#6aa7ff;

      /* Top banner */
      --topBannerH: 32px;

      /* Section accent defaults (overridden per section) */
      --sec:#6aa7ff;
      --secBg: rgba(106,167,255,0.10);
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:var(--bg);
      color:var(--text);
      height:100vh;
      overflow:hidden;
      padding-top: var(--topBannerH); /* leaves room for fixed top banner */
    }

    /* --- Thin top banner (requested) --- */
    #topBanner{
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--topBannerH);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding-left: calc(12px + env(safe-area-inset-left));
      padding-right: calc(12px + env(safe-area-inset-right));
      background: rgba(0,0,0,0.55);
      border-bottom: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 10000;
      font-size: 12px;
      line-height: 1;
      user-select: none;
    }

    #tbApp{
      font-weight: 700;
      letter-spacing: .15px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 40vw;
    }
    #tbPromptTime{
      color: rgba(255,255,255,0.80);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 44vw;
    }
    #tbEditor{
      color: rgba(255,255,255,0.72);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 40vw;
      text-align: right;
    }

    #app{ display:flex; height: calc(100vh - var(--topBannerH)); }

    /* --- Sidebar: header stays put, content scrolls --- */
    #sidebar{
      width: 380px;
      max-width: 42vw;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-right: 1px solid var(--line);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      flex-shrink:0;
    }

    #sidebarHeader{
      padding: 10px 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
    }

    #sidebarScroll{
      padding: 12px;
      overflow-y:auto;
      overflow-x:hidden;
    }

    /* --- Viewport (stationary preview) --- */
    #viewport{ flex:1; position:relative; min-width: 320px; height:100%; }

    /* Preview surface: keep a canvas-like feel, but it‚Äôs just a div */
    #previewSurface{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 24px;
      background:
        radial-gradient(1100px 600px at 30% 25%, rgba(106,167,255,0.12), transparent 60%),
        radial-gradient(900px 500px at 70% 75%, rgba(255,140,90,0.10), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    }

    #previewCard{
      width: min(640px, 92vw);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 18px;
      background: rgba(0,0,0,0.20);
      padding: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
    }

    #previewCard h1{ margin:0 0 6px; font-size: 16px; letter-spacing: .2px; }
    #previewCard p{ margin:0; color: var(--muted); font-size: 13px; line-height: 1.35; }

    /* --- Shared UI atoms --- */
    h2{
      margin: 10px 0 8px;
      font-size: 14px;
      letter-spacing: .3px;
      color: var(--muted);
      text-transform: uppercase;
    }

    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .col{ display:flex; flex-direction:column; gap:6px; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      font-size: 12px;
      color: var(--muted);
      user-select:none;
    }

    .pillTiny{
      /* Smaller, tighter pills for the header debug readouts */
      padding: 3px 7px;
      font-size: 10px;
      gap: 6px;
    }

    .card{
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 10px;
      background: rgba(255,255,255,0.03);
      margin-bottom: 10px;
    }

    /* Color-coded sections */
    .section{
      border-left: 6px solid var(--sec);
      background: linear-gradient(180deg, var(--secBg), rgba(255,255,255,0.02));
    }
    .section .sectionTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 6px;
    }
    .section .sectionTitle b{ font-size: 13px; color: var(--text); }
    .section .sectionTag{
      font-size: 11px;
      color: var(--muted);
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.03);
      padding: 3px 8px;
      border-radius: 999px;
    }

    label{ font-size: 12px; color: var(--muted); }

    input[type="number"], input[type="text"], select{
      width: 100%;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 10px;
      padding: 10px 10px;
      color: var(--text);
      outline:none;
    }

    button{
      background: rgba(106,167,255,0.18);
      border: 1px solid rgba(106,167,255,0.35);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 600;
    }
    button:active{ transform: translateY(1px); }
    button.secondary{ background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); }
    button.danger{ background: rgba(255,90,90,0.16); border: 1px solid rgba(255,90,90,0.35); }
    .mini{ font-size: 12px; padding: 8px 10px; border-radius: 10px; }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .grid3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .hr{ height:1px; background: rgba(255,255,255,0.10); margin:10px 0; }
    .help{ font-size: 12px; color: var(--muted); line-height: 1.35; }

    /* Quick toolbar inside the header */
    .toolbarHeader{
      margin-top: 10px;
      font-size: 11px;
      letter-spacing: .35px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.70);
    }

    .actionBar{
      margin-top: 6px;
      display:flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: nowrap; /* keep vertical buttons pinned right */
    }

    .actionBarLeft{
      display:flex;
      flex-direction: column;
      gap: 6px;
      flex: 1; /* keeps the common actions to the left */
      min-width: 0;
    }

    .actionBarRight{
      display:flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
      flex: 0 0 auto;
    }

    .actionRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }

    .pillStack{
      display:flex;
      flex-direction: row; /* horizontal */
      gap: 4px;
      align-items: center;
      justify-content: flex-end;
    }

    .miniSm{
      font-size: 10px;
      padding: 6px 8px;
      border-radius: 10px;
    }

    .miniLg{
      /* Slightly smaller for the right-side vertical stack */
      font-size: 13px;
      padding: 9px 11px;
      border-radius: 12px;
      min-width: 72px;
    }

    .helpTiny{
      font-size: 10px;
      line-height: 1.25;
    }
    /* Floating, in-app debug for mobile (no devtools required) */
    #debugLogPanel{
      position: absolute;
      top: calc(var(--topBannerH) + 10px);
      right: 10px;
      width: min(360px, 92vw);
      max-height: 48vh;
      background: rgba(11, 15, 20, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      overflow: hidden;
      display: none;
      z-index: 20;
    }
    #debugLogPanel.visible{ display:block; }

    .debug-log-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding: 10px 12px;
      background: rgba(0,0,0,0.3);
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .debug-log-header h3{ margin:0; font-size: 13px; color: var(--text); font-weight: 600; }
    .debug-log-buttons{ display:flex; gap:6px; }
    .debug-log-btn{
      padding: 4px 8px;
      font-size: 11px;
      background: rgba(106, 167, 255, 0.18);
      border: 1px solid rgba(106, 167, 255, 0.35);
      color: var(--text);
      border-radius: 6px;
      cursor:pointer;
    }

    #debugLogContent{
      max-height: calc(48vh - 44px);
      overflow-y:auto;
      padding: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 11px;
      line-height: 1.4;
    }

    .debug-log-line{ padding: 2px 4px; border-radius: 3px; margin-bottom: 2px; color: #bfdbfe; }
    .debug-log-line:hover{ background: rgba(255,255,255,0.05); }

    #debugLogToggle{
      position:absolute;
      top: calc(var(--topBannerH) + 10px);
      left: 10px;
      padding: 8px 12px;
      background: rgba(11, 15, 20, 0.90);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      color: var(--text);
      font-size: 12px;
      cursor:pointer;
      z-index: 20;
    }

    /* Make the demo feel good on narrow screens */
    @media (max-width: 920px){
      #sidebar{ width: 340px; max-width: 55vw; }
      #tbApp{ max-width: 32vw; }
      #tbPromptTime{ max-width: 42vw; }
      #tbEditor{ max-width: 30vw; }
    }
    @media (max-width: 720px){
      #sidebar{ width: 320px; max-width: 78vw; }
      #tbApp{ max-width: 36vw; }
      #tbPromptTime{ max-width: 44vw; }
      #tbEditor{ max-width: 32vw; }
    }
  

/* ============================
   HHInstanceMap controls (scoped)
   ============================ */
#sceneRoot{
  position:absolute;
  inset:0;
  overflow:hidden;
}
#sceneRoot canvas{
  display:block;
  width:100%;
  height:100%;
}
#previewSurface{
  padding:0;
  display:block;
  align-items:stretch;
  justify-content:stretch;
}

/* Put HH HUD as an overlay in the viewport (hidden by default; debug panel mirrors it) */
#hud{
  position:absolute;
  left:10px;
  bottom:10px;
  z-index:30;
  font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  color: rgba(255,255,255,0.85);
  background: rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 10px;
  padding: 10px 12px;
  max-width: min(980px, calc(100vw - 20px));
  white-space: pre-wrap;
  user-select:none;
  display:none; /* toggle in code if you want it visible */
}

#hhControls .hhWrap{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  align-items:flex-start;
}

/* HH style atoms */
#hhControls .btn, #hhControls .field{
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.14);
  background: rgba(0,0,0,0.28);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  color: rgba(255,255,255,0.9);
}
#hhControls .btn{
  font: 13px/1 ui-sans-serif, system-ui;
  padding:10px 12px;
  cursor:pointer;
  -webkit-tap-highlight-color: transparent;
}
#hhControls .btn:active{ transform: translateY(1px); }
#hhControls .btn.mini{
  padding:6px 10px;
  font-size:12px;
  border-radius:10px;
}
#hhControls .field{
  display:flex;
  align-items:center;
  gap:8px;
  padding:6px 10px;
  font:12px/1 ui-sans-serif, system-ui;
}
#hhControls .field label{ opacity:0.75; }
#hhControls .field input, #hhControls .field select{
  width:86px;
  padding:6px 8px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: rgba(255,255,255,0.95);
  outline:none;
}
#hhControls .field input[type="text"]{ width:140px; }
#hhControls .field input[type="checkbox"]{ width:auto; transform: translateY(1px); }
#hhControls .field select{ width:120px; }
#hhControls .field input[type="range"]{
  width:120px;
  padding:0;
  height:18px;
  background: transparent;
  border:none;
}
#hhControls .pill{
  display:inline-block;
  padding:4px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  font-variant-numeric: tabular-nums;
  min-width: 44px;
  text-align:center;
}
#hhControls .seedRow{
  display:flex;
  gap:8px;
  align-items:center;
  width:100%;
}
#hhControls .seedRow input{
  flex: 1 1 auto;
  min-width: 0;
}

/* Wind direction pad */
#hhControls .windpad{
  width:96px; height:96px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.05);
  position: relative;
  touch-action: none;
  overflow:hidden;
}
#hhControls .windpad::before{
  content:"";
  position:absolute; inset:0;
  background:
    linear-gradient(to right, rgba(255,255,255,0.10) 1px, transparent 1px) 50% 0/50% 100%,
    linear-gradient(to bottom, rgba(255,255,255,0.10) 1px, transparent 1px) 0 50%/100% 50%;
  opacity:0.55;
  pointer-events:none;
}
#hhControls .winddot{
  width:14px; height:14px;
  border-radius:999px;
  background: rgba(255,255,255,0.92);
  position:absolute;
  left:50%; top:50%;
  transform: translate(-50%,-50%);
  box-shadow: 0 0 0 2px rgba(0,0,0,0.35);
  pointer-events:none;
}
</style>
<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script></head>
<body>
<!-- Fixed top banner (requested) -->
<div aria-label="Top status banner" id="topBanner">
<div id="tbApp">App</div>
<div id="tbPromptTime">Prompt time: ‚Äî</div>
<div id="tbEditor">Last edit: ‚Äî</div>
</div>
<div id="app">
<aside aria-label="Settings panel" id="sidebar">
<!-- Stationary header (does NOT scroll) -->
<div id="sidebarHeader">
<div class="row" style="justify-content:space-between; align-items:center;">
<div>
<div style="font-weight:700; font-size:14px; letter-spacing:.2px;">HH InstanceMap</div>
<div style="font-size:12px; color:var(--muted); margin-top:2px;">HHInstanceMap integrated into the new UI</div>
</div>
<div class="pillStack" id="pillStack">
<div class="pill pillTiny" id="statePill">State: Idle</div>
<div class="pill pillTiny" id="selectionPill">Selection: (none)</div>
<div class="pill pillTiny" id="modePill">Mode: A</div>
</div>
</div>
<div class="toolbarHeader">Quick toolbar (frequently used)</div>
<div aria-label="Quick toolbar" class="actionBar">
<div class="actionBarLeft">
<div aria-label="Common actions" class="actionRow">
<button class="secondary mini miniSm" id="regenBtn" title="Regenerate terrain" type="button">Regen</button>
<button class="secondary mini miniSm" id="exportBtn" title="Export as .vox" type="button">Export</button>
<button class="secondary mini miniSm" id="importBtn" title="Import .vox" type="button">Import</button>
</div>
<div aria-label="Other actions" class="actionRow">
<button class="secondary mini miniSm" id="resetBtn" title="Reset controls to defaults and regenerate" type="button">Reset</button>
</div>
</div>
<div aria-label="Navigation and history" class="actionBarRight">
<button class="secondary mini miniLg" id="tocJumpBtn" title="Jump to Table of Contents" type="button">TOC</button>
<button class="secondary mini miniLg" id="undoBtn" title="Undo" type="button">Undo</button>
<button class="secondary mini miniLg" id="redoBtn" title="Redo" type="button">Redo</button>
</div>
</div>
<div class="help helpTiny" style="margin-top:8px;">
          This file is intentionally <b>UI-only</b>. Buttons update the in-app debug log so you can demonstrate flows on mobile.
        </div>
</div>
<!-- Scrolling settings content -->
<div id="sidebarScroll"><div id="hhControls">
<h2>Table of Contents</h2>
<div class="card section" id="toc" style="--sec:#94a3b8; --secBg: rgba(148,163,184,0.10);">
<div class="sectionTitle">
<b>Jump to section</b>
<span class="sectionTag">TOC</span>
</div>
<div class="help">Tap to scroll within the sidebar.</div>
<div class="hr"></div>
<div class="row" style="gap:8px;">
<button class="secondary mini" id="toc_tab-layout" type="button">Layout</button>
<button class="secondary mini" id="toc_tab-ground" type="button">Ground</button>
<button class="secondary mini" id="toc_tab-grass" type="button">Grass &amp; Wind</button>
<button class="secondary mini" id="toc_tab-water" type="button">Water</button>
<button class="secondary mini" id="toc_tab-lighting" type="button">Lighting</button>
<button class="secondary mini" id="toc_tab-actions" type="button">Actions</button>
<button class="secondary mini" id="toc_tab-terrain-types" type="button">Terrain Types</button>
</div>
</div>
<h2>Layout</h2>
<div class="card section" id="sec_tab-layout" style="--sec:#6aa7ff; --secBg: rgba(106,167,255,0.10);">
<div class="sectionTitle">
<b>Layout</b>
<span class="sectionTag">Layout</span>
</div>
<div class="help">HHInstanceMap controls ‚Äî Layout.</div>
<div class="hr"></div>
<div class="hhWrap">
<div class="field seedRow">
<label>Seed</label>
<input id="seed" type="text" value="benjam-rect-01"/>
<button class="btn mini" id="seedRand" title="Generate a random seed">üé≤</button>
<button class="btn mini" id="seedCopy" title="Copy seed to clipboard">Copy</button>
<button class="btn mini" id="seedPaste" title="Paste seed from clipboard">Paste</button>
</div>
<div class="field"><label>W</label><input id="w" min="16" type="number" value="64"/></div>
<div class="field"><label>H</label><input id="h" min="16" type="number" value="64"/></div>
<div class="field"><label>Tile</label><input id="tile" min="0.25" step="0.25" type="number" value="1"/></div>
<div class="field"><label>StepH</label><input id="stepH" min="0.25" step="0.25" type="number" value="1"/></div>
<div class="field">
<label>MaxLvl</label>
<input id="maxLvl" min="1" type="number" value="6"/>
<span id="maxLvlNote" style="display:none; font-size:9px; opacity:0.6; margin-left:4px;">(block height)</span>
</div>
<div class="field"><label>Rects</label><input id="rects" min="1" type="number" value="18"/></div>
<div class="field"><label>Ramps</label><input id="ramps" min="0" type="number" value="28"/></div>
<div class="field"><label>Vertical</label>
<select id="vertMode">
<option selected="" value="mixed">mixed</option>
<option value="ramps">ramps</option>
<option value="rockwalls">rockwalls</option>
</select>
</div>
<div class="field" id="rampFracField">
<label>RampFrac</label>
<input id="rampFrac" max="1" min="0" step="0.01" type="range" value="0.60"/>
<span class="pill" id="rampFracVal">0.60</span>
</div>
<div class="field"><label>CliffFacing</label>
<select id="cliffFacing">
<option selected="" value="ANY">Any</option>
<option value="X+">X+</option>
<option value="X-">X-</option>
<option value="Z+">Z+</option>
<option value="Z-">Z-</option>
</select>
</div>
<div class="field"><label>GenMode</label>
<select id="genMode">
<option selected="" value="procedural">Procedural</option>
<option value="reimport">Reimport (apply layout)</option>
<option value="sculpt-gentle">Sculpt - Gentle</option>
<option value="sculpt-dramatic">Sculpt - Dramatic</option>
</select>
</div>
<div class="field" id="sculptOpsField" style="display:none;">
<label>Ops/Layer</label>
<input id="sculptOpsMin" max="5" min="0" style="width:50px;" type="number" value="1"/>
<span style="opacity:0.5;">to</span>
<input id="sculptOpsMax" max="5" min="0" style="width:50px;" type="number" value="2"/>
</div>
<div id="sculptNote" style="display:none; font-size:10px; opacity:0.6; padding:6px 10px; max-width:380px;">
        MaxLvl = starting block height. Set Ops to 0-0 to see full solid block. 1-1 for minimal carving.
      </div>
<div id="sculptOpsCheckboxes" style="display:none; width:100%; padding:6px 10px; border-radius:12px; border:1px solid rgba(255,255,255,0.14); background: rgba(0,0,0,0.28);">
<div style="font-size:10px; opacity:0.7; margin-bottom:6px;">Enabled Operations:</div>
<div style="display:flex; flex-direction:column; gap:4px; font-size:11px;">
<label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
<input checked="" id="opRiverValley" style="width:auto;" type="checkbox"/> River Valley
          </label>
<label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
<input checked="" id="opRiverTerrace" style="width:auto;" type="checkbox"/> River Terrace ‚≠ê
          </label>
<label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
<input checked="" id="opBasinDeepen" style="width:auto;" type="checkbox"/> Basin Deepen
          </label>
<label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
<input checked="" id="opWindSmooth" style="width:auto;" type="checkbox"/> Wind Smooth
          </label>
<label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
<input checked="" id="opRidgeCarve" style="width:auto;" type="checkbox"/> Ridge Carve
          </label>
<label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
<input checked="" id="opSurfaceLower" style="width:auto;" type="checkbox"/> Surface Lower
          </label>
<label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
<input checked="" id="opPlateauKeep" style="width:auto;" type="checkbox"/> Plateau Keep
          </label>
</div>
</div>
<div class="field" id="groundLayerField" style="display:none;">
<label>GroundLayer</label>
<input id="groundLayer" max="8" min="1" type="number" value="2"/>
</div>
</div>
</div>
<h2>Ground</h2>
<div class="card section" id="sec_tab-ground" style="--sec:#22c55e; --secBg: rgba(34,197,94,0.10);">
<div class="sectionTitle">
<b>Ground</b>
<span class="sectionTag">Ground</span>
</div>
<div class="help">HHInstanceMap controls ‚Äî Ground.</div>
<div class="hr"></div>
<div class="hhWrap">
<div class="field"><label>GroundAmp</label><input id="gAmp" min="0" step="0.01" type="number" value="0.12"/></div>
<div class="field"><label>GroundScale</label><input id="gScale" min="0.01" step="0.01" type="number" value="0.11"/></div>
<div class="field"><label>LumpAmp</label><input id="lumpAmp" min="0" step="0.01" type="number" value="0.10"/></div>
<div class="field"><label>LumpScale</label><input id="lumpScale" min="0.01" step="0.01" type="number" value="0.55"/></div>
<div class="field"><label>MuffinLift</label><input id="muffLift" min="0" step="0.01" type="number" value="0.18"/></div>
<div class="field"><label>MuffinOver</label><input id="muffOver" min="0" step="0.01" type="number" value="0.14"/></div>
<div class="field"><label>MuffinRad</label><input id="muffRad" min="0.05" step="0.05" type="number" value="0.35"/></div>
<div class="field"><label>Round</label><input id="round" min="0" step="0.01" type="number" value="0.18"/></div>
<div class="field"><label>CliffWallRough</label><input id="wallRough" min="0" step="0.1" type="number" value="1.0"/></div>
<div class="field"><label>CliffVar</label><input id="cliffVar" min="0" step="0.01" type="number" value="0.22"/></div>
<div class="field"><label>CliffVarScale</label><input id="cliffVarScale" min="0.01" step="0.01" type="number" value="0.18"/></div>
<div class="field"><label>CliffVarBoost</label><input id="cliffVarBoost" min="0" step="0.25" type="number" value="1.0"/></div>
<div class="field"><label>Smooth Normals</label><input checked="" id="smoothNormals" type="checkbox"/></div>
<div class="field"><label>Solid Ground</label><input checked="" id="groundShellOn" type="checkbox"/></div>
<div class="field"><label>ShellVox</label><input id="groundShellVox" min="0" step="0.25" type="number" value="1.0"/></div>
</div>
</div>
<h2>Grass &amp; Wind</h2>
<div class="card section" id="sec_tab-grass" style="--sec:#a78bfa; --secBg: rgba(167,139,250,0.10);">
<div class="sectionTitle">
<b>Grass &amp; Wind</b>
<span class="sectionTag">Grass</span>
</div>
<div class="help">HHInstanceMap controls ‚Äî Grass &amp; Wind.</div>
<div class="hr"></div>
<div class="hhWrap">
<div class="field"><label>Substance</label>
<select id="topMat">
<option selected="" value="grass">grass</option>
<option value="accumulation">accumulation</option>
<option value="default">default</option>
</select>
</div>
<div class="field"><label>GrassThk</label><input id="grassThk" min="0" step="0.01" type="number" value="0.14"/></div>
<div class="field"><label>Grass</label><input checked="" id="grassOn" type="checkbox"/></div>
<div class="field">
<label>GrassDen</label>
<input id="grassDen" max="6" min="0" step="0.1" type="range" value="1.2"/>
<span class="pill" id="grassDenVal">1.2</span>
</div>
<div class="field">
<label>GrassHeight</label>
<input id="grassHeight" max="2" min="0" step="0.01" type="range" value="0.1"/>
<span class="pill" id="grassHeightVal">0.25</span>
</div>
<div class="field">
<label>GrassDetail</label>
<input id="grassFreq" max="200" min="1" step="1" type="range" value="20"/>
<span class="pill" id="grassFreqVal">20</span>
</div>
<div class="field">
<label>GrassSubdiv</label>
<input id="grassSubdiv" max="16" min="0" step="1" type="range" value="4"/>
<span class="pill" id="grassSubdivVal">12</span>
</div>
<div class="field">
<label>GrassWidth</label>
<input id="grassWidth" max="2" min="0.1" step="0.05" type="range" value="0.5"/>
<span class="pill" id="grassWidthVal">0.50</span>
</div>
<div class="field">
<label>GrassUp</label>
<select id="grassUpAxis">
<option selected="" value="Y">Y + (default)</option>
<option value="Y-">Y -</option>
<option value="Z">Z +</option>
<option value="Z-">Z -</option>
<option value="X">X +</option>
<option value="X-">X -</option>
</select>
</div>
<div class="field" style="display:none"><label>R</label><input id="grassR" min="0.01" step="0.01" type="number" value="0.07"/></div>
<div class="field"><label>Lean¬∞</label><input id="grassLean" min="0" step="1" type="number" value="22"/></div>
<div class="field">
<label>WindDir</label>
<div style="display:flex; gap:8px; align-items:center;">
<div class="windpad" data-wx="0.45" data-wz="0.15" id="windPad" title="Drag the dot to set wind direction (XZ). Center = no wind.">
<div class="winddot" id="windDot"></div>
</div>
<span class="pill" id="windDirVal">0.00,0.00</span>
</div>
</div>
<div class="field">
<label>WindStrength</label>
<input id="windStrength" max="1" min="0" step="0.01" type="range" value="0.05"/>
<span class="pill" id="windStrengthVal">0.12</span>
</div>
<div class="field">
<label>AutoWind</label>
<div style="display:flex; gap:10px; align-items:center;">
<input id="windAuto" type="checkbox"/>
<span style="font-size:12px; opacity:0.85;">Rotate wind direction over time (testing)</span>
</div>
</div>
<div class="field">
<label>AutoWindSpeed</label>
<input id="windAutoSpeed" max="4" min="0" step="0.05" type="range" value="0"/>
<span class="pill" id="windAutoSpeedVal">1.00</span>
</div>

<div class="field" style="margin-top:12px; border-top:1px solid rgba(255,255,255,0.14); padding-top:10px;">
  <label style="font-weight:bold; opacity:1;">Accumulation</label>
</div>
<div class="field" style="font-size: 11px; opacity: 0.75; margin-top: -6px; flex-direction:column; gap:2px;">
  <span>Surface cover that builds up over time (e.g., snow, moss). Mutually exclusive with grass.</span>
</div>

<div class="field">
  <label>Type</label>
  <select id="accumKind">
    <option selected value="none">none</option>
    <option value="snow">snow</option>
    <option value="moss">moss</option>
  </select>
</div>

<div class="field">
  <label>Height</label>
  <input id="accumHeight" max="1.5" min="0" step="0.01" type="range" value="1"/>
  <span class="pill" id="accumHeightVal">0.35</span>
</div>
<div class="field">
  <label>NoiseScale</label>
  <input id="accumNoiseScale" max="6" min="0.1" step="0.05" type="range" value="1.10"/>
  <span class="pill" id="accumNoiseScaleVal">1.10</span>
</div>
<div class="field">
  <label>Layers</label>
  <input id="accumLayers" max="10" min="0" step="1" type="range" value="5"/>
  <span class="pill" id="accumLayersVal">5</span>
</div>
<div class="field">
  <label>LayerBulge</label>
  <input id="accumLayerBulge" max="1.5" min="0" step="0.01" type="range" value="0.65"/>
  <span class="pill" id="accumLayerBulgeVal">0.65</span>
</div>
<div class="field">
  <label>LayerSharpness</label>
  <input id="accumLayerSharpness" max="6" min="0.1" step="0.05" type="range" value="2.50"/>
  <span class="pill" id="accumLayerSharpnessVal">2.50</span>
</div>
<div class="field">
  <label>SlopeStart</label>
  <input id="accumSlopeStart" max="1" min="0" step="0.01" type="range" value="0.20"/>
  <span class="pill" id="accumSlopeStartVal">0.20</span>
</div>
<div class="field">
  <label>SlopeEnd</label>
  <input id="accumSlopeEnd" max="1" min="0" step="0.01" type="range" value="0.70"/>
  <span class="pill" id="accumSlopeEndVal">0.70</span>
</div>

<div class="field">
  <label>EdgeHold</label>
  <input id="accumEdgeHold" max="1" min="0" step="0.01" type="range" value="1.00"/>
  <span class="pill" id="accumEdgeHoldVal">1.00</span>
</div>
<div class="field">
  <label>EdgePow</label>
  <input id="accumEdgePow" max="8" min="0" step="0.05" type="range" value="0"/>
  <span class="pill" id="accumEdgePowVal">2.50</span>
</div>

<div class="field">
  <label>Tint</label>
  <div style="display:flex; gap:8px; align-items:center;">
    <input id="accumTint" type="color" value="#ebf6ff"/>
    <input id="accumTintHex" type="text" value="#ebf6ff" style="width:96px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;"/>
  </div>
</div>
<div class="field">
  <label>TintStrength</label>
  <input id="accumTintStrength" max="1" min="0" step="0.01" type="range" value="1.0"/>
  <span class="pill" id="accumTintStrengthVal">1.00</span>
</div>

</div>
</div>
<h2>Water</h2>
<div class="card section" id="sec_tab-water" style="--sec:#38bdf8; --secBg: rgba(56,189,248,0.10);">
<div class="sectionTitle">
<b>Water</b>
<span class="sectionTag">Water</span>
</div>
<div class="help">HHInstanceMap controls ‚Äî Water.</div>
<div class="hr"></div>
<div class="hhWrap">
<div style="font-size: 11px; opacity: 0.75; padding: 10px; background: rgba(255,180,50,0.15); border: 1px solid rgba(255,180,50,0.3); border-radius: 8px; line-height: 1.4; margin-bottom: 10px;">
<strong>‚ö†Ô∏è This is GLOBAL WATER PLANE (ocean/lake) - disabled by default</strong><br/>
        For rivers ‚Üí use <strong>"Terrain Types"</strong> tab ‚Üí Generate River<br/>
        River voxels flow naturally with terrain and don't conflict with this.
      </div>
<div class="field"><label>Enable Water Plane</label><input id="enableWater" type="checkbox"/></div>
<div class="field"><label>Clip Water To Low Areas</label><input id="waterClip" type="checkbox" checked/></div>
<div class="field">
<label>Water Level</label>
<input id="waterLevel" max="32" min="0" step="0.5" type="range" value="3"/>
<span class="pill" id="waterLevelVal">3.0</span>
</div>
<div class="field">
<label>Water Color</label>
<input id="waterColor" type="color" value="#2f6b8f"/>
</div>
<div class="field">
<label>Water Opacity</label>
<input id="waterOpacity" max="1.0" min="0.1" step="0.05" type="range" value="1.0"/>
<span class="pill" id="waterOpacityVal">1.0</span>
</div>

<div class="row" style="gap:8px; align-items:center; flex-wrap:wrap;">
  <button id="waterDumpBtn" class="btn mini" type="button">Dump Water Debug</button>
  <button id="waterFrameBtn" class="btn mini" type="button">Frame Water</button>
  <label class="pill"><input id="waterShowHelpers" type="checkbox"> Show Helpers</label>
  <label class="pill"><input id="waterShowTestQuad" type="checkbox"> Test Quad</label>
</div>
<div class="tiny">Debug helpers: logs whether water spawned, its bounds/layers, and can frame the camera on it.</div>
<div class="field">
<label>Wave Speed</label>
<input id="waveSpeed" max="3.0" min="0.0" step="0.1" type="range" value="1.25"/>
<span class="pill" id="waveSpeedVal">1.25</span>
</div>
<div class="field">
<label>Wave Scale</label>
<input id="waveScale" max="8.0" min="0.5" step="0.1" type="range" value="4.5"/>
<span class="pill" id="waveScaleVal">4.5</span>
</div>
<div class="field">
<label>Wave Height</label>
<input id="waveAmp" max="0.5" min="0.0" step="0.01" type="range" value="0.10"/>
<span class="pill" id="waveAmpVal">0.10</span>
</div>
<div class="field">
<label>Flow Direction</label>
<select id="flowDir">
<option value="0,0,1">North</option>
<option value="1,0,0">East</option>
<option value="0,0,-1">South</option>
<option value="-1,0,0">West</option>
<option selected="" value="0.7,0,0.7">Northeast</option>
<option value="-0.7,0,0.7">Northwest</option>
</select>
</div>
</div>
</div>

<div class="hr"></div>
<div class="field">
  <label>Fancy Water</label>
  <div style="display:flex; gap:10px; align-items:center;">
    <input id="waterFancy" type="checkbox" />
    <span style="font-size:12px; opacity:0.85;">Foam + fresnel + internal shading (turn off to keep only flow + silhouette trouble)</span>
  </div>
</div>

<div class="field">
  <label>Water Surface Outlines</label>
  <div style="display:flex; gap:10px; align-items:center;">
    <input id="waterSurfaceOutlines" type="checkbox" checked />
    <span style="font-size:12px; opacity:0.85;">Ink line wherever water meets non-water in camera view (shorelines, tree trunks, rocks, etc.)</span>
  </div>
</div>

<div class="field">
  <label>Water Outline Thick</label>
  <input id="waterOutlineThick" type="range" min="0.5" max="20" step="0.5" value="4.0"/>
  <span class="pill" id="waterOutlineThickVal">4.0</span>
</div>
<div class="field">
  <label>Water Outline Strength</label>
  <input id="waterOutlineStrength" type="range" min="0.0" max="2.0" step="0.05" value="1.0"/>
  <span class="pill" id="waterOutlineStrengthVal">1.0</span>
</div>

<h2 style="margin-top:16px;">Material Outlines</h2>

<div class="field">
  <label>Material Intersection Outlines</label>
  <div style="display:flex; gap:10px; align-items:center;">
    <input id="materialOutlinesEnabled" type="checkbox" checked />
    <span style="font-size:12px; opacity:0.85;">Ink line wherever different materials meet (grass/rock, wood/water, etc.)</span>
  </div>
</div>

<div class="field">
  <label>Material Outline Thick</label>
  <input id="materialOutlineThick" type="range" min="0.5" max="20" step="0.5" value="5.0"/>
  <span class="pill" id="materialOutlineThickVal">5.0</span>
</div>

<div class="field">
  <label>Material Outline Strength</label>
  <input id="materialOutlineStrength" type="range" min="0.0" max="2.0" step="0.05" value="1.0"/>
  <span class="pill" id="materialOutlineStrengthVal">1.0</span>
</div>

<h2>Lighting</h2>
<div class="card section" id="sec_tab-lighting" style="--sec:#fbbf24; --secBg: rgba(251,191,36,0.10);">
<div class="sectionTitle">
<b>Lighting</b>
<span class="sectionTag">Lighting</span>
</div>
<div class="help">HHInstanceMap controls ‚Äî Lighting.</div>
<div class="hr"></div>
<div class="hhWrap">
            
 Integrated Time &amp; Season System 
<div class="field">
<label style="font-weight: bold; opacity: 1;">Time &amp; Season</label>
</div>

<div class="field" style="margin-top:6px;">
<label>Biome Mode</label>
<select id="biomeSelect">
  <option value="andes_highlands">Andes Highlands</option>
  <option value="orographic_snowbelt">Orographic Snowbelt</option>
</select>
</div>
<div class="field" style="font-size: 11px; opacity: 0.75; margin-top: -6px; flex-direction:column; gap:2px;">
<span id="biomeDesc">Andean highlands wet/dry seasonal palette &amp; wind.</span>
</div>
 Day/Night Cycle 
<div class="field" style="margin-top:8px;">
<label>Time of Day</label>
<input id="timeOfDay" max="24" min="0" step="0.1" type="range" value="12"/>
<span class="pill" id="timeOfDayVal">12:00</span>
</div>
<div style="display:flex; gap:6px; flex-wrap:wrap; padding:0 10px;">
<button class="btn mini" id="timeSunrise">Sunrise</button>
<button class="btn mini" id="timeNoon">Noon</button>
<button class="btn mini" id="timeSunset">Sunset</button>
<button class="btn mini" id="timeMidnight">Midnight</button>
</div>
 Season Cycle 
<div class="field" style="margin-top:10px;">
<label>Season Value</label>
<input id="seasonSlider" max="1" min="0" step="0.01" type="range" value="0.5"/>
<span class="pill" id="seasonVal">0.50</span>
</div>
<div class="field" style="font-size: 11px; opacity: 0.75; margin-top: -8px; flex-direction:column; gap:2px;">
<span id="seasonDesc0">0.0 = Dry (golden grass, crystal sky)</span>
<span id="seasonDesc1">1.0 = Wet (green grass, morning fog)</span>
</div>
<div style="display:flex; gap:6px; flex-wrap:wrap; padding:0 10px;">
<button class="btn mini" id="seasonDry">Dry</button>
<button class="btn mini" id="seasonMid">Transition</button>
<button class="btn mini" id="seasonWet">Wet</button>
</div>
 Auto-Cycle System 
<div class="field" style="margin-top:10px; border-top:1px solid rgba(255,255,255,0.14); padding-top:10px;">
<label style="font-weight: bold; opacity: 1;">Auto-Cycle</label>
</div>
<div class="field" style="gap:4px;">
<input id="timeCycleAuto" type="checkbox"/>
<span style="font-size:12px; opacity:0.85;">Animate time &amp; seasons</span>
</div>
<div class="field">
<label>Day Length (sec)</label>
<input id="dayLength" max="120" min="10" step="5" type="range" value="60"/>
<span class="pill" id="dayLengthVal">60s</span>
</div>
<div class="field">
<label>Days per Season</label>
<input id="daysPerSeason" max="10" min="1" step="1" type="range" value="3"/>
<span class="pill" id="daysPerSeasonVal">3</span>
</div>
<div class="field" style="font-size: 11px; opacity: 0.65; flex-direction:column; gap:2px; margin-top:-6px;">
<span id="cycleInfo">Full cycle: 180s (3 min)</span>
</div>
 Atmosphere 
<div class="field" style="margin-top:12px; border-top:1px solid rgba(255,255,255,0.14); padding-top:10px;">
<label style="font-weight: bold; opacity: 1;">Atmosphere</label>
</div>
<div class="field">
<label>Fog Density</label>
<input id="fogDensity" max="0.02" min="0" step="0.0005" type="range" value="0.003"/>
<span class="pill" id="fogDensityVal">0.0030</span>
</div>
<div class="field">
<label>Fog Near</label>
<input id="fogNear" max="200" min="0" step="5" type="range" value="50"/>
<span class="pill" id="fogNearVal">50</span>
</div>
<div class="field">
<label>Altitude Clarity</label>
<input id="altitudeClarity" max="1" min="0" step="0.05" type="range" value="0.85"/>
<span class="pill" id="altitudeClarityVal">0.85</span>
</div>
 Storm System 
<div class="field" style="margin-top:12px; border-top:1px solid rgba(255,255,255,0.14); padding-top:10px;">
<label style="font-weight: bold; opacity: 1;">Storms &amp; Weather</label>
</div>
<div class="field" style="gap:4px;">
<input checked="" id="stormsEnabled" type="checkbox"/>
<span style="font-size:12px; opacity:0.85;">Enable afternoon storms (wet season)</span>
</div>
<div class="field">
<label>Storm Frequency</label>
<input id="stormFrequency" max="1" min="0" step="0.1" type="range" value="0.6"/>
<span class="pill" id="stormFrequencyVal">0.60</span>
</div>
<div class="field">
<label>Storm Intensity</label>
<input id="stormIntensity" max="1" min="0" step="0.1" type="range" value="0.7"/>
<span class="pill" id="stormIntensityVal">0.70</span>
</div>
<div class="field">
<label>Lightning Freq</label>
<input id="lightningFrequency" max="1" min="0" step="0.1" type="range" value="0.5"/>
<span class="pill" id="lightningFrequencyVal">0.50</span>
</div>
<div class="field" style="font-size: 11px; opacity: 0.65; flex-direction:column; gap:2px; margin-top:-6px;">
<span>Storms: 2-6pm in wet season</span>
<span id="stormStatus" style="opacity:0.85;">Status: Clear</span>
</div>
<div style="display:flex; gap:6px; flex-wrap:wrap; padding:0 10px;">
<button class="btn mini" id="triggerStorm">Trigger Storm</button>
<button class="btn mini" id="clearStorm">Clear Storm</button>
</div>
 Original controls 
<div class="field" style="margin-top:12px; border-top:1px solid rgba(255,255,255,0.14); padding-top:10px;">
<label style="font-weight: bold; opacity: 1;">Manual Sun Control</label>
</div>
<div class="field">
<label>ShapeLightTrack</label>
<input id="shapeLightTrack" max="1" min="0" step="0.05" type="range" value="0.7"/>
<span class="pill" id="shapeLightTrackVal">0.70</span>
</div>
<div class="field">
<label>RealLightBright</label>
<input id="realLightBright" max="3" min="0" step="0.05" type="range" value="0.8"/>
<span class="pill" id="realLightBrightVal">0.80</span>
</div>
<div class="field">
<label>Hemi</label>
<input id="hemiI" max="5" min="0" step="0.05" type="range" value="0.05"/>
<span class="pill" id="hemiIVal">0.55</span>
</div>
<div class="field">
<label>HemiSky</label>
<input id="hemiSky" type="color" value="#bfd7ff"/>
<span class="pill" id="hemiSkyVal">#bfd7ff</span>
</div>
<div class="field">
<label>HemiGround</label>
<input id="hemiGround" type="color" value="#5b4a2f"/>
<span class="pill" id="hemiGroundVal">#5b4a2f</span>
</div>
<div class="field">
<label>HemiBoost</label>
<input id="hemiBoost" type="checkbox"/>
</div>
<div class="field">
<label>SunRotate</label>
<input checked="" id="sunRotate" type="checkbox"/>
</div>
<div class="field">
<label>SunSpeed¬∞/s</label>
<input id="sunSpeed" max="45" min="0" step="0.5" type="range" value="6"/>
<span class="pill" id="sunSpeedVal">6.0</span>
</div>
<div class="field">
<label>SunAz¬∞</label>
<input id="sunAz" max="360" min="0" step="1" type="range" value="28"/>
<span class="pill" id="sunAzVal">28</span>
</div>
<div class="field">
<label>SunElev¬∞</label>
<input id="sunElev" max="85" min="5" step="1" type="range" value="55"/>
<span class="pill" id="sunElevVal">55</span>
</div>
 Depth Outline Controls 
<div id="depthOutlineControls" style="width:100%; border-top:1px solid rgba(255,255,255,0.14); padding-top:10px; margin-top:10px;">
<div class="field">
<label>OutlineThick</label>
<input id="outlineThick" max="40" min="0.5" step="0.5" type="range" value="7"/>
<span class="pill" id="outlineThickVal">7.0</span>
</div>
<div class="field">
<label>DepthSens</label>
<input id="depthSens" max="1" min="0.01" step="0.01" type="range" value="1.00"/>
<span class="pill" id="depthSensVal">1.00</span>
</div>
<div class="field">
<label>OutlineColor</label>
<input id="outlineColor" type="color" value="#000000"/>
<span class="pill" id="outlineColorVal">#000000</span>
</div>
<div class="field">
<label>DistShrink</label>
<input id="outlineDistShrink" max="200" min="0" step="0.5" type="range" value="100.0"/>
<span class="pill" id="outlineDistShrinkVal">100.0</span>
</div>
</div>
</div>
</div>
<h2>Actions</h2>
<div class="card section" id="sec_tab-actions" style="--sec:#fb7185; --secBg: rgba(251,113,133,0.10);">
<div class="sectionTitle">
<b>Actions</b>
<span class="sectionTag">Actions</span>
</div>
<div class="help">HHInstanceMap controls ‚Äî Actions.</div>
<div class="hr"></div>
<div class="hhWrap">
<button class="btn" id="regen">Regenerate</button>
<button class="btn" id="debug">Debug: lit</button>
<button class="btn" id="cliffDbg">Cliffs: runs</button>
<button class="btn" id="copyHud" title="Copy the HUD/debug text to clipboard">Copy HUD</button>
<button class="btn" id="treeToggle" title="Show/hide a procedural tree preview (token-friendly generator island)">Tree: on</button>
<button class="btn" id="treeRegen" title="Rebuild the tree preview without regenerating terrain">Tree: regen</button>
<button class="btn" id="treePresetLoad" title="Load a tree preset JSON (includes leaf PNG if embedded)">Tree: load .json</button>
<button class="btn" id="treePresetSave" title="Download the currently active tree preset as JSON">Tree: save .json</button>
<button class="btn" id="treePresetReset" title="Reset the tree preset back to the built-in default">Tree: default</button>
<button class="btn" id="roadBricksToggle" title="Show/hide procedural cobbles on road voxels (instanced)">Road Bricks: on</button>
<button class="btn" id="roadBricksRegen" title="Rebuild road bricks without regenerating terrain">Road Bricks: rebuild</button>
<div class="field">
<label>Road Brick Density</label>
<input id="roadBricksDensity" max="8" min="0" step="0.25" type="range" value="2.00"/>
<span class="pill" id="roadBricksDensityVal">2.00</span>
</div>
<div class="field">
<label>Road Brick Size</label>
<input id="roadBricksSizeFrac" max="0.60" min="0.12" step="0.02" type="range" value="0.26"/>
<span class="pill" id="roadBricksSizeFracVal">0.26</span>
</div>
<button class="btn" id="roadDebugToggle" title="Overlay tiles detected as road (debug)">Road Debug: off</button>
<div class="field">
<label>Road Brick Lift</label>
<input id="roadBricksYLift" max="0.20" min="0" step="0.005" type="range" value="0.030"/>
<span class="pill" id="roadBricksYLiftVal">0.030</span>
</div>

<div class="field">
  <label>Road Recipe</label>
  <button class="btn" id="roadBricksRecipeBtn" title="Import a road recipe JSON (from Wall/Road Builder) to control cobble placement">Road Recipe: built-in</button>
  <span class="pill" id="roadBricksRecipeStatus">built-in</span>
</div>
<input accept=".json,application/json" id="roadBricksRecipeInput" style="display:none" type="file"/>
<input accept=".json,application/json" id="treePresetInput" style="display:none" type="file"/>
<div class="field">
<label>Tree Base Scale</label>
<input id="treeUnitScale" max="3.0" min="0.25" step="0.05" type="range" value="0.45"/>
<span class="pill" id="treeUnitScaleVal">0.45</span>
</div>
<div class="field">
<label>Tree Size Variation</label>
<input id="treeScaleJitterFrac" max="0.5" min="0" step="0.05" type="range" value="0.25"/>
<span class="pill" id="treeScaleJitterFracVal">0.25</span>
</div>
<div class="field">
<label>Tree Rotation</label>
<input id="treeRotJitterDeg" max="360" min="0" step="15" type="range" value="360"/>
<span class="pill" id="treeRotJitterDegVal">360¬∞</span>
</div>
<div class="field">
<label>Tree Spawn Offset</label>
<input id="treeSpawnOffsetFrac" max="0.5" min="0" step="0.05" type="range" value="0.45"/>
<span class="pill" id="treeSpawnOffsetFracVal">0.45</span>
</div>
<button class="btn" id="exportVox">Export as .vox</button>
<button class="btn" id="importVox">Import .vox</button>
<input accept=".vox" id="voxFileInput" style="display:none" type="file"/>
</div>
</div>
<h2>Terrain Types</h2>
<div class="card section" id="sec_tab-terrain-types" style="--sec:#94a3b8; --secBg: rgba(148,163,184,0.10);">
<div class="sectionTitle">
<b>Terrain Types</b>
<span class="sectionTag">Terrain</span>
</div>
<div class="help">HHInstanceMap controls ‚Äî Terrain Types.</div>
<div class="hr"></div>
<div class="hhWrap">
<div class="field"><label>üõ£Ô∏è Roads (Marks voxels only - GLB instancing separate)</label></div>
<div class="field"><label>Road Width</label><input id="roadWidth" max="8" min="1" type="number" value="2"/></div>
<button class="btn" id="btnTestRoad">Test: Straight Road</button>
<button class="btn" id="btnGenerateRoads">Auto: Connect Peaks</button>
<button class="btn" id="btnClearRoads">Clear All Roads</button>
<div class="field"><label>Road Ramp Count</label><input id="roadRampCount" max="50" min="0" type="number" value="12"/></div>
<button class="btn" id="btnGenerateRoadRamps">Generate Road Ramps</button>
<button class="btn" id="btnConvertRoadSteps">Convert Road Steps ‚Üí Ramps</button>
<div style="width: 100%; height: 1px; background: rgba(255,255,255,0.14); margin: 10px 0;"></div>
<div class="field"><label>üåä Rivers</label></div>
<div class="field"><label>River Width</label><input id="riverWidth" max="8" min="1" type="number" value="2"/></div>
<button class="btn" id="btnGenerateRiver">Generate River</button>
<button class="btn" id="btnClearRivers">Clear All Rivers</button>
<div style="width: 100%; height: 1px; background: rgba(255,255,255,0.14); margin: 10px 0;"></div>
<div class="field"><label>üå≤ Trees &amp; Forests</label></div>
<div class="field"><label>Forest Density</label><input id="forestDensity" max="1" min="0" step="0.05" type="number" value="0.3"/></div>
<div class="field"><label>Barrier Density</label><input id="barrierDensity" max="1" min="0" step="0.05" type="number" value="0.2"/></div>
<button class="btn" id="btnTestForest">Test: Forest Patch</button>
<button class="btn" id="btnGenerateForests">Auto: Scatter Forests</button>
<button class="btn" id="btnClearForests">Clear All Forests</button>
<div style="font-size: 11px; opacity: 0.75; margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; line-height: 1.4;">
<strong>What you'll see:</strong><br/>
        ‚Ä¢ <span style="color:#8b6f47;">Brown dirt</span> where roads/rivers are (no grass!)<br/>
        ‚Ä¢ <span style="color:#1f7a2e;">Forest masks</span> mark tree spawn areas<br/>
        ‚Ä¢ <span style="color:#b02fb0;">Barrier masks</span> mark dense hedgerows<br/>
        ‚Ä¢ Green grass everywhere else<br/>
<br/>
<strong>Workflow:</strong><br/>
        1. Generate terrain (Layout ‚Üí Regenerate)<br/>
        2. Mark areas with "Test: Forest Patch" or "Auto"<br/>
        3. Go to Actions tab ‚Üí Toggle Tree Preview<br/>
        4. Trees spawn in marked forest/barrier zones<br/>
</div>
</div>
</div>
</div></div>
</aside>
<main aria-label="Preview area" id="viewport">
<button id="debugLogToggle" type="button">Debug</button>
<div id="previewSurface"><div aria-label="3D viewport" id="sceneRoot"></div></div>
<div aria-label="Debug log" id="debugLogPanel">
<div class="debug-log-header">
<h3>Debug Log</h3>
<div class="debug-log-buttons">
<button class="debug-log-btn" id="debugCopyBtn" type="button">Copy</button>
<button class="debug-log-btn" id="debugClearBtn" type="button">Clear</button>
<button class="debug-log-btn" id="debugCloseBtn" type="button">Close</button>
</div>
</div>
<div id="debugLogContent"></div>
</div>
<div id="hud">Booting‚Ä¶</div></main>
</div>
<script>
"use strict";

/* =========================================================================
   Top banner metadata (AI-updated)
   ========================================================================= */
const APP_META = {
  appName: "Vt3D Live Intersection Outlines",               // Used by top banner
  appEmojis: "üëÅÔ∏è‚ö°",                       // EXACTLY TWO emojis
  lastEditor: "GPT-5.2 Thinking",          // Chatbot/model that made the last edit
  promptTimestampISO: null                 // Updated by markPromptUsed(...); persisted in localStorage
};

const APP_META_STORAGE_KEY = "hh_instancemap_ui_meta_v1";

function loadAppMeta(){
  try{
    const raw = localStorage.getItem(APP_META_STORAGE_KEY);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    if (typeof parsed?.promptTimestampISO === "string") APP_META.promptTimestampISO = parsed.promptTimestampISO;
    log("Loaded APP_META from storage.");
  }catch(_){
    log("APP_META load failed (storage/JSON).");
  }
}
function saveAppMeta(){
  try{
    localStorage.setItem(APP_META_STORAGE_KEY, JSON.stringify({ promptTimestampISO: APP_META.promptTimestampISO }));
  }catch(_){
    log("APP_META save failed (storage).");
  }
}
function formatLocalDateTime(isoString){
  const d = new Date(isoString);
  if (Number.isNaN(d.getTime())) return "Invalid time";
  try{
    return new Intl.DateTimeFormat(undefined, {
      year: "numeric", month: "short", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit"
    }).format(d);
  }catch(_){
    return d.toLocaleString();
  }
}
function formatAgo(isoString){
  const d = new Date(isoString);
  const now = new Date();
  const ms = now.getTime() - d.getTime();
  if (!Number.isFinite(ms)) return "";
  if (ms < 0) return "in the future";
  const totalMinutes = Math.floor(ms / 60000);
  if (totalMinutes <= 0) return "just now";
  const hours = Math.floor(totalMinutes / 60);
  const minutes = totalMinutes % 60;
  if (hours <= 0) return `${minutes}m ago`;
  return `${hours}h ${minutes}m ago`;
}
function updateTopBanner(){
  const appEl = document.getElementById("tbApp");
  const promptEl = document.getElementById("tbPromptTime");
  const editorEl = document.getElementById("tbEditor");

  if (appEl) appEl.textContent = `${APP_META.appName} ${APP_META.appEmojis}`;
  if (editorEl) editorEl.textContent = `Last edit: ${APP_META.lastEditor}`;

  if (!promptEl) return;
  if (!APP_META.promptTimestampISO){
    promptEl.textContent = "Prompt time: ‚Äî";
    return;
  }
  const local = formatLocalDateTime(APP_META.promptTimestampISO);
  const ago = formatAgo(APP_META.promptTimestampISO);
  promptEl.textContent = `Prompt time: ${local} (${ago})`;
}
function markPromptUsed(actionLabel){
  APP_META.promptTimestampISO = new Date().toISOString();
  saveAppMeta();
  updateTopBanner();
  log(`Prompt timestamp updated by: ${actionLabel}`);
}

/* =========================================================================
   Mobile-friendly debug log
   ========================================================================= */
const debugPanel = document.getElementById("debugLogPanel");
const debugContent = document.getElementById("debugLogContent");
const debugToggle = document.getElementById("debugLogToggle");
const debugCloseBtn = document.getElementById("debugCloseBtn");
const debugClearBtn = document.getElementById("debugClearBtn");
const debugCopyBtn = document.getElementById("debugCopyBtn");

function ts(){
  const d = new Date();
  const pad = (n)=> String(n).padStart(2,"0");
  return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function log(msg){
  const line = document.createElement("div");
  line.className = "debug-log-line";
  line.textContent = `[${ts()}] ${msg}`;
  debugContent.prepend(line);
}

// Expose for the module script (HHInstanceMap) to mirror HUD/errors into this panel.
globalThis.__uiLog = (msg)=>log(msg);

debugToggle.addEventListener("click", () => {
  debugPanel.classList.toggle("visible");
  log(`Debug panel ${debugPanel.classList.contains("visible") ? "opened" : "closed"}.`);
});
debugCloseBtn.addEventListener("click", () => debugPanel.classList.remove("visible"));
debugClearBtn.addEventListener("click", () => {
  debugContent.innerHTML = "";
  log("Log cleared.");
});
debugCopyBtn.addEventListener("click", async () => {
  const lines = Array.from(debugContent.querySelectorAll(".debug-log-line"))
    .map(el => el.textContent)
    .reverse();
  const text = lines.join("\n");
  try{
    await navigator.clipboard.writeText(text);
    log(`Copied ${lines.length} line(s) to clipboard.`);
  }catch(_){
    log("Clipboard copy failed (browser permissions).");
  }
});

window.addEventListener("error", (e) => {
  log(`ERROR: ${e?.message || "Unknown error"}`);
});
window.addEventListener("unhandledrejection", (e) => {
  log(`PROMISE REJECTION: ${e?.reason?.message || String(e?.reason || "Unknown")}`);
});

/* =========================================================================
   Sidebar helpers + wiring
   ========================================================================= */
function scrollSidebarToId(targetId){
  const container = document.getElementById("sidebarScroll");
  const el = document.getElementById(targetId);
  if (!container){ log("Scroll container not found: sidebarScroll"); return; }
  if (!el){ log(`Scroll target not found: ${targetId}`); return; }

  const containerRect = container.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  const top = (elRect.top - containerRect.top) + container.scrollTop;
  container.scrollTo({ top: Math.max(0, top - 8), behavior: "smooth" });
}

function bindClick(id, handler){
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener("click", handler);
}

function clickById(id){
  const el = document.getElementById(id);
  if (!el){
    log(`Missing element: #${id}`);
    return false;
  }
  el.click();
  return true;
}

function resetHHControlsToDefaults(){
  const root = document.getElementById("hhControls");
  if (!root){ log("Missing #hhControls"); return; }

  const nodes = root.querySelectorAll("input, select, textarea");
  let count = 0;

  nodes.forEach(el => {
    const tag = el.tagName.toLowerCase();
    if (tag === "select"){
      // Revert to the default selected option (from HTML)
      const opts = Array.from(el.options);
      const defIdx = opts.findIndex(o => o.defaultSelected);
      el.selectedIndex = defIdx >= 0 ? defIdx : 0;
      el.dispatchEvent(new Event("change", { bubbles: true }));
      count++;
      return;
    }

    if (el.type === "checkbox" || el.type === "radio"){
      el.checked = el.defaultChecked;
      el.dispatchEvent(new Event("change", { bubbles: true }));
      count++;
      return;
    }

    // number, text, range, etc.
    el.value = el.defaultValue;
    el.dispatchEvent(new Event("input", { bubbles: true }));
    el.dispatchEvent(new Event("change", { bubbles: true }));
    count++;
  });

  log(`Reset ${count} control(s) to defaults.`);
}

// Quick toolbar
bindClick("regenBtn", () => {
  markPromptUsed("Regen");
  clickById("regen");
});

bindClick("exportBtn", () => {
  markPromptUsed("Export");
  clickById("exportVox");
});

bindClick("importBtn", () => {
  markPromptUsed("Import");
  clickById("importVox");
});

bindClick("resetBtn", () => {
  markPromptUsed("Reset");
  resetHHControlsToDefaults();
  // Regenerate after reset (best-effort)
  clickById("regen");
});

// Right side buttons
bindClick("tocJumpBtn", () => {
  scrollSidebarToId("toc");
  log("Jumped to TOC.");
});

bindClick("undoBtn", () => log("Undo (not wired in this integration)."));
bindClick("redoBtn", () => log("Redo (not wired in this integration)."));

// TOC buttons
[
  ["toc_tab-layout","sec_tab-layout"],
  ["toc_tab-ground","sec_tab-ground"],
  ["toc_tab-grass","sec_tab-grass"],
  ["toc_tab-water","sec_tab-water"],
  ["toc_tab-lighting","sec_tab-lighting"],
  ["toc_tab-actions","sec_tab-actions"],
  ["toc_tab-terrain-types","sec_tab-terrain-types"]
].forEach(([btnId, secId]) => {
  bindClick(btnId, () => {
    scrollSidebarToId(secId);
    log(`Jumped to: ${secId}`);
  });
});

// Mark prompt time when key HH buttons are used directly in the sidebar
["regen","exportVox","importVox"].forEach(id => {
  const el = document.getElementById(id);
  if (el){
    el.addEventListener("click", () => markPromptUsed(id), { capture:true });
  }
});

loadAppMeta();
updateTopBanner();
setInterval(updateTopBanner, 15000); // keep "ago" fresh
log("UI booted.");
</script>
<script id="hhInstanceMapModule" type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { mergeVertices } from "three/addons/utils/BufferGeometryUtils.js";

    // Make utilities available globally for helper functions
    globalThis.THREE = THREE;
    globalThis.mergeVertices = mergeVertices;

    const hud = document.getElementById("hud");
    
    // Consolidated debug output (single HUD box). Also captures errors so you don't need devtools.
    const __hudLines = []; // rolling buffer for HUD + errors; copied by the Copy HUD button
    const __hudMaxLines = 180;

    function hudPush(line){
      const s = String(line ?? "");
      if (!s) return;
      __hudLines.push(s);
      __uiEcho(s);
      while (__hudLines.length > __hudMaxLines) __hudLines.shift();
      hud.textContent = __hudLines.join("\n");
    }

    function __uiEcho(line){
      try{ if (globalThis.__uiLog) globalThis.__uiLog(line); }catch(_){ }
    }


    // Replace setHud to also push into the consolidated buffer.
    const setHud = (t)=>{
      const s = String(t ?? "");
      // If someone passes multi-line blocks, preserve them as lines.
      for (const line of s.split(/\r?\n/)) hudPush(line);
    };

    window.addEventListener("error", (e)=>{
      hudPush("JS ERROR: " + (e?.message || e?.error || "unknown"));
      if (e?.filename) hudPush("  at " + e.filename + ":" + e.lineno);
    });

    const __origErr = console.error.bind(console);
    const __origWarn = console.warn.bind(console);
    console.error = (...args)=>{ 
      try{ hudPush("console.error: " + args.map(a=>String(a)).join(" ").slice(0,240)); }catch(_e){}
      __origErr(...args);
    };
    console.warn = (...args)=>{ 
      try{ hudPush("console.warn: " + args.map(a=>String(a)).join(" ").slice(0,240)); }catch(_e){}
      __origWarn(...args);
    };

const $ = (id)=>document.getElementById(id);
  // Safe DOM helpers (mobile-friendly; prevents null deref when UI elements are missing)
  const $el = (id)=>document.getElementById(id);
  const $val = (id, fallback="")=>{ const el = $el(id); return el ? el.value : fallback; };
  const $chk = (id, fallback=false)=>{ const el = $el(id); return el ? !!el.checked : fallback; };

  // ============================================================================
  // VOXEL TYPE SYSTEM - Terrain Types (Grass, Rivers, Roads)
  // ============================================================================
  const VOXEL_TYPES = {
    EMPTY: 0,
    GRASS_FLAT: 1,
    GRASS_RAMP_N: 2,
    GRASS_RAMP_S: 3,
    GRASS_RAMP_E: 4,
    GRASS_RAMP_W: 5,
    DIRT: 6,
    STONE: 7,
    RIVER_N: 10,
    RIVER_S: 11,
    RIVER_E: 12,
    RIVER_W: 13,
    RIVER_NE: 14,
    RIVER_NW: 15,
    RIVER_SE: 16,
    RIVER_SW: 17,
    ROAD_NS: 20,
    ROAD_EW: 21,
    ROAD_NE: 22,
    ROAD_NW: 23,
    ROAD_SE: 24,
    ROAD_SW: 25,
    ROAD_CROSS: 26,
    ROAD_RAMP_N: 27,
    ROAD_RAMP_S: 28,
    ROAD_RAMP_E: 29,
    ROAD_RAMP_W: 30,
    // Tree spawn masks (areas, not literal placement)
    FOREST: 40,
    TREE_BARRIER: 41,
  };

  const VOXEL_COLORS = {
    [VOXEL_TYPES.EMPTY]: 0x000000,
    [VOXEL_TYPES.GRASS_FLAT]: 0x4a7c3e,
    [VOXEL_TYPES.GRASS_RAMP_N]: 0x5a8c4e,
    [VOXEL_TYPES.GRASS_RAMP_S]: 0x5a8c4e,
    [VOXEL_TYPES.GRASS_RAMP_E]: 0x5a8c4e,
    [VOXEL_TYPES.GRASS_RAMP_W]: 0x5a8c4e,
    [VOXEL_TYPES.DIRT]: 0x8b6f47,
    [VOXEL_TYPES.STONE]: 0x666666,
    [VOXEL_TYPES.RIVER_N]: 0x4a9fdf,      // Brighter blue for visibility
    [VOXEL_TYPES.RIVER_S]: 0x4a9fdf,      // Brighter blue
    [VOXEL_TYPES.RIVER_E]: 0x4a9fdf,      // Brighter blue
    [VOXEL_TYPES.RIVER_W]: 0x4a9fdf,      // Brighter blue
    [VOXEL_TYPES.RIVER_NE]: 0x5aafef,     // Even brighter for corners
    [VOXEL_TYPES.RIVER_NW]: 0x5aafef,     // Even brighter for corners
    [VOXEL_TYPES.RIVER_SE]: 0x5aafef,     // Even brighter for corners
    [VOXEL_TYPES.RIVER_SW]: 0x5aafef,     // Even brighter for corners
    [VOXEL_TYPES.ROAD_NS]: 0x888888,
    [VOXEL_TYPES.ROAD_EW]: 0x888888,
    [VOXEL_TYPES.ROAD_NE]: 0x999999,
    [VOXEL_TYPES.ROAD_NW]: 0x999999,
    [VOXEL_TYPES.ROAD_SE]: 0x999999,
    [VOXEL_TYPES.ROAD_SW]: 0x999999,
    [VOXEL_TYPES.ROAD_CROSS]: 0xaaaaaa,
    [VOXEL_TYPES.ROAD_RAMP_N]: 0x777777,
    [VOXEL_TYPES.ROAD_RAMP_S]: 0x777777,
    [VOXEL_TYPES.ROAD_RAMP_E]: 0x777777,
    [VOXEL_TYPES.ROAD_RAMP_W]: 0x777777,
    [VOXEL_TYPES.FOREST]: 0x1f7a2e,        // Forest area mask
    [VOXEL_TYPES.TREE_BARRIER]: 0xb02fb0,  // Dense tree barrier mask (high visibility)
  };

  const VOXEL_NAMES = {
    [VOXEL_TYPES.EMPTY]: 'Empty',
    [VOXEL_TYPES.GRASS_FLAT]: 'Grass Flat',
    [VOXEL_TYPES.GRASS_RAMP_N]: 'Grass Ramp N',
    [VOXEL_TYPES.GRASS_RAMP_S]: 'Grass Ramp S',
    [VOXEL_TYPES.GRASS_RAMP_E]: 'Grass Ramp E',
    [VOXEL_TYPES.GRASS_RAMP_W]: 'Grass Ramp W',
    [VOXEL_TYPES.DIRT]: 'Dirt',
    [VOXEL_TYPES.STONE]: 'Stone',
    [VOXEL_TYPES.RIVER_N]: 'River N',
    [VOXEL_TYPES.RIVER_S]: 'River S',
    [VOXEL_TYPES.RIVER_E]: 'River E',
    [VOXEL_TYPES.RIVER_W]: 'River W',
    [VOXEL_TYPES.RIVER_NE]: 'River NE',
    [VOXEL_TYPES.RIVER_NW]: 'River NW',
    [VOXEL_TYPES.RIVER_SE]: 'River SE',
    [VOXEL_TYPES.RIVER_SW]: 'River SW',
    [VOXEL_TYPES.ROAD_NS]: 'Road N-S',
    [VOXEL_TYPES.ROAD_EW]: 'Road E-W',
    [VOXEL_TYPES.ROAD_NE]: 'Road NE',
    [VOXEL_TYPES.ROAD_NW]: 'Road NW',
    [VOXEL_TYPES.ROAD_SE]: 'Road SE',
    [VOXEL_TYPES.ROAD_SW]: 'Road SW',
    [VOXEL_TYPES.ROAD_CROSS]: 'Road Cross',
    [VOXEL_TYPES.ROAD_RAMP_N]: 'Road Ramp N',
    [VOXEL_TYPES.ROAD_RAMP_S]: 'Road Ramp S',
    [VOXEL_TYPES.ROAD_RAMP_E]: 'Road Ramp E',
    [VOXEL_TYPES.ROAD_RAMP_W]: 'Road Ramp W',
    [VOXEL_TYPES.FOREST]: 'Forest (tree area)',
    [VOXEL_TYPES.TREE_BARRIER]: 'Tree Barrier (dense area)',
  };
  
  // Helper: Get color for a voxel type
  function getVoxelColor(voxelType) {
    return VOXEL_COLORS[voxelType] || 0xffffff;
  }
  
  // Helper: Check if voxel is empty
  function isVoxelEmpty(voxelType) {
    return voxelType === VOXEL_TYPES.EMPTY || voxelType === 0;
  }
  
  // Helper: Check if voxel is solid (not empty)
  function isVoxelSolid(voxelType) {
    return voxelType !== VOXEL_TYPES.EMPTY && voxelType !== 0;
  }
  

// Helper: Check if voxel type is river/water (used for material routing)
function isRiverVoxelType(voxelType) {
  return voxelType >= VOXEL_TYPES.RIVER_N && voxelType <= VOXEL_TYPES.RIVER_SW;
}

// Alias (future-proof if we add lakes/ocean types)
function isWaterVoxelType(voxelType) {
  return isRiverVoxelType(voxelType);
}
// ============================================================================
    // Mobile-friendly: copy HUD text for sharing/debugging (no devtools needed).
    async function copyTextToClipboard(text){
      const str = String(text ?? "");
      if (!str) return false;
      try{
        if (navigator.clipboard && navigator.clipboard.writeText){
          await navigator.clipboard.writeText(str);
          return true;
        }
      }catch(_e){ /* fall through */ }

      // Fallback path (some Android WebViews block navigator.clipboard)
      try{
        const ta = document.createElement('textarea');
        ta.value = str;
        ta.setAttribute('readonly', '');
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        ta.setSelectionRange(0, ta.value.length);
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return !!ok;
      }catch(_e2){
        return false;
      }
    }

    
const grassDenVal = $("grassDenVal");
const syncGrassDenLabel = ()=>{
  const el = $("grassDen");
  if (grassDenVal && el) grassDenVal.textContent = (+el.value).toFixed(1);
};
if ($("grassDen")) $("grassDen").addEventListener("input", syncGrassDenLabel);
syncGrassDenLabel();

// GrassHeight (shader) slider
const grassHeightVal = $("grassHeightVal");
const syncGrassHeightLabel = ()=>{
  const el = $("grassHeight");
  if (!el) return;
  const v = +el.value;
  if (grassHeightVal) grassHeightVal.textContent = v.toFixed(2);

  const st = globalThis.StylizedTerrainShader;
  if (st && st.styleGrass && st.styleGrass.grassHeight) st.styleGrass.grassHeight.value = v;
  else if (st && st.style && st.style.grassHeight) st.style.grassHeight.value = v;
  if (globalThis.u && globalThis.u.grassHeight) globalThis.u.grassHeight.value = v;
};
if ($("grassHeight")) $("grassHeight").addEventListener("input", syncGrassHeightLabel);
syncGrassHeightLabel();



// GrassDetail (shader frequency) slider (shared across presets)
const grassFreqVal = $("grassFreqVal");
const syncGrassFreqLabel = ()=>{
  const el = $("grassFreq");
  if (!el) return;
  const v = +el.value;
  if (grassFreqVal) grassFreqVal.textContent = String(Math.round(v));

  const st = globalThis.StylizedTerrainShader;
  if (st && st.styleGrass && st.styleGrass.grassFreq) st.styleGrass.grassFreq.value = v;
  else if (st && st.style && st.style.grassFreq) st.style.grassFreq.value = v;
  if (globalThis.u && globalThis.u.grassFreq) globalThis.u.grassFreq.value = v;
};
if ($("grassFreq")) $("grassFreq").addEventListener("input", syncGrassFreqLabel);
syncGrassFreqLabel();


// GrassSubdiv (geometry detail) slider (affects vertex density; requires Regenerate)
const grassSubdivVal = $("grassSubdivVal");
const syncGrassSubdivLabel = ()=>{
  const el = $("grassSubdiv");
  if (!el) return;
  const v = parseInt(el.value, 10) || 0;
  if (grassSubdivVal) grassSubdivVal.textContent = String(v);
};
if ($("grassSubdiv")) $("grassSubdiv").addEventListener("input", syncGrassSubdivLabel);
syncGrassSubdivLabel();

// GrassWidth (tuft width/narrowness) slider
const grassWidthVal = $("grassWidthVal");
const syncGrassWidthLabel = ()=>{
  const el = $("grassWidth");
  if (!el) return;
  const v = +el.value;
  if (grassWidthVal) grassWidthVal.textContent = v.toFixed(2);
  
  const st = globalThis.StylizedTerrainShader;
  if (st && st.styleGrass && st.styleGrass.grassWidth) st.styleGrass.grassWidth.value = v;
  else if (st && st.style && st.style.grassWidth) st.style.grassWidth.value = v;
  if (globalThis.u && globalThis.u.grassWidth) globalThis.u.grassWidth.value = v;
};
if ($("grassWidth")) $("grassWidth").addEventListener("input", syncGrassWidthLabel);
syncGrassWidthLabel();

// Grass Blade Controls

// Wind direction pad (2D, XZ only; ignores up/down)
(function initWindPad(){
  const pad = $("windPad");
  const dot = $("windDot");
  const out = $("windDirVal");
  if (!pad || !dot) return;

  // Internal state stored on global u (used by shaders) and in params via hidden vars.
  let wx = 0.0, wz = 0.0; // used by regen + live update

  const dead = 0.08; // mobile-friendly center deadzone

  function setFromNorm(nx, nz, {emit=true}={}){
    // clamp to [-1,1]
    let x = Math.max(-1, Math.min(1, nx));
    let z = Math.max(-1, Math.min(1, nz));

    // deadzone
    if (Math.hypot(x, z) < dead){ x = 0; z = 0; }

    wx = x; wz = z;

    // place dot
    const rect = pad.getBoundingClientRect();
    const px = (x * 0.5 + 0.5) * rect.width;
    const pz = (z * 0.5 + 0.5) * rect.height;
    dot.style.left = `${px}px`;
    dot.style.top  = `${pz}px`;

    if (out) out.textContent = `${wx.toFixed(2)},${wz.toFixed(2)}`;

    // live-update shader uniforms (both sets so outlines match)
    const st = globalThis.StylizedTerrainShader;
    if (st){
      if (st.styleGrass?.windVel?.value) st.styleGrass.windVel.value.set(wx, 0, wz);
      if (st.styleRock?.windVel?.value)  st.styleRock.windVel.value.set(wx, 0, wz);
      if (st.style?.windVel?.value)      st.style.windVel.value.set(wx, 0, wz); // backward compat
    }

    // also keep global uniforms if present
    if (globalThis.u?.windVel?.value) globalThis.u.windVel.value.set(wx, 0, wz);

    // stash for readParams()
    pad.dataset.wx = String(wx);
    pad.dataset.wz = String(wz);

    if (emit){
      // Don't auto-regenerate; wind should be responsive without regen.
      // Regen will still pick it up via readParams() when you hit Regenerate.
    }
  }

  function readFromPointer(ev){
    const rect = pad.getBoundingClientRect();
    const x = (ev.clientX - rect.left) / rect.width;   // 0..1
    const z = (ev.clientY - rect.top) / rect.height;   // 0..1
    const nx = (x - 0.5) * 2.0;
    const nz = (z - 0.5) * 2.0;
    setFromNorm(nx, nz);
  }

  let dragging = false;
  function onDown(ev){
    dragging = true;
    try{ pad.setPointerCapture(ev.pointerId); }catch(_e){}
    readFromPointer(ev);
    ev.preventDefault();
    ev.stopPropagation();
  }
  function onMove(ev){
    if (!dragging) return;
    readFromPointer(ev);
    ev.preventDefault();
    ev.stopPropagation();
  }
  function onUp(ev){
    dragging = false;
    try{ pad.releasePointerCapture(ev.pointerId); }catch(_e){}
    ev.preventDefault();
    ev.stopPropagation();
  }

  // Pointer events cover mouse + touch on modern mobile browsers.
  pad.addEventListener("pointerdown", onDown, {passive:false});
  window.addEventListener("pointermove", onMove, {passive:false});
  window.addEventListener("pointerup", onUp, {passive:false});
  window.addEventListener("pointercancel", onUp, {passive:false});

  // initialize from dataset if any
  const initWx = parseFloat(pad.dataset.wx || "0");
  const initWz = parseFloat(pad.dataset.wz || "0");
  setFromNorm(initWx, initWz, {emit:false});
  // expose for AutoWind + debugging
  globalThis.__windPadSetNorm = (nx, nz, opts)=>setFromNorm(nx, nz, opts||{});
  globalThis.__windPadGetNorm = ()=>({ x: wx, z: wz });

})();

// Accumulation Controls (snow/moss) ‚Äî mutually exclusive with grass
(function initAccumulationControls(){
  const $ = (id)=>document.getElementById(id);
  const st = ()=>globalThis.StylizedTerrainShader;
  const hudPush = globalThis.hudPush || ((msg)=>{ try{ console.log(msg); }catch(_e){} });

  const idsGrassDisable = [
    "grassOn","grassDen","grassHeight","grassFreq","grassSubdiv","grassWidth","grassLean","grassThk","grassUpAxis"
  ];

  const idsAccum = [
    "accumKind","accumHeight","accumNoiseScale","accumLayers","accumLayerBulge","accumLayerSharpness",
    "accumSlopeStart","accumSlopeEnd","accumEdgeHold","accumEdgePow","accumTint","accumTintHex","accumTintStrength"
  ];

  const hasUI = idsAccum.every(id => $(id));
  if (!hasUI) return;

  const clamp = (v, a, b)=>Math.max(a, Math.min(b, v));
  const fmt2 = (v)=>Number.isFinite(v)? v.toFixed(2) : "0.00";

  function normalizeHex(str){
    if (!str) return null;
    let s = String(str).trim();
    if (!s.startsWith("#")) s = "#"+s;
    if (!/^#[0-9a-fA-F]{6}$/.test(s)) return null;
    return s.toLowerCase();
  }

  function setGrassUIEnabled(enabled){
    for (const id of idsGrassDisable){
      const el = $(id);
      if (!el) continue;
      // grassOn is handled specially
      if (id === "grassOn") continue;
      el.disabled = !enabled;
    }
  }

  let _enforcing = false;

  function enforceMutualExclusivity(){
    if (_enforcing) return;
    _enforcing = true;

    const topMat = $("topMat");
    const grassOn = $("grassOn");
    const kind = $("accumKind")?.value || "none";
    const wantsAccum = (kind !== "none") || (topMat && topMat.value === "accumulation");

    if (topMat && wantsAccum && topMat.value !== "accumulation"){
      topMat.value = "accumulation";
      // Changing topMat affects geometry; fire change to regenerate
      topMat.dispatchEvent(new Event("change", { bubbles:true }));
      hudPush("[Accumulation] Switched Substance ‚Üí accumulation (disables grass).");
    }

    if (grassOn){
      if (wantsAccum){
        grassOn.checked = false;
        grassOn.disabled = true;
        setGrassUIEnabled(false);
      } else {
        grassOn.disabled = false;
        setGrassUIEnabled(true);
      }
    }

    // Accumulation sliders enabled only if kind != none
    const enableAccumSliders = (kind !== "none");
    for (const id of idsAccum){
      const el = $(id);
      if (!el) continue;
      if (id === "accumKind" || id === "accumTintHex" || id === "accumTint") continue;
      el.disabled = !enableAccumSliders;
    }
    const tintEl = $("accumTint"); if (tintEl) tintEl.disabled = !enableAccumSliders;
    const tintHexEl = $("accumTintHex"); if (tintHexEl) tintHexEl.disabled = !enableAccumSliders;

    _enforcing = false;
  }

  const defaultsByKind = {
    none: {
      height: 0.0, noiseScale: 1.1, layers: 0, bulge: 0.65, sharp: 2.5, slopeStart: 0.2, slopeEnd: 0.7, edgeHold: 1.0, edgePow: 2.5,
      tint: "#ebf6ff", tintStrength: 0.0
    },
    snow: {
      height: 1.00, noiseScale: 1.1, layers: 5, bulge: 0.65, sharp: 2.5, slopeStart: 0.0, slopeEnd: 1, edgeHold: 1.0, edgePow: 0,
      tint: "#ebf6ff", tintStrength: 1.0
    },
    moss: {
      height: 0.08, noiseScale: 2.2, layers: 2, bulge: 0.30, sharp: 1.6, slopeStart: 0.1, slopeEnd: 0.6, edgeHold: 1.0, edgePow: 0,
      tint: "#2f8f4f", tintStrength: 0.65
    }
  };

  function setAccumUIFromValues(v){
    const set = (id, val)=>{ const el = $(id); if (el) el.value = String(val); };
    set("accumHeight", v.height);
    set("accumNoiseScale", v.noiseScale);
    set("accumLayers", v.layers);
    set("accumLayerBulge", v.bulge);
    set("accumLayerSharpness", v.sharp);
    set("accumSlopeStart", v.slopeStart);
    set("accumSlopeEnd", v.slopeEnd);
    set("accumEdgeHold", v.edgeHold);
    set("accumEdgePow", v.edgePow);
    set("accumTintStrength", v.tintStrength);
    const tint = normalizeHex(v.tint) || "#ebf6ff";
    const tintEl = $("accumTint"); if (tintEl) tintEl.value = tint;
    const tintHexEl = $("accumTintHex"); if (tintHexEl) tintHexEl.value = tint;
  }

  function setPill(id, txt){
    const el = $(id);
    if (el) el.textContent = txt;
  }

  function syncPills(){
    setPill("accumHeightVal", fmt2(parseFloat($("accumHeight").value)));
    setPill("accumNoiseScaleVal", fmt2(parseFloat($("accumNoiseScale").value)));
    setPill("accumLayersVal", String(parseInt($("accumLayers").value,10) || 0));
    setPill("accumLayerBulgeVal", fmt2(parseFloat($("accumLayerBulge").value)));
    setPill("accumLayerSharpnessVal", fmt2(parseFloat($("accumLayerSharpness").value)));
    setPill("accumSlopeStartVal", fmt2(parseFloat($("accumSlopeStart").value)));
    setPill("accumSlopeEndVal", fmt2(parseFloat($("accumSlopeEnd").value)));
    setPill("accumEdgeHoldVal", fmt2(parseFloat($("accumEdgeHold").value)));
    setPill("accumEdgePowVal", fmt2(parseFloat($("accumEdgePow").value)));
    setPill("accumTintStrengthVal", fmt2(parseFloat($("accumTintStrength").value)));
  }

  function applyAccumulationToShader(){
    const shader = st();
    const style = shader ? (shader.styleRock || shader.style) : (globalThis.u || null);
    if (!style) return;

    const kind = $("accumKind").value || "none";
    const enabled = kind !== "none";

    const height = clamp(parseFloat($("accumHeight").value), 0, 10);
    const noiseScale = clamp(parseFloat($("accumNoiseScale").value), 0.01, 999);
    const layers = clamp(parseInt($("accumLayers").value, 10) || 0, 0, 64);
    const bulge = clamp(parseFloat($("accumLayerBulge").value), 0, 10);
    const sharp = clamp(parseFloat($("accumLayerSharpness").value), 0.01, 999);
    const slopeStart = clamp(parseFloat($("accumSlopeStart").value), 0, 1);
    const slopeEnd = clamp(parseFloat($("accumSlopeEnd").value), 0, 1);
    const edgeHold = clamp(parseFloat($("accumEdgeHold").value), 0, 1);
    const edgePow  = clamp(parseFloat($("accumEdgePow").value), 0.05, 999);
    const tintStrength = clamp(parseFloat($("accumTintStrength").value), 0, 1);

    const hex = normalizeHex($("accumTintHex").value) || normalizeHex($("accumTint").value) || "#ebf6ff";
    $("accumTint").value = hex;
    $("accumTintHex").value = hex;

    if (style.snowHeight) style.snowHeight.value = enabled ? height : 0.0;
    if (style.snowNoiseScale) style.snowNoiseScale.value = noiseScale;
    if (style.snowLayers) style.snowLayers.value = layers;
    if (style.snowLayerBulge) style.snowLayerBulge.value = bulge;
    if (style.snowLayerSharpness) style.snowLayerSharpness.value = sharp;
    if (style.snowSlopeStart) style.snowSlopeStart.value = slopeStart;
    if (style.snowSlopeEnd) style.snowSlopeEnd.value = slopeEnd;
    if (style.snowEdgeHold) style.snowEdgeHold.value = edgeHold;
    if (style.snowEdgePow)  style.snowEdgePow.value  = edgePow;
    if (style.snowTintStrength) style.snowTintStrength.value = enabled ? tintStrength : 0.0;
    if (style.snowTintColor && style.snowTintColor.value && typeof style.snowTintColor.value.set === "function") {
      style.snowTintColor.value.set(hex);
    }
  }

  function onKindChanged(){
    const kind = $("accumKind").value || "none";
    const d = defaultsByKind[kind] || defaultsByKind.none;
    setAccumUIFromValues(d);
    syncPills();
    enforceMutualExclusivity();
    applyAccumulationToShader();
  }

  // Expose a helper so biome switching can sync UI from current uniforms
  globalThis.syncAccumulationUIFromShader = function syncAccumulationUIFromShader(){
    const shader = st();
    const style = shader ? (shader.styleRock || shader.style) : (globalThis.u || null);
    if (!style) return;

    // Determine kind based on whether snowHeight is > 0 (heuristic)
    const h = style.snowHeight ? (style.snowHeight.value || 0) : 0;
    const currentKind = $("accumKind").value || "none";
    if (h <= 0.0001 && currentKind !== "none"){
      $("accumKind").value = "none";
    }

    // Pull values into UI (do not change kind unless snow is clearly enabled)
    if (h > 0.0001 && currentKind === "none"){
      $("accumKind").value = "snow";
    }

    const get = (u, fallback)=> (u && typeof u.value === "number") ? u.value : fallback;
    $("accumHeight").value = String(get(style.snowHeight, parseFloat($("accumHeight").value)));
    $("accumNoiseScale").value = String(get(style.snowNoiseScale, parseFloat($("accumNoiseScale").value)));
    $("accumLayers").value = String(Math.round(get(style.snowLayers, parseFloat($("accumLayers").value))));
    $("accumLayerBulge").value = String(get(style.snowLayerBulge, parseFloat($("accumLayerBulge").value)));
    $("accumLayerSharpness").value = String(get(style.snowLayerSharpness, parseFloat($("accumLayerSharpness").value)));
    $("accumSlopeStart").value = String(get(style.snowSlopeStart, parseFloat($("accumSlopeStart").value)));
    $("accumSlopeEnd").value = String(get(style.snowSlopeEnd, parseFloat($("accumSlopeEnd").value)));
    $("accumEdgeHold").value = String(get(style.snowEdgeHold, parseFloat($("accumEdgeHold").value)));
    $("accumEdgePow").value = String(get(style.snowEdgePow, parseFloat($("accumEdgePow").value)));
    $("accumTintStrength").value = String(get(style.snowTintStrength, parseFloat($("accumTintStrength").value)));

    let hex = null;
    try{
      if (style.snowTintColor && style.snowTintColor.value){
        const c = style.snowTintColor.value;
        if (typeof c.getHexString === "function") hex = "#"+c.getHexString();
      }
    }catch(_e){}
    hex = normalizeHex(hex) || normalizeHex($("accumTintHex").value) || "#ebf6ff";
    $("accumTint").value = hex;
    $("accumTintHex").value = hex;

    syncPills();
    enforceMutualExclusivity();
  };

  // Events
  $("accumKind").addEventListener("change", onKindChanged);

  // Sliders: live update
  for (const id of ["accumHeight","accumNoiseScale","accumLayers","accumLayerBulge","accumLayerSharpness","accumSlopeStart","accumSlopeEnd","accumEdgeHold","accumEdgePow","accumTintStrength"]){
    $(id).addEventListener("input", ()=>{
      syncPills();
      enforceMutualExclusivity();
      applyAccumulationToShader();
    });
  }

  // Color picker ‚Üí hex
  $("accumTint").addEventListener("input", ()=>{
    const hex = normalizeHex($("accumTint").value) || "#ebf6ff";
    $("accumTintHex").value = hex;
    enforceMutualExclusivity();
    applyAccumulationToShader();
  });

  // Hex ‚Üí color picker
  $("accumTintHex").addEventListener("change", ()=>{
    const hex = normalizeHex($("accumTintHex").value);
    if (!hex){
      // revert to current picker color
      $("accumTintHex").value = normalizeHex($("accumTint").value) || "#ebf6ff";
      return;
    }
    $("accumTint").value = hex;
    enforceMutualExclusivity();
    applyAccumulationToShader();
  });

  // Substance changes
  const topMat = $("topMat");
  if (topMat){
    topMat.addEventListener("change", ()=>{
      const kindEl = $("accumKind");
      const kind = kindEl ? (kindEl.value || "none") : "none";

      if (topMat.value === "accumulation" && kind === "none"){
        // Helpful default: picking accumulation implies "snow" unless user says otherwise
        if (kindEl) kindEl.value = "snow";
        onKindChanged();
        return;
      }

      // If user flips away from accumulation, also disable accumulation (keeps rule consistent)
      if (topMat.value !== "accumulation" && kind !== "none"){
        if (kindEl) kindEl.value = "none";
      }

      enforceMutualExclusivity();
      applyAccumulationToShader();
    });
  }

  // Initialize
  syncPills();
  enforceMutualExclusivity();
  applyAccumulationToShader();
})();
;
// WindStrength (grass only) slider: scales wind response so tiny wind isn't a hurricane after subdivision
(function initWindStrength(){
  const el = $("windStrength");
  const out = $("windStrengthVal");
  if (!el) return;

  const apply = ()=>{
    const v = Math.max(0, Math.min(1, parseFloat(el.value)||0));
    if (out) out.textContent = v.toFixed(2);
    const st = globalThis.StylizedTerrainShader;
    if (st?.styleGrass?.windStrength?.value !== undefined) st.styleGrass.windStrength.value = v;
    // backward compat: if a single style exists, set it too
    if (st?.style?.windStrength?.value !== undefined) st.style.windStrength.value = v;
  };

  el.addEventListener("input", apply, {passive:true});
  apply();
})();



// AutoWind (testing): rotates wind direction automatically so you can see grass motion without fiddling.
(function initAutoWind(){
  const chk = $("windAuto");
  const spd = $("windAutoSpeed");
  const out = $("windAutoSpeedVal");
  if (!chk) return;

  const wa = (globalThis.__windAuto = globalThis.__windAuto || { enabled:false, speed:1.0, debug:true });

  const applySpeed = ()=>{
    if (!spd) return;
    const v = Math.max(0, Math.min(4, parseFloat(spd.value)||0));
    wa.speed = v;
    if (out) out.textContent = v.toFixed(2);
  };

  chk.addEventListener("change", ()=>{
    wa.enabled = !!chk.checked;
    hudPush("AutoWind: " + (wa.enabled ? "ON" : "OFF"));
  }, {passive:true});

  if (spd) spd.addEventListener("input", applySpeed, {passive:true});
  applySpeed();
})();

// Seasonal System (Andes highlands wet/dry seasons)

// ============================================================================
// INTEGRATED TIME & SEASON SYSTEM (Andean Climate)
// ============================================================================
(function initIntegratedTimeSeasonSystem(){
  // Time controls
  const timeSlider = $("timeOfDay");
  const timeDisplay = $("timeOfDayVal");
  const btnSunrise = $("timeSunrise");
  const btnNoon = $("timeNoon");
  const btnSunset = $("timeSunset");
  const btnMidnight = $("timeMidnight");
  
  // Season controls
  const seasonSlider = $("seasonSlider");
  const seasonDisplay = $("seasonVal");
  const biomeSelect = $("biomeSelect");
  const biomeDesc = $("biomeDesc");
  const seasonDesc0 = $("seasonDesc0");
  const seasonDesc1 = $("seasonDesc1");

  const btnDry = $("seasonDry");
  const btnMid = $("seasonMid");
  const btnWet = $("seasonWet");
  
  // Auto-cycle controls
  const chkAuto = $("timeCycleAuto");
  const dayLengthInput = $("dayLength");
  const dayLengthDisplay = $("dayLengthVal");
  const daysPerSeasonInput = $("daysPerSeason");
  const daysPerSeasonDisplay = $("daysPerSeasonVal");
  const cycleInfoDisplay = $("cycleInfo");
  
  if (!timeSlider || !seasonSlider) return;

  function __applyBiomeToShader(key){
    const st = globalThis.StylizedTerrainShader;
    if (!st || typeof st.setBiomeMode !== "function") return false;
    const ok = st.setBiomeMode(key);
    if (ok) {
      const b = (typeof st.getBiomeProfile === "function") ? st.getBiomeProfile() : null;
      if (biomeDesc && b && b.desc) biomeDesc.textContent = b.desc;
      if (seasonDesc0 && b && b.seasonDesc0) seasonDesc0.textContent = b.seasonDesc0;
      if (seasonDesc1 && b && b.seasonDesc1) seasonDesc1.textContent = b.seasonDesc1;
      hudPush(`[Biome] ${b && b.label ? b.label : key}`);
      if (typeof globalThis.syncAccumulationUIFromShader === "function") { globalThis.syncAccumulationUIFromShader(); }
    } else {
      hudPush(`[Biome] Unknown key: ${key}`);
    }
    return ok;
  }

  
  // State
  const state = globalThis.__integratedTimeSeasonState = globalThis.__integratedTimeSeasonState || {
    timeOfDay: 12.0,          // 0-24 hours
    seasonValue: 0.5,         // 0.0 = dry, 1.0 = wet
    biomeKey: "andes_highlands", // currently active biome profile (used by shader)
    dayCount: 0,              // Days elapsed (fractional)
    auto: false,              // Auto-cycle enabled
    dayLengthSec: 60,         // How many real seconds = 1 game day
    daysPerSeason: 3,         // How many game days for full seasonal cycle
    latitude: -15.0,          // Andean highlands average latitude
    sunriseTime: 6.0,         // 6am
    sunsetTime: 18.0,         // 6pm (12-hour days near equator)
  };

  // Biome selector wiring
  if (biomeSelect){
    // Keep UI + shader in sync (persists via __integratedTimeSeasonState)
    biomeSelect.value = state.biomeKey || "andes_highlands";
    biomeSelect.addEventListener("change", ()=>{
      state.biomeKey = biomeSelect.value;
      __applyBiomeToShader(state.biomeKey);
      // Re-apply current season so coverage/snow height update immediately
      applyTimeAndSeason(state.timeOfDay, state.seasonValue);
    }, {passive:true});
  }

  // Apply initial biome (if shader is ready)
  __applyBiomeToShader(state.biomeKey);

  // Calculate sun position and atmospheric properties for current time
  function calculateSunPosition(hour, seasonValue) {
    const h = hour % 24;
    
    // Near equator, days are ~12 hours year-round
    // But sun angle varies with season (¬±23.5¬∞ declination)
    const seasonalTilt = (seasonValue - 0.5) * 23.5; // -11.75¬∞ to +11.75¬∞ for Andes at 15¬∞S
    
    // Calculate sun elevation angle
    let elevation;
    if (h < state.sunriseTime || h > state.sunsetTime) {
      // Night - sun below horizon
      elevation = -15; // Below horizon
    } else {
      // Daytime - sun arc
      const dayProgress = (h - state.sunriseTime) / (state.sunsetTime - state.sunriseTime);
      
      // Parabolic arc for sun elevation
      const noonElevation = 90 - Math.abs(state.latitude - seasonalTilt);
      elevation = Math.sin(dayProgress * Math.PI) * noonElevation;
    }
    
    // Calculate azimuth (compass direction)
    let azimuth;
    if (h < state.sunriseTime || h > state.sunsetTime) {
      azimuth = 0; // Midnight position (north)
    } else {
      const dayProgress = (h - state.sunriseTime) / (state.sunsetTime - state.sunriseTime);
      azimuth = 90 + dayProgress * 180; // East (90¬∞) to West (270¬∞)
    }
    
    return { elevation, azimuth, hour: h };
  }
  
  // Get atmospheric properties based on time and season
  function getAtmosphericProperties(hour, seasonValue, stormState) {
    const { elevation, azimuth } = calculateSunPosition(hour, seasonValue);
    const h = hour % 24;
    
    // Altitude clarity factor (0.85 = very clear Andean highlands)
    const altitudeClarity = $("altitudeClarity") ? parseFloat($("altitudeClarity").value) : 0.85;
    
    // Season affects atmosphere
    // Dry season (0.0): Very clear, low fog, deep blue
    // Wet season (1.0): More haze, morning fog, softer light
    const dryness = 1.0 - seasonValue;
    const wetness = seasonValue;
    
    // Sky color based on sun elevation (smooth transitions!)
    let skyColor;
    
    if (elevation < -12) {
      // Deep night - sun far below horizon
      skyColor = { r: 0.02, g: 0.03, b: 0.08 };
    } else if (elevation < -6) {
      // Late twilight ‚Üí night transition
      const t = (elevation + 12) / 6; // 0 at -12¬∞, 1 at -6¬∞
      skyColor = {
        r: 0.08 * (1 - t) + 0.02 * t,
        g: 0.10 * (1 - t) + 0.03 * t,
        b: 0.20 * (1 - t) + 0.08 * t
      };
    } else if (elevation < 0) {
      // Twilight - sun just below horizon (civil twilight)
      const t = (elevation + 6) / 6; // 0 at -6¬∞, 1 at 0¬∞
      skyColor = {
        r: 0.08 * (1 - t) + 0.35 * t,
        g: 0.10 * (1 - t) + 0.25 * t,
        b: 0.20 * (1 - t) + 0.45 * t
      };
    } else if (elevation < 3) {
      // Golden hour - sun just above horizon
      const t = elevation / 3; // 0 at 0¬∞, 1 at 3¬∞
      skyColor = {
        r: 0.95 * (1 - t) + 0.85 * t,
        g: 0.45 * (1 - t) + 0.60 * t,
        b: 0.30 * (1 - t) + 0.70 * t
      };
    } else if (elevation < 10) {
      // Early morning/late afternoon
      const t = (elevation - 3) / 7; // 0 at 3¬∞, 1 at 10¬∞
      skyColor = {
        r: 0.85 * (1 - t) + (0.45 + wetness * 0.15) * t,
        g: 0.60 * (1 - t) + (0.65 + wetness * 0.10) * t,
        b: 0.70 * (1 - t) + (0.85 - wetness * 0.15 + altitudeClarity * 0.10) * t
      };
    } else {
      // Full daylight - deep blue
      const baseBlue = 0.85 - wetness * 0.15;
      skyColor = {
        r: 0.45 + wetness * 0.15,
        g: 0.65 + wetness * 0.10,
        b: baseBlue + altitudeClarity * 0.10
      };
    }
    
    // Storm override - darken sky dramatically
    if (stormState && stormState.active && stormState.intensity > 0) {
      const stormDarkness = stormState.intensity * 0.75; // How much to darken
      skyColor.r *= (1 - stormDarkness);
      skyColor.g *= (1 - stormDarkness * 0.85); // Slight green tint to storm clouds
      skyColor.b *= (1 - stormDarkness * 0.7);  // Keep some blue
      
      // Add slight green/yellow cast to storm clouds
      skyColor.g += stormState.intensity * 0.08;
      skyColor.r += stormState.intensity * 0.05;
    }
    
    // Fog density
    let fogDensity;
    if (elevation < -6) {
      // Night fog
      fogDensity = 0.001 + wetness * 0.002;
    } else if (elevation < 0) {
      // Twilight - fog forming/clearing
      const t = (elevation + 6) / 6;
      fogDensity = (0.001 + wetness * 0.002) * (1 - t) + (0.001 + wetness * 0.003) * t;
    } else if (h >= state.sunriseTime && h < state.sunriseTime + 2 && wetness > 0.5) {
      // Morning fog in wet season (burns off over 2 hours)
      const t = (h - state.sunriseTime) / 2.0;
      fogDensity = 0.008 * wetness * (1 - t);
    } else {
      // Daytime: Very clear in dry season, light haze in wet season
      fogDensity = 0.001 + wetness * 0.003;
    }
    
    // Storm fog - heavy rain reduces visibility
    if (stormState && stormState.active) {
      fogDensity += stormState.intensity * 0.012; // Storm fog
    }
    
    // Apply altitude clarity (higher altitude = less fog)
    fogDensity *= (1.0 - altitudeClarity * 0.5);
    
    // Light intensity
    let sunIntensity, ambientIntensity, hemiIntensity;
    if (elevation < -6) {
      // Night
      sunIntensity = 0.0;
      ambientIntensity = 0.15; // Starlight
      hemiIntensity = 0.10;
    } else if (elevation < 0) {
      // Twilight
      const t = (elevation + 6) / 6;
      sunIntensity = 0.4 * t;
      ambientIntensity = 0.15 + 0.55 * t;
      hemiIntensity = 0.10 + 0.55 * t;
    } else if (elevation < 5) {
      // Low sun (sunrise/sunset golden hour)
      const t = elevation / 5;
      sunIntensity = 0.4 + 1.6 * t; // 0.4 to 2.0
      ambientIntensity = 0.70 + 0.40 * t;
      hemiIntensity = 0.65 + 0.40 * t;
    } else {
      // Full daylight - much brighter to overpower proximity lights
      const elevationFactor = Math.sin((elevation / 90) * Math.PI / 2);
      
      // Dry season: Harsh, intense sun (Andean high altitude = very bright)
      // Wet season: Softer, but still bright diffused light
      sunIntensity = (3.5 + 1.5 * dryness) * elevationFactor; // 3.5-5.0 at peak
      ambientIntensity = 1.0 + 0.5 * elevationFactor;
      hemiIntensity = 0.85 + 0.50 * elevationFactor;
    }
    
    // Storm darkening - reduce light intensity
    if (stormState && stormState.active) {
      const stormDim = 1.0 - stormState.intensity * 0.7;
      sunIntensity *= stormDim;
      ambientIntensity *= stormDim;
      hemiIntensity *= stormDim;
    }
    
    // Lightning flash override
    if (stormState && stormState.lightningFlash > 0) {
      const flashIntensity = stormState.lightningFlash * 3.0;
      sunIntensity += flashIntensity;
      ambientIntensity += flashIntensity * 0.8;
      hemiIntensity += flashIntensity * 0.6;
    }
    
    // Sun color temperature
    let sunColor;
    if (elevation < 0) {
      // Twilight/night - cool blue
      sunColor = { r: 0.7, g: 0.8, b: 1.0 };
    } else if (elevation < 5) {
      // Golden hour - warm
      const t = elevation / 5;
      sunColor = {
        r: 1.0,
        g: 0.70 + 0.25 * t,
        b: 0.50 + 0.38 * t
      };
    } else if (elevation < 15) {
      // Morning/afternoon - slightly warm
      const t = (elevation - 5) / 10;
      sunColor = {
        r: 1.0,
        g: 0.95 + 0.05 * t,
        b: 0.88 + 0.10 * t
      };
    } else {
      // Midday - pure white (high altitude = less atmospheric filtering)
      sunColor = { r: 1.0, g: 1.0, b: 0.98 };
    }
    
    return {
      skyColor,
      fogDensity,
      sunIntensity,
      ambientIntensity,
      hemiIntensity,
      sunColor,
      elevation,
      azimuth
    };
  }
  
  // Apply current time and season to scene (made global for storm system)
  const applyTimeAndSeason = globalThis.__applyTimeAndSeason = function(timeOfDay, seasonValue) {
    state.timeOfDay = timeOfDay;
    state.seasonValue = seasonValue;
    
    // Update time UI
    if (timeSlider) timeSlider.value = timeOfDay;
    if (timeDisplay) {
      const h = Math.floor(timeOfDay);
      const m = Math.floor((timeOfDay % 1) * 60);
      timeDisplay.textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
    }
    
    // Update season UI
    if (seasonSlider) seasonSlider.value = seasonValue;
    if (seasonDisplay) seasonDisplay.textContent = seasonValue.toFixed(2);
    
    // Get storm state (will be null if storms not initialized yet)
    const stormState = globalThis.__stormState || null;
    
    // Calculate atmospheric properties
    const atmo = getAtmosphericProperties(timeOfDay, seasonValue, stormState);
    
    // Update Three.js scene
    const scene = globalThis.scene;
    const sun = globalThis.__sunLight;
    const hemi = globalThis.__hemiLight;
    const renderer = globalThis.renderer;
    
    if (scene && renderer) {
      // Update scene background color
      scene.background.setRGB(atmo.skyColor.r, atmo.skyColor.g, atmo.skyColor.b);
      
      // Update fog
      if (scene.fog) {
        scene.fog.color.setRGB(atmo.skyColor.r, atmo.skyColor.g, atmo.skyColor.b);
        scene.fog.density = atmo.fogDensity;
      }
    }
    
    // Update sun light
    if (sun) {
      sun.intensity = atmo.sunIntensity;
      sun.color.setRGB(atmo.sunColor.r, atmo.sunColor.g, atmo.sunColor.b);
      
      // Update sun position
      const distance = 200;
      const elevRad = (atmo.elevation * Math.PI) / 180;
      const azRad = (atmo.azimuth * Math.PI) / 180;
      
      sun.position.x = distance * Math.cos(elevRad) * Math.sin(azRad);
      sun.position.y = distance * Math.sin(elevRad);
      sun.position.z = distance * Math.cos(elevRad) * Math.cos(azRad);
      
      // Update sun target (point at terrain center)
      if (sun.target && globalThis.__terrainCenter) {
        sun.target.position.copy(globalThis.__terrainCenter);
        sun.target.updateMatrixWorld();
      }
    }
    
    // Update hemisphere light
    if (hemi) {
      hemi.intensity = atmo.hemiIntensity;
      // Sky color matches scene background
      hemi.color.setRGB(atmo.skyColor.r, atmo.skyColor.g, atmo.skyColor.b);
      // Ground color - warm earth tones
      hemi.groundColor.setRGB(0.35, 0.30, 0.22);
    }
    
    // Update ambient light if it exists
    if (scene) {
      scene.traverse(obj => {
        if (obj instanceof THREE.AmbientLight) {
          obj.intensity = atmo.ambientIntensity;
        }
      });
    }
    
    // Update shader uniforms (for grass shader)
    const st = globalThis.StylizedTerrainShader;
    if (st) {
      if (sun) st.setLightDirWorld(sun.position);

      // Ensure shader biome is applied before season-derived values (coverage, wind, snow height)
      if (state && state.biomeKey && typeof st.setBiomeMode === "function"){
        const needs = (typeof st.getBiomeMode === "function") ? (st.getBiomeMode() !== state.biomeKey) : true;
        if (needs) {
          st.setBiomeMode(state.biomeKey);
          const b = (typeof st.getBiomeProfile === "function") ? st.getBiomeProfile() : null;
          if (biomeDesc && b && b.desc) biomeDesc.textContent = b.desc;
          if (seasonDesc0 && b && b.seasonDesc0) seasonDesc0.textContent = b.seasonDesc0;
          if (seasonDesc1 && b && b.seasonDesc1) seasonDesc1.textContent = b.seasonDesc1;
        }
      }

      if (st.setSeasonValue) st.setSeasonValue(seasonValue);
    }

    // Update cached leaf materials (seasonal tint)
    if (typeof globalThis.__updateLeafSeasonTint === "function") {
      globalThis.__updateLeafSeasonTint(seasonValue);
    }
  }
  
  // Update cycle info display
  function updateCycleInfo() {
    const dayLen = state.dayLengthSec;
    const daysPerSeason = state.daysPerSeason;
    const fullCycleSec = dayLen * daysPerSeason * 2; // Full dry-to-wet-to-dry
    const mins = Math.floor(fullCycleSec / 60);
    const secs = fullCycleSec % 60;
    if (cycleInfoDisplay) {
      cycleInfoDisplay.textContent = `Full cycle: ${fullCycleSec}s (${mins}m ${secs}s)`;
    }
  }
  
  // Time slider interaction
  timeSlider.addEventListener("input", ()=>{
    state.auto = false;
    if (chkAuto) chkAuto.checked = false;
    applyTimeAndSeason(parseFloat(timeSlider.value), state.seasonValue);
  }, {passive:true});
  
  // Time button shortcuts
  if (btnSunrise) btnSunrise.addEventListener("click", ()=>{
    state.auto = false;
    if (chkAuto) chkAuto.checked = false;
    applyTimeAndSeason(6.0, state.seasonValue);
  });
  
  if (btnNoon) btnNoon.addEventListener("click", ()=>{
    state.auto = false;
    if (chkAuto) chkAuto.checked = false;
    applyTimeAndSeason(12.0, state.seasonValue);
  });
  
  if (btnSunset) btnSunset.addEventListener("click", ()=>{
    state.auto = false;
    if (chkAuto) chkAuto.checked = false;
    applyTimeAndSeason(18.0, state.seasonValue);
  });
  
  if (btnMidnight) btnMidnight.addEventListener("click", ()=>{
    state.auto = false;
    if (chkAuto) chkAuto.checked = false;
    applyTimeAndSeason(0.0, state.seasonValue);
  });
  
  // Season slider interaction
  seasonSlider.addEventListener("input", ()=>{
    state.auto = false;
    if (chkAuto) chkAuto.checked = false;
    applyTimeAndSeason(state.timeOfDay, parseFloat(seasonSlider.value));
  }, {passive:true});
  
  // Season button shortcuts
  if (btnDry) btnDry.addEventListener("click", ()=>{
    state.auto = false;
    if (chkAuto) chkAuto.checked = false;
    applyTimeAndSeason(state.timeOfDay, 0.0);
  });
  
  if (btnMid) btnMid.addEventListener("click", ()=>{
    state.auto = false;
    if (chkAuto) chkAuto.checked = false;
    applyTimeAndSeason(state.timeOfDay, 0.5);
  });
  
  if (btnWet) btnWet.addEventListener("click", ()=>{
    state.auto = false;
    if (chkAuto) chkAuto.checked = false;
    applyTimeAndSeason(state.timeOfDay, 1.0);
  });
  
  // Auto-cycle checkbox
  if (chkAuto) chkAuto.addEventListener("change", ()=>{
    state.auto = !!chkAuto.checked;
    if (state.auto) {
      // Reset day counter when starting auto-cycle
      state.dayCount = 0;
    }
    hudPush("Time & Season Auto-Cycle: " + (state.auto ? "ON" : "OFF"));
  }, {passive:true});
  
  // Day length control
  if (dayLengthInput && dayLengthDisplay) {
    dayLengthInput.addEventListener('input', () => {
      state.dayLengthSec = parseFloat(dayLengthInput.value);
      dayLengthDisplay.textContent = state.dayLengthSec.toFixed(0) + 's';
      updateCycleInfo();
    });
  }
  
  // Days per season control
  if (daysPerSeasonInput && daysPerSeasonDisplay) {
    daysPerSeasonInput.addEventListener('input', () => {
      state.daysPerSeason = parseInt(daysPerSeasonInput.value);
      daysPerSeasonDisplay.textContent = state.daysPerSeason.toString();
      updateCycleInfo();
    });
  }
  
  // Update function (called from tick())
  globalThis.__updateIntegratedTimeSeasonCycle = function(deltaTime) {
    if (!state || !state.auto) return;
    
    // Calculate how much time advances (in game hours)
    const hoursPerSecond = 24 / state.dayLengthSec;
    const hoursDelta = deltaTime * hoursPerSecond;
    
    // Advance time of day
    state.timeOfDay = (state.timeOfDay + hoursDelta) % 24;
    
    // Track day count (for seasonal progression)
    state.dayCount += hoursDelta / 24;
    
    // Calculate season value based on day count
    // Use sine wave: 0 days = dry (0.0), daysPerSeason days = wet (1.0), 2*daysPerSeason days = dry again
    const seasonCycleProgress = (state.dayCount % (state.daysPerSeason * 2)) / (state.daysPerSeason * 2);
    state.seasonValue = (Math.sin(seasonCycleProgress * Math.PI * 2 - Math.PI / 2) + 1) / 2;
    
    // Apply updates
    applyTimeAndSeason(state.timeOfDay, state.seasonValue);
  };
  
  // Wire up atmosphere controls
  ['fogDensity', 'fogNear', 'altitudeClarity'].forEach(id => {
    const input = $(id);
    const display = $(id + 'Val');
    if (input && display) {
      input.addEventListener('input', () => {
        const val = parseFloat(input.value);
        if (id === 'fogDensity') {
          display.textContent = val.toFixed(4);
        } else if (id === 'altitudeClarity') {
          display.textContent = val.toFixed(2);
        } else {
          display.textContent = val.toFixed(0);
        }
        // Re-apply current time to update atmosphere
        applyTimeAndSeason(state.timeOfDay, state.seasonValue);
      });
    }
  });
  
  // Initialize
  applyTimeAndSeason(state.timeOfDay, state.seasonValue);
  updateCycleInfo();
})();


// ============================================================================
// STORM SYSTEM (Andean Afternoon Thunderstorms)
// ============================================================================
(function initStormSystem(){
  const chkEnabled = $("stormsEnabled");
  const stormFreqInput = $("stormFrequency");
  const stormFreqDisplay = $("stormFrequencyVal");
  const stormIntensityInput = $("stormIntensity");
  const stormIntensityDisplay = $("stormIntensityVal");
  const lightningFreqInput = $("lightningFrequency");
  const lightningFreqDisplay = $("lightningFrequencyVal");
  const stormStatusDisplay = $("stormStatus");
  const btnTriggerStorm = $("triggerStorm");
  const btnClearStorm = $("clearStorm");
  
  if (!chkEnabled) return;
  
  // Storm state
  const state = globalThis.__stormState = globalThis.__stormState || {
    enabled: true,
    active: false,
    intensity: 0.0,          // 0.0 = clear, 1.0 = full storm
    targetIntensity: 0.0,
    buildupSpeed: 0.05,      // How fast storms build/fade
    
    // Lightning
    lightningFlash: 0.0,     // Current flash intensity
    lightningCooldown: 0.0,  // Time until next lightning can occur
    lightningTimer: 0.0,     // Time until next lightning
    
    // Configuration
    frequency: 0.6,          // Probability of storms (0-1)
    maxIntensity: 0.7,       // Maximum storm intensity (0-1)
    lightningFrequency: 0.5, // How often lightning strikes (0-1)
    
    // Storm timing (Andean pattern: afternoon storms in wet season)
    stormStartHour: 14,      // 2pm
    stormEndHour: 18,        // 6pm
    stormPeakHour: 16,       // 4pm (most intense)
    
    // Manual override
    manualOverride: false,
  };
  
  // Check if conditions are right for storms
  function shouldHaveStorm(hour, seasonValue) {
    if (!state.enabled) return false;
    if (state.manualOverride) return true; // Manual trigger
    
    // Storms only in wet season (seasonValue > 0.5)
    if (seasonValue < 0.5) return false;
    
    // Storms during afternoon hours (2pm - 6pm)
    if (hour < state.stormStartHour || hour > state.stormEndHour) return false;
    
    // Probability increases with wetness
    const wetnessFactor = (seasonValue - 0.5) * 2; // 0 at 0.5, 1 at 1.0
    const stormChance = state.frequency * wetnessFactor;
    
    // Peak intensity at 4pm, tapering off before/after
    const hourProgress = (hour - state.stormStartHour) / (state.stormEndHour - state.stormStartHour);
    const peakFactor = Math.sin(hourProgress * Math.PI); // 0 at start/end, 1 at middle
    
    return stormChance * peakFactor > 0.3; // Threshold for storm occurrence
  }
  
  // Calculate target storm intensity based on conditions
  function getTargetStormIntensity(hour, seasonValue) {
    if (!shouldHaveStorm(hour, seasonValue)) {
      return 0.0;
    }
    
    // Storm intensity varies over time
    const hourProgress = (hour - state.stormStartHour) / (state.stormEndHour - state.stormStartHour);
    const peakFactor = Math.sin(hourProgress * Math.PI); // Peak in middle
    
    // Add some randomness (using time as seed for variation)
    const randomVar = (Math.sin(hour * 43.7 + seasonValue * 12.3) + 1) / 2;
    
    return state.maxIntensity * peakFactor * (0.7 + randomVar * 0.3);
  }
  
  // Trigger lightning flash
  function triggerLightning() {
    if (state.lightningCooldown > 0) return;
    
    // Flash parameters
    state.lightningFlash = 1.0;
    state.lightningCooldown = 0.5 + Math.random() * 1.5; // 0.5-2 seconds between strikes
    
    // Schedule next lightning
    const baseInterval = 3.0 / Math.max(0.1, state.lightningFrequency);
    const randomDelay = baseInterval * (0.5 + Math.random() * 1.0);
    state.lightningTimer = randomDelay;
    
    // Play thunder sound (delayed by distance simulation)
    // In a real implementation, you'd play an audio file here
    // const thunderDelay = 1.0 + Math.random() * 2.0;
    // setTimeout(() => playThunderSound(), thunderDelay * 1000);
  }
  
  // Update storm state
  function updateStorm(deltaTime, timeOfDay, seasonValue) {
    if (!state) return;
    
    // Determine target intensity
    if (!state.manualOverride) {
      state.targetIntensity = getTargetStormIntensity(timeOfDay, seasonValue);
    }
    
    // Smoothly transition to target intensity
    if (Math.abs(state.targetIntensity - state.intensity) > 0.01) {
      const direction = state.targetIntensity > state.intensity ? 1 : -1;
      state.intensity += direction * state.buildupSpeed * deltaTime;
      state.intensity = Math.max(0, Math.min(1, state.intensity));
    }
    
    // Update active flag
    state.active = state.intensity > 0.05;
    
    // Lightning system (only during active storms)
    if (state.active && state.intensity > 0.3) {
      // Decay flash
      if (state.lightningFlash > 0) {
        state.lightningFlash -= deltaTime * 8.0; // Fast decay
        state.lightningFlash = Math.max(0, state.lightningFlash);
      }
      
      // Cooldown timer
      if (state.lightningCooldown > 0) {
        state.lightningCooldown -= deltaTime;
      }
      
      // Lightning trigger timer
      state.lightningTimer -= deltaTime;
      if (state.lightningTimer <= 0 && state.lightningFlash === 0) {
        triggerLightning();
      }
    } else {
      // Clear lightning when storm is weak
      state.lightningFlash = 0;
      state.lightningCooldown = 0;
      state.lightningTimer = 5.0;
    }
    
    // Update status display
    if (stormStatusDisplay) {
      if (!state.active) {
        stormStatusDisplay.textContent = "Status: Clear";
      } else if (state.intensity < 0.3) {
        stormStatusDisplay.textContent = "Status: Building...";
      } else if (state.intensity < 0.6) {
        stormStatusDisplay.textContent = "Status: Storm Active";
      } else {
        stormStatusDisplay.textContent = "Status: Heavy Storm ‚ö°";
      }
    }
    
    // Re-apply atmosphere to update visuals when storm changes
    const timeState = globalThis.__integratedTimeSeasonState;
    if (timeState && globalThis.__applyTimeAndSeason) {
      // Only re-render when there are significant changes
      if (state.lightningFlash > 0.5 || Math.abs(state.targetIntensity - state.intensity) > 0.01) {
        globalThis.__applyTimeAndSeason(timeState.timeOfDay, timeState.seasonValue);
      }
    }
  }
  
  // Wire up controls
  if (chkEnabled) {
    chkEnabled.addEventListener('change', () => {
      state.enabled = chkEnabled.checked;
      if (!state.enabled) {
        state.manualOverride = false;
        state.targetIntensity = 0.0;
      }
    });
  }
  
  if (stormFreqInput && stormFreqDisplay) {
    stormFreqInput.addEventListener('input', () => {
      state.frequency = parseFloat(stormFreqInput.value);
      stormFreqDisplay.textContent = state.frequency.toFixed(2);
    });
  }
  
  if (stormIntensityInput && stormIntensityDisplay) {
    stormIntensityInput.addEventListener('input', () => {
      state.maxIntensity = parseFloat(stormIntensityInput.value);
      stormIntensityDisplay.textContent = state.maxIntensity.toFixed(2);
    });
  }
  
  if (lightningFreqInput && lightningFreqDisplay) {
    lightningFreqInput.addEventListener('input', () => {
      state.lightningFrequency = parseFloat(lightningFreqInput.value);
      lightningFreqDisplay.textContent = state.lightningFrequency.toFixed(2);
    });
  }
  
  if (btnTriggerStorm) {
    btnTriggerStorm.addEventListener('click', () => {
      state.manualOverride = true;
      state.targetIntensity = state.maxIntensity;
      hudPush("Storm triggered manually!");
    });
  }
  
  if (btnClearStorm) {
    btnClearStorm.addEventListener('click', () => {
      state.manualOverride = false;
      state.targetIntensity = 0.0;
      hudPush("Storm clearing...");
    });
  }
  
  // Update function (called from main tick)
  globalThis.__updateStormSystem = function(deltaTime) {
    const timeState = globalThis.__integratedTimeSeasonState;
    if (!timeState) return;
    
    updateStorm(deltaTime, timeState.timeOfDay, timeState.seasonValue);
  };
  
  // Initialize
  state.enabled = chkEnabled.checked;
})();


// Grass up-axis selector (helps diagnose sideways sprouting)
(function initGrassUpAxis(){
  const sel = $("grassUpAxis");
  if (!sel) return;

  function axisToVec(a){
    if (a === "X")  return [1,0,0];
    if (a === "X-") return [-1,0,0];
    if (a === "Z")  return [0,0,1];
    if (a === "Z-") return [0,0,-1];
    if (a === "Y-") return [0,-1,0];
    return [0,1,0]; // Y+ default
  }

  function apply(){
    const [x,y,z] = axisToVec(sel.value);
    const st = globalThis.StylizedTerrainShader;
    if (st){
      if (st.styleGrass?.upAxisObj?.value) st.styleGrass.upAxisObj.value.set(x,y,z);
      if (st.styleRock?.upAxisObj?.value)  st.styleRock.upAxisObj.value.set(x,y,z); // mostly unused but keeps debug consistent
      if (st.style?.upAxisObj?.value)      st.style.upAxisObj.value.set(x,y,z); // backward compat
    }
    sel.dataset.axis = sel.value;
  }

  sel.addEventListener("change", apply);
  apply();
})();

// Hemisphere light intensity slider (live)

(function initHemiControls(){
  const elI = $("hemiI");
  const valI = $("hemiIVal");
  const elSky = $("hemiSky");
  const valSky = $("hemiSkyVal");
  const elGround = $("hemiGround");
  const valGround = $("hemiGroundVal");
  const elBoost = $("hemiBoost");

  if (!elI) return;

  // Persisted user choices (mobile-safe)
  const state = globalThis.__hemiState = globalThis.__hemiState || {
    intensity: +elI.value,
    sky: (elSky && elSky.value) ? elSky.value : "#bfd7ff",
    ground: (elGround && elGround.value) ? elGround.value : "#5b4a2f",
    boost: !!(elBoost && elBoost.checked),
  };

  const hasShaderHemi = (st)=>{
    return !!(st?.styleGrass?.hemiIntensity || st?.styleRock?.hemiIntensity || st?.style?.hemiIntensity);
  };

  const setShaderHemi = (st, v, skyHex, groundHex)=>{
    // intensity
    if (st?.styleGrass?.hemiIntensity?.value !== undefined) st.styleGrass.hemiIntensity.value = v;
    if (st?.styleRock?.hemiIntensity?.value  !== undefined) st.styleRock.hemiIntensity.value  = v;
    if (st?.style?.hemiIntensity?.value      !== undefined) st.style.hemiIntensity.value      = v; // backward compat

    // colors (Three.Color)
    const applyColor = (styleObj)=>{
      if (!styleObj) return;
      if (styleObj.skyColor?.value?.set) styleObj.skyColor.value.set(skyHex);
      if (styleObj.groundColor?.value?.set) styleObj.groundColor.value.set(groundHex);
    };
    applyColor(st?.styleGrass);
    applyColor(st?.styleRock);
    applyColor(st?.style); // backward compat
    
    // Update scene background to match sky color
    if (globalThis.__sceneBackground) {
      globalThis.__sceneBackground.set(skyHex);
    }
  };

  const resolveColors = ()=>{
    if (state.boost){
      // High-contrast debug colors to make hemi unmistakable
      return { sky:"#9fd6ff", ground:"#ff9a4a" };
    }
    return { sky: state.sky, ground: state.ground };
  };

  const applyToTargets = ()=>{
    const v = +elI.value;
    state.intensity = v;
    if (valI) valI.textContent = v.toFixed(2);

    if (elSky){ state.sky = elSky.value; if (valSky) valSky.textContent = elSky.value.toLowerCase(); }
    if (elGround){ state.ground = elGround.value; if (valGround) valGround.textContent = elGround.value.toLowerCase(); }
    if (elBoost){ state.boost = !!elBoost.checked; }

    const cols = resolveColors();

    // Update Three.js hemi light (for non-shader mats)
    if (globalThis.__hemiLight) globalThis.__hemiLight.intensity = v;

    const st = globalThis.StylizedTerrainShader;
    if (st) setShaderHemi(st, v, cols.sky, cols.ground);

    globalThis.__debugHemi = {
      value: v,
      sky: cols.sky,
      ground: cols.ground,
      boost: state.boost,
      hasThree: !!globalThis.__hemiLight,
      hasShader: hasShaderHemi(st),
    };
  };

  // Apply now, then keep trying until both shader + light exist (boot order varies on mobile).
  let tries = 0;
  const tick = ()=>{
    tries++;
    applyToTargets();
    const st = globalThis.StylizedTerrainShader;
    if (tries < 90 && (!globalThis.__hemiLight || !hasShaderHemi(st))){
      requestAnimationFrame(tick);
    }
  };
  requestAnimationFrame(tick);

  // Event wiring
  elI.addEventListener("input", applyToTargets);
  if (elSky) elSky.addEventListener("input", applyToTargets);
  if (elGround) elGround.addEventListener("input", applyToTargets);
  if (elBoost) elBoost.addEventListener("change", applyToTargets);
})();

// Shape Light & Real Light controls
(function initShapeLightControls(){
  const elTrack = $("shapeLightTrack");
  const valTrack = $("shapeLightTrackVal");
  const elBright = $("realLightBright");
  const valBright = $("realLightBrightVal");

  if (!elTrack || !elBright) return;

  const state = globalThis.__shapeLightState = globalThis.__shapeLightState || {
    track: +elTrack.value,
    brightness: +elBright.value,
  };

  const applyToShader = ()=>{
    state.track = +elTrack.value;
    state.brightness = +elBright.value;
    
    if (valTrack) valTrack.textContent = state.track.toFixed(2);
    if (valBright) valBright.textContent = state.brightness.toFixed(2);

    const st = globalThis.StylizedTerrainShader;
    if (st) {
      if (st.styleGrass?.shapeLightTrack?.value !== undefined) st.styleGrass.shapeLightTrack.value = state.track;
      if (st.styleRock?.shapeLightTrack?.value !== undefined) st.styleRock.shapeLightTrack.value = state.track;
      if (st.style?.shapeLightTrack?.value !== undefined) st.style.shapeLightTrack.value = state.track;
      
      if (st.styleGrass?.realLightBrightness?.value !== undefined) st.styleGrass.realLightBrightness.value = state.brightness;
      if (st.styleRock?.realLightBrightness?.value !== undefined) st.styleRock.realLightBrightness.value = state.brightness;
      if (st.style?.realLightBrightness?.value !== undefined) st.style.realLightBrightness.value = state.brightness;
    }

    globalThis.__debugShapeLight = {
      track: state.track,
      brightness: state.brightness,
      hasShader: !!(st?.styleGrass?.shapeLightTrack || st?.styleRock?.shapeLightTrack),
    };
  };

  // Apply now, then keep trying until shader exists
  let tries = 0;
  const tick = ()=>{
    tries++;
    applyToShader();
    const st = globalThis.StylizedTerrainShader;
    if (tries < 90 && !(st?.styleGrass?.shapeLightTrack || st?.styleRock?.shapeLightTrack)){
      requestAnimationFrame(tick);
    }
  };
  requestAnimationFrame(tick);

  // Event wiring
  elTrack.addEventListener("input", applyToShader);
  elBright.addEventListener("input", applyToShader);
})();

// Sun (directional) controls: rotate like a sun around the scene (azimuth), with fixed elevation.
(function initSunControls(){
  const elRot = $("sunRotate");
  const elSpd = $("sunSpeed");
  const valSpd = $("sunSpeedVal");
  const elAz  = $("sunAz");
  const valAz = $("sunAzVal");
  const elEl  = $("sunElev");
  const valEl = $("sunElevVal");
  const elGizmo = $("sunGizmo");

  if (!elRot || !elSpd || !elAz || !elEl) return;

  // Persisted user choices (mobile-safe)
  const st = globalThis.__sunState = globalThis.__sunState || {
    rotate: !!elRot.checked,
    speedDegPerSec: +elSpd.value,
    azDeg: +elAz.value,
    elevDeg: +elEl.value,
    radius: null, // filled from light position when available
    gizmo: elGizmo ? !!elGizmo.checked : true,
  };

  const clamp = (x,a,b)=>Math.max(a, Math.min(b, x));


// ---------------------------------------------------------------------
// Geometry subdivision helper (non-indexed triangle split into 4)
// Used to increase vertex density for shader-based micro detail (e.g. grass)
// ---------------------------------------------------------------------

// ---------------------------------------------------------------------
// Geometry subdivision helper (triangle barycentric grid)
// Used to increase vertex density for shader-based micro detail (e.g. grass).
//
// segmentsPerEdge:
//   1 => unchanged
//   2 => each tri -> 4 tris
//   12 => matches previewer "Cube Segments: 12" density expectations
// Notes:
// - Operates on non-indexed geometry
// - Interpolates position/normal/uv
// - Caps segments to keep mobile-safe
// ---------------------------------------------------------------------
globalThis.subdivideGeometryTriangles = function subdivideGeometryTriangles(geo, segmentsPerEdge){
  const segs = Math.max(1, Math.min(16, (segmentsPerEdge|0) || 1));
  if (!geo || segs === 1) return geo;

  const g0 = geo.clone().toNonIndexed();
  const pos = g0.getAttribute("position");
  const nor = g0.getAttribute("normal");
  const uv  = g0.getAttribute("uv");

  const outPos = [];
  const outNor = [];
  const outUV  = [];

  // Barycentric interpolation helpers
  function mix3(a,b,c,wa,wb,wc){
    return [
      a[0]*wa + b[0]*wb + c[0]*wc,
      a[1]*wa + b[1]*wb + c[1]*wc,
      a[2]*wa + b[2]*wb + c[2]*wc,
    ];
  }
  function mix2(a,b,c,wa,wb,wc){
    return [
      a[0]*wa + b[0]*wb + c[0]*wc,
      a[1]*wa + b[1]*wb + c[1]*wc,
    ];
  }

  const p = [0,0,0], q = [0,0,0], r = [0,0,0];
  const n = [0,0,0], m = [0,0,0], o = [0,0,0];
  const u0=[0,0], u1=[0,0], u2=[0,0];

  // For each original triangle, generate a barycentric grid
  for (let i=0; i<pos.count; i+=3){
    // positions
    p[0]=pos.getX(i);   p[1]=pos.getY(i);   p[2]=pos.getZ(i);
    q[0]=pos.getX(i+1); q[1]=pos.getY(i+1); q[2]=pos.getZ(i+1);
    r[0]=pos.getX(i+2); r[1]=pos.getY(i+2); r[2]=pos.getZ(i+2);

    // normals (if any)
    if (nor){
      n[0]=nor.getX(i);   n[1]=nor.getY(i);   n[2]=nor.getZ(i);
      m[0]=nor.getX(i+1); m[1]=nor.getY(i+1); m[2]=nor.getZ(i+1);
      o[0]=nor.getX(i+2); o[1]=nor.getY(i+2); o[2]=nor.getZ(i+2);
    }

    // uvs (if any)
    if (uv){
      u0[0]=uv.getX(i);   u0[1]=uv.getY(i);
      u1[0]=uv.getX(i+1); u1[1]=uv.getY(i+1);
      u2[0]=uv.getX(i+2); u2[1]=uv.getY(i+2);
    }

    // Build small triangles
    // We use integer barycentric coords (a,b,c) where a+b+c = segs
    for (let a=0; a<segs; a++){
      for (let b=0; b<segs-a; b++){
        // Two small triangles per cell, except along diagonal edge
        const c = segs - a - b;

        // Vertex weights for corners:
        // v00: (a,b,c)
        // v10: (a+1,b,c-1)
        // v01: (a,b+1,c-1)
        const wa00 = a/segs, wb00 = b/segs, wc00 = c/segs;
        const wa10 = (a+1)/segs, wb10 = b/segs,     wc10 = (c-1)/segs;
        const wa01 = a/segs,     wb01 = (b+1)/segs, wc01 = (c-1)/segs;

        const P00 = mix3(p,q,r,wc00,wa00,wb00);
        const P10 = mix3(p,q,r,wc10,wa10,wb10);
        const P01 = mix3(p,q,r,wc01,wa01,wb01);

        outPos.push(...P00, ...P10, ...P01);

        if (nor){
          const N00 = mix3(n,m,o,wc00,wa00,wb00);
          const N10 = mix3(n,m,o,wc10,wa10,wb10);
          const N01 = mix3(n,m,o,wc01,wa01,wb01);
          outNor.push(...N00, ...N10, ...N01);
        }
        if (uv){
          const U00 = mix2(u0,u1,u2,wc00,wa00,wb00);
          const U10 = mix2(u0,u1,u2,wc10,wa10,wb10);
          const U01 = mix2(u0,u1,u2,wc01,wa01,wb01);
          outUV.push(...U00, ...U10, ...U01);
        }

        // Second triangle if not on the diagonal boundary
        if (c > 1){
          // v11: (a+1,b+1,c-2)
          const wa11 = (a+1)/segs, wb11 = (b+1)/segs, wc11 = (c-2)/segs;

          const P11 = mix3(p,q,r,wc11,wa11,wb11);
          // triangle: P10, P11, P01
          outPos.push(...P10, ...P11, ...P01);

          if (nor){
            const N10 = mix3(n,m,o,wc10,wa10,wb10);
            const N11 = mix3(n,m,o,wc11,wa11,wb11);
            const N01 = mix3(n,m,o,wc01,wa01,wb01);
            outNor.push(...N10, ...N11, ...N01);
          }
          if (uv){
            const U10 = mix2(u0,u1,u2,wc10,wa10,wb10);
            const U11 = mix2(u0,u1,u2,wc11,wa11,wb11);
            const U01 = mix2(u0,u1,u2,wc01,wa01,wb01);
            outUV.push(...U10, ...U11, ...U01);
          }
        }
      }
    }
  }

  const g1 = new THREE.BufferGeometry();
  g1.setAttribute("position", new THREE.Float32BufferAttribute(outPos, 3));
  if (outNor.length) g1.setAttribute("normal", new THREE.Float32BufferAttribute(outNor, 3));
  if (outUV.length)  g1.setAttribute("uv", new THREE.Float32BufferAttribute(outUV, 2));
  if (!outNor.length) g1.computeVertexNormals();

  // Copy groups if any are present (rare here)
  if (g0.groups && g0.groups.length) g1.groups = g0.groups.map(x=>({...x}));

  g0.dispose?.();
  return g1;
};

// Helper to apply smooth normals to geometry if enabled
globalThis.applySmoothNormalsIfEnabled = function applySmoothNormalsIfEnabled(geometry) {
  const $chk = (id, fallback=false)=>{ const el = document.getElementById(id); return el ? !!el.checked : fallback; };
  const smoothNormals = $chk("smoothNormals", true);
  if (smoothNormals) {
    const merged = globalThis.mergeVertices(geometry, 1e-6);
    merged.computeVertexNormals();
    geometry.dispose();
    return globalThis.ensureEdgeAttrs ? globalThis.ensureEdgeAttrs(merged) : merged;
  } else {
    geometry.computeVertexNormals();
    return globalThis.ensureEdgeAttrs ? globalThis.ensureEdgeAttrs(geometry) : geometry;
  }
};

// Ensure optional edge-related attributes exist (prevents shader attribute binding errors).
// Geometries that don't provide these will get safe defaults (0), so edge-draping has no effect.
globalThis.ensureEdgeAttrs = function ensureEdgeAttrs(geo){
  try{
    if (!geo) return geo;
    const pos = geo.getAttribute && geo.getAttribute("position");
    if (!pos) return geo;
    const n = pos.count|0;

    if (!geo.getAttribute("edgeW")){
      geo.setAttribute("edgeW", new THREE.Float32BufferAttribute(new Float32Array(n), 1));
    }
    if (!geo.getAttribute("outDirXZ")){
      geo.setAttribute("outDirXZ", new THREE.Float32BufferAttribute(new Float32Array(n*2), 2));
    }    
    if (!geo.getAttribute("isTop")){
      // isTop: 1 for top-cap surfaces, 0 otherwise. Used to gate accumulation/snow so walls/cliffs don't inflate.
      geo.setAttribute("isTop", new THREE.Float32BufferAttribute(new Float32Array(n), 1));
    }
if (!geo.getAttribute("isTop")){
      geo.setAttribute("isTop", new THREE.Float32BufferAttribute(new Float32Array(n), 1));
    }

    return geo;
  }catch(e){
    // Best-effort: if something goes wrong, don't block rendering
    return geo;
  }
};





// Ensure top-surface attributes for accumulation overlays.
// Unlike ensureEdgeAttrs (which fills zeros), this computes boundary + edge falloff and marks isTop=1
// so snow displacement can lift the interior while keeping edges pinned.
globalThis.ensureTopSurfaceAttrs = function ensureTopSurfaceAttrs(geo, edgeRings=3){
  try{
    if (!geo) return geo;
    const posAttr = geo.getAttribute && geo.getAttribute("position");
    const idxAttr = geo.index;
    if (!posAttr || !idxAttr) return globalThis.ensureEdgeAttrs ? globalThis.ensureEdgeAttrs(geo) : geo;

    const V = posAttr.count|0;
    if (V<=0) return geo;

    // Mark all vertices as top-cap for accumulation purposes.
    const isTopArr = new Float32Array(V);
    isTopArr.fill(1.0);
    geo.setAttribute("isTop", new THREE.Float32BufferAttribute(isTopArr, 1));

    const idx = idxAttr.array;
    const edgeCount = new Map();
    const edgeOriented = new Map();
    const keyUndir = (a,b)=> (a<b) ? (a+"|"+b) : (b+"|"+a);

    for (let i=0;i<idx.length;i+=3){
      const a=idx[i], b=idx[i+1], c=idx[i+2];
      const e0=keyUndir(a,b), e1=keyUndir(b,c), e2=keyUndir(c,a);
      edgeCount.set(e0,(edgeCount.get(e0)||0)+1);
      edgeCount.set(e1,(edgeCount.get(e1)||0)+1);
      edgeCount.set(e2,(edgeCount.get(e2)||0)+1);
      if (!edgeOriented.has(e0)) edgeOriented.set(e0,[a,b]);
      if (!edgeOriented.has(e1)) edgeOriented.set(e1,[b,c]);
      if (!edgeOriented.has(e2)) edgeOriented.set(e2,[c,a]);
    }

    const boundary = new Uint8Array(V);
    for (const [k,cnt] of edgeCount.entries()){
      if (cnt!==1) continue;
      const [oa,ob]=edgeOriented.get(k);
      boundary[oa]=1; boundary[ob]=1;
    }

    // Outward direction (XZ) per boundary vertex (accum drape).
    const outX = new Float32Array(V);
    const outZ = new Float32Array(V);
    const pos = posAttr.array;
    for (const [k,cnt] of edgeCount.entries()){
      if (cnt!==1) continue;
      const [oa,ob]=edgeOriented.get(k);
      const ax=pos[oa*3+0], az=pos[oa*3+2];
      const bx=pos[ob*3+0], bz=pos[ob*3+2];
      const dx=bx-ax, dz=bz-az;
      const px=-dz, pz=dx;
      outX[oa]+=px; outZ[oa]+=pz;
      outX[ob]+=px; outZ[ob]+=pz;
    }

    // Small-ring distance transform for edgeW falloff.
    const EDGE_RINGS = Math.max(1, edgeRings|0);
    const edgeDist = new Int16Array(V);
    edgeDist.fill(32767);

    const nbrs = new Array(V);
    for (let i=0;i<V;i++) nbrs[i]=[];
    for (let i=0;i<idx.length;i+=3){
      const a=idx[i], b=idx[i+1], c=idx[i+2];
      nbrs[a].push(b,c);
      nbrs[b].push(a,c);
      nbrs[c].push(a,b);
    }

    const q=[];
    for (let i=0;i<V;i++){
      if (boundary[i]){
        edgeDist[i]=0;
        q.push(i);
      }
    }

    for (let qi=0; qi<q.length; qi++){
      const v=q[qi];
      const d=edgeDist[v];
      if (d>=EDGE_RINGS) continue;
      const nd=d+1;
      const arr=nbrs[v];
      for (let k=0;k<arr.length;k++){
        const u=arr[k];
        if (edgeDist[u]>nd){
          edgeDist[u]=nd;
          q.push(u);
        }
      }
    }

    const edgeW = new Float32Array(V);
    const boundaryW = new Float32Array(V);
    const outDirXZ = new Float32Array(V*2);

    for (let i=0;i<V;i++){
      const d=edgeDist[i];
      edgeW[i] = (d<=EDGE_RINGS) ? (1.0 - (d/EDGE_RINGS)) : 0.0;
      boundaryW[i] = boundary[i] ? 1.0 : 0.0;

      if (boundary[i]){
        let ox=outX[i], oz=outZ[i];
        const len=Math.hypot(ox,oz);
        if (len>1e-6){ ox/=len; oz/=len; } else { ox=0; oz=0; }
        outDirXZ[i*2+0]=ox;
        outDirXZ[i*2+1]=oz;
      } else {
        outDirXZ[i*2+0]=0;
        outDirXZ[i*2+1]=0;
      }
    }

    geo.setAttribute("edgeW", new THREE.Float32BufferAttribute(edgeW, 1));
    geo.setAttribute("boundaryW", new THREE.Float32BufferAttribute(boundaryW, 1));
    geo.setAttribute("outDirXZ", new THREE.Float32BufferAttribute(outDirXZ, 2));
    return geo;
  }catch(e){
    return globalThis.ensureEdgeAttrs ? globalThis.ensureEdgeAttrs(geo) : geo;
  }
};

  const wrap360 = (d)=>((d%360)+360)%360;

  function applyToLight(){
    // UI -> state
    st.rotate = !!elRot.checked;
    st.speedDegPerSec = +elSpd.value;
    st.azDeg = wrap360(+elAz.value);
    st.elevDeg = clamp(+elEl.value, 0.1, 89.9);
    st.gizmo = elGizmo ? !!elGizmo.checked : st.gizmo;

    // HUD/debug snapshot (works even before the light exists)
    globalThis.__debugSun = {
      rotate: st.rotate,
      speed: st.speedDegPerSec,
      az: st.azDeg,
      elev: st.elevDeg,
      hasThree: !!globalThis.__sunLight,
      gizmo: st.gizmo,
    };

    if (valSpd) valSpd.textContent = st.speedDegPerSec.toFixed(1);
    if (valAz)  valAz.textContent  = String(Math.round(st.azDeg));
    if (valEl)  valEl.textContent  = String(Math.round(st.elevDeg));

    const sun = globalThis.__sunLight;
    if (!sun) return;

    // Determine orbit radius once from existing position.
    if (!st.radius){
      st.radius = Math.max(1e-3, sun.position.length());
    }

    const az = st.azDeg * Math.PI/180;
    const el = st.elevDeg * Math.PI/180;
    const r = st.radius;

    const c = Math.cos(el);
    const x = r * c * Math.cos(az);
    const y = r * Math.sin(el);
    const z = r * c * Math.sin(az);

    sun.position.set(x,y,z);
    sun.target.position.set(0,0,0);
    sun.target.updateMatrixWorld();
  }

  // Apply now, then keep trying until light exists (boot order varies)
  let tries = 0;
  const tick = ()=>{
    tries++;
    applyToLight();
    if (tries < 90 && !globalThis.__sunLight) requestAnimationFrame(tick);
  };
  requestAnimationFrame(tick);

  // Event wiring
  elRot.addEventListener('change', applyToLight);
  elSpd.addEventListener('input', applyToLight);
  elAz.addEventListener('input', applyToLight);
  elEl.addEventListener('input', applyToLight);
  if (elGizmo) elGizmo.addEventListener('change', applyToLight);
})();

// Depth Outline Controls
(function initDepthOutlineControls(){
  const controlsDiv = $("depthOutlineControls");
  const elThick = $("outlineThick");
  const valThick = $("outlineThickVal");
  const elSens = $("depthSens");
  const valSens = $("depthSensVal");
  const elColor = $("outlineColor");
  const valColor = $("outlineColorVal");
  const elDistShrink = $("outlineDistShrink");
  const valDistShrink = $("outlineDistShrinkVal");
  
  if (!elThick || !elSens || !elColor) return;
  
  // State object
  const state = globalThis.__depthOutlineState = globalThis.__depthOutlineState || {
    thickness: 7.0,
    sensitivity: 1.0,
    color: elColor.value,
    distShrink: 100.0
  };
  
  const applyToShader = ()=>{
    state.thickness = +elThick.value;
    state.sensitivity = +elSens.value;
    state.color = elColor.value;
    if (elDistShrink) state.distShrink = +elDistShrink.value;
    
    if (valThick) valThick.textContent = state.thickness.toFixed(1);
    if (valSens) valSens.textContent = state.sensitivity.toFixed(2);
    if (valColor) valColor.textContent = state.color.toLowerCase();
    if (valDistShrink) valDistShrink.textContent = state.distShrink.toFixed(1);
    
    // Update shader uniforms (the pass may not exist yet on first call)
    if (window.depthOutlinePass && window.depthOutlinePass.uniforms) {
      const u = window.depthOutlinePass.uniforms;
      if (u.outlineThickness) u.outlineThickness.value = state.thickness;
      if (u.depthSensitivity) u.depthSensitivity.value = state.sensitivity;
      if (u.outlineColor && u.outlineColor.value.set) {
        u.outlineColor.value.set(state.color);
      }
      if (u.distanceShrinkFactor) u.distanceShrinkFactor.value = state.distShrink;
    }
    
    globalThis.__debugDepthOutline = {
      thickness: state.thickness,
      sensitivity: state.sensitivity,
      color: state.color,
      distShrink: state.distShrink,
      hasPass: !!window.depthOutlinePass
    };
  };
  
  // Apply now, then keep trying until pass exists (async loading)
  let tries = 0;
  const tick = ()=>{
    tries++;
    applyToShader();
    if (tries < 120 && !window.depthOutlinePass) requestAnimationFrame(tick);
  };
  requestAnimationFrame(tick);
  
  // Event wiring
  elThick.addEventListener("input", applyToShader);
  elSens.addEventListener("input", applyToShader);
  elColor.addEventListener("input", applyToShader);
  if (elDistShrink) elDistShrink.addEventListener("input", applyToShader);
})();


// RampFrac label + visibility (shown only in mixed mode)
const rampFracField = $("rampFracField");
const rampFracVal = $("rampFracVal");
const syncRampFracLabel = ()=>{
  const el = $("rampFrac");
  if (rampFracVal && el) rampFracVal.textContent = (+el.value).toFixed(2);
};
const syncRampFracVisibility = ()=>{
  const mode = $("vertMode")?.value || "mixed";
  if (rampFracField) rampFracField.style.display = (mode === "mixed") ? "flex" : "none";
};
if ($("rampFrac")) $("rampFrac").addEventListener("input", syncRampFracLabel);
if ($("vertMode")) $("vertMode").addEventListener("change", syncRampFracVisibility);
syncRampFracLabel();
syncRampFracVisibility();

// Copy HUD button
    const copyHudBtn = $("copyHud");
    if (copyHudBtn){
      copyHudBtn.addEventListener("click", async ()=>{
        const ok = await copyTextToClipboard(hud.textContent);
        const prev = copyHudBtn.textContent;
        copyHudBtn.textContent = ok ? "Copied!" : "Copy failed";
        setTimeout(()=>{ copyHudBtn.textContent = prev; }, 900);
      });
    }

    

    // Seed helpers: randomize / copy / paste (mobile-friendly)
    function makeRandomSeed(){
      // A readable-ish seed (no external libs). Example: "misty-fox-4831"
      const A = ["misty","brass","ashen","lunar","mossy","quiet","frost","ember","copper","opal","ivory","sable","sunlit","dusky"];
      const B = ["fox","owl","otter","lynx","badger","wren","tiger","heron","yak","stoat","koala","quokka","eagle","gecko"];
      const n = Math.floor(Math.random()*9000)+1000;
      return A[Math.floor(Math.random()*A.length)] + "-" + B[Math.floor(Math.random()*B.length)] + "-" + n;
    }
    const seedRandBtn = $("seedRand");
    const seedCopyBtn = $("seedCopy");
    const seedPasteBtn = $("seedPaste");
    if (seedRandBtn){
      seedRandBtn.addEventListener("click", ()=>{
        $val("seed") = makeRandomSeed();
        regenerate();
      });
    }
    if (seedCopyBtn){
      seedCopyBtn.addEventListener("click", async ()=>{
        const ok = await copyTextToClipboard($val("seed"));
        const prev = seedCopyBtn.textContent;
        seedCopyBtn.textContent = ok ? "Copied!" : "Copy failed";
        setTimeout(()=>{ seedCopyBtn.textContent = prev; }, 900);
      });
    }
    if (seedPasteBtn){
      seedPasteBtn.addEventListener("click", async ()=>{
        let txt = "";
        try{
          if (navigator.clipboard && navigator.clipboard.readText){
            txt = await navigator.clipboard.readText();
          }
        }catch(_e){ /* ignore */ }
        if (!txt){
          txt = prompt("Paste seed:", $val("seed")) || "";
        }
        txt = String(txt).trim();
        if (txt){
          $val("seed") = txt;
          regenerate();
        }
      });
    }


    // Register error handlers early (before optional feature init) so mobile doesn't get stuck on "Booting‚Ä¶".
    window.addEventListener("error", (e)=>{
      setHud("JS Error:\n" + (e?.message || e) + "\n" + (e?.filename ? (e.filename + ":" + e.lineno) : ""));
    });
    window.addEventListener("unhandledrejection", (e)=>{
      setHud("Promise Rejection:\n" + (e?.reason?.message || String(e?.reason || e)));
    });

    const DIR = { None:0, N:1, S:2, E:3, W:4 };
    const lerp = (a,b,t)=>a+(b-a)*t;
    const clamp = (v,a,b)=>Math.min(b, Math.max(a,v));
    const clamp01 = (v)=>clamp(v, 0, 1);
    const smoothstep = (a,b,x)=>{
      const t = clamp((x-a)/(b-a), 0, 1);
      return t*t*(3-2*t);
    };



    // NEW: cliff edge height delta (world units), varies along edge length
    function cliffDeltaAt(worldX, worldZ, params, simplexCliff){
      // Allow >1 for "make it obvious" debugging; the UI input has no max.
      // 1.0 == one full levelHeight of variation.
      const varFrac = clamp(params.cliffVar || 0, 0, 3); // fraction of stepH
      if (varFrac <= 0) return 0;

      const scale = Math.max(0.01, params.cliffVarScale || 0.18);
      const n = simplexCliff.noise(worldX * scale, worldZ * scale); // ~[-1..1]
      const t = clamp(n, -1, 1);

      // base amplitude in world units
      // cliffVarBoost is a visibility/debug knob so you can exaggerate the effect.
      const boost = Math.max(0, params.cliffVarBoost ?? 1); // readParams()
      const amp = varFrac * params.levelHeight * boost;

      return t * amp;
    }


    function pointsToNeighbor(dir, x,z, nx,nz){
      if (dir===DIR.N) return nx===x && nz===z+1;
      if (dir===DIR.S) return nx===x && nz===z-1;
      if (dir===DIR.E) return nx===x+1 && nz===z;
      if (dir===DIR.W) return nx===x-1 && nz===z;
      return false;
    }

    const DEFAULT_CLIFFSIDE_PRESET_V2 = {
      version: 2,
      kind: "cliffside_preset",
      name: "cliffside_rock-1",
      seed: "rock-1",
      cliffSelection: { facing: "X+", verticalMaxAbsNy: 0.25, minFacingDot: 0.35, minHeight01: 0.15, tileUnitSize: 2 },
      carve: { noiseScale: 3.33, octaves: 1, lacunarity: 3.2, gain: 0.75, carveStrength: 2, carveBias: 0.35, cubeToSphere: 0 },
      chip: { chipSteps: 0, chipStrength: 0.82, chipBias: 0.74, chipBiasDir: "X-", chipDepthRandom: 0.77, chipJitter: 0.42 },
      plateau: {
        plateauStraightness: 0.85,
        planes: {
          top:    { enabled:false, mode:"flatten", closeness:0 },
          bottom: { enabled:false, mode:"flatten", closeness:0.12 },
          xPlus:  { enabled:false, mode:"cut", closeness:0.25 },
          xMinus: { enabled:false, mode:"cut", closeness:0.25 },
          zPlus:  { enabled:false, mode:"cut", closeness:0.25 },
          zMinus: { enabled:false, mode:"cut", closeness:0.25 }
        }
      },
      erosion: { erosionSteps: 6, erosionStrength: 0.35, preserveEdges: 0.2, erosionSpherify: 0.15 },
      micro: { microNoise: 0.04, microNoiseScale: 6.21, quantize: 0.06, flatShading: false },
      renderHint: { cliffMaterial: "basalt", backsideWireframe: true }
    };

    function xmur3(str){
      let h = 1779033703 ^ str.length;
      for (let i=0;i<str.length;i++){
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return function(){
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        return (h ^= (h >>> 16)) >>> 0;
      }
    }
    function mulberry32(seed){
      return function(){
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }
    function makeRng(seedStr){
      const s = xmur3(seedStr)();
      return mulberry32(s);
    }
    function randInt(rng, min, maxInclusive){
      return min + Math.floor(rng() * (maxInclusive - min + 1));
    }

    class Simplex2D {
      constructor(rng){
        const p = new Uint8Array(256);
        for (let i=0;i<256;i++) p[i]=i;
        for (let i=255;i>0;i--){
          const j = Math.floor(rng()* (i+1));
          const tmp = p[i]; p[i]=p[j]; p[j]=tmp;
        }
        this.perm = new Uint8Array(512);
        for (let i=0;i<512;i++) this.perm[i]=p[i & 255];
      }
      noise(xin, yin){
        const grad3 = [
          [ 1, 1], [-1, 1], [ 1,-1], [-1,-1],
          [ 1, 0], [-1, 0], [ 1, 0], [-1, 0],
          [ 0, 1], [ 0,-1], [ 0, 1], [ 0,-1],
        ];
        const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
        const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;

        let n0=0, n1=0, n2=0;
        const s = (xin + yin) * F2;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;

        let i1, j1;
        if (x0 > y0) { i1 = 1; j1 = 0; }
        else { i1 = 0; j1 = 1; }

        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1.0 + 2.0 * G2;
        const y2 = y0 - 1.0 + 2.0 * G2;

        const ii = i & 255;
        const jj = j & 255;
        const gi0 = this.perm[ii + this.perm[jj]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
        const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;

        let t0 = 0.5 - x0*x0 - y0*y0;
        if (t0 > 0) { t0 *= t0; n0 = t0 * t0 * (grad3[gi0][0]*x0 + grad3[gi0][1]*y0); }
        let t1 = 0.5 - x1*x1 - y1*y1;
        if (t1 > 0) { t1 *= t1; n1 = t1 * t1 * (grad3[gi1][0]*x1 + grad3[gi1][1]*y1); }
        let t2 = 0.5 - x2*x2 - y2*y2;
        if (t2 > 0) { t2 *= t2; n2 = t2 * t2 * (grad3[gi2][0]*x2 + grad3[gi2][1]*y2); }
        return 70.0 * (n0 + n1 + n2);
      }
    }

    function neighbors4(x,z){ return [[x+1,z],[x-1,z],[x,z+1],[x,z-1]]; }
    function dirFromTo(ax,az,bx,bz){
      if (bx===ax && bz===az+1) return DIR.N;
      if (bx===ax && bz===az-1) return DIR.S;
      if (bx===ax+1 && bz===az) return DIR.E;
      if (bx===ax-1 && bz===az) return DIR.W;
      return DIR.None;
    }

    
function generateRectTierMap({ seed, w,h, maxLevel, rectCount, rampCount, vertMode, vertRampFrac }){
  const rng = makeRng(seed);
  const levels = new Int16Array(w*h);

  // Unified vertical-tile feature category:
  // vertType: 0 none, 1 ramp, 2 rockwall
  // vertDir:  direction from this tile toward the higher neighbor (DIR.*)
  const vertDir = new Int8Array(w*h);
  const vertType = new Int8Array(w*h);

  const idx = (x,z)=>z*w+x;
  levels.fill(0);

  // --- Rect-based tier generation (same as before) ---
  for (let lvl=1; lvl<=maxLevel; lvl++){
    const countAtLvl = Math.max(1, Math.round(rectCount * (1.0 - (lvl-1)/maxLevel) * 0.55));
    for (let r=0; r<countAtLvl; r++){
      const maxW = Math.max(4, Math.floor(w * (0.55 - 0.04*lvl)));
      const maxH = Math.max(4, Math.floor(h * (0.55 - 0.04*lvl)));
      const rw = randInt(rng, Math.max(4, Math.floor(maxW*0.25)), maxW);
      const rh = randInt(rng, Math.max(4, Math.floor(maxH*0.25)), maxH);

      const x0 = randInt(rng, 1, Math.max(1, w - rw - 2));
      const z0 = randInt(rng, 1, Math.max(1, h - rh - 2));
      const x1 = x0 + rw;
      const z1 = z0 + rh;

      for (let z=z0; z<z1; z++){
        for (let x=x0; x<x1; x++){
          levels[idx(x,z)] = Math.max(levels[idx(x,z)], lvl);
        }
      }
    }
  }

  // smooth hard edges a bit (same as before)
  for (let pass=0; pass<2; pass++){
    const copy = new Int16Array(levels);
    for (let z=1; z<h-1; z++){
      for (let x=1; x<w-1; x++){
        const self = copy[idx(x,z)];
        let nMax = self, nMin = self;
        for (const [nx,nz] of neighbors4(x,z)){
          const v = copy[idx(nx,nz)];
          nMax = Math.max(nMax, v);
          nMin = Math.min(nMin, v);
        }
        if (self > nMin + 2) levels[idx(x,z)] = nMin + 2;
        if (self < nMax - 2) levels[idx(x,z)] = nMax - 2;
      }
    }
  }

  vertDir.fill(0);
  vertType.fill(0);

  // ---------------------------------------------------------------------------
  // NEW: span-first vertical feature placement
  //
  // We compute *all* 1-step vertical edges first, merge them into continuous spans
  // (like "cliff runs"), then decide per-span whether it becomes a ramp span or
  // a rockwall span. This guarantees:
  // - ramps can cover wide continuous edges
  // - ramps and rockwalls "cut off" each other (mutual exclusion happens at span level)
  // ---------------------------------------------------------------------------

  /**
   * A span represents a continuous run of edges that share:
   * - same orientation (axis)
   * - same fixed boundary line
   * - same direction (from low tile to high tile)
   * - same low level (so same height delta == +1)
   *
   * axis:
   *  - "Z": run progresses along Z (boundary is at fixed X)
   *  - "X": run progresses along X (boundary is at fixed Z)
   *
   * start/end are integer tile coordinates along the run axis (end is exclusive).
   */
  function computeStep1Spans(){
    const spans = [];

    // Spans along Z (between x and x+1 columns)
    for (let x=0; x<w-1; x++){
      const fixed = x + 1; // boundary world line is at (x+1)*tileSize
      let run = null;
      for (let z=0; z<h; z++){
        const a = levels[idx(x,z)];
        const b = levels[idx(x+1,z)];

        let dir = DIR.None;
        let lowLvl = 0;

        if (b === a + 1){ dir = DIR.E; lowLvl = a; }       // low at (x,z)
        else if (a === b + 1){ dir = DIR.W; lowLvl = b; }  // low at (x+1,z)

        const ok = (dir !== DIR.None);
        const sameRun = ok && run && (run.dir === dir) && (run.lowLvl === lowLvl);

        if (!ok || !sameRun){
          if (run) spans.push(run);
          run = ok ? { axis:"Z", fixed, start:z, end:z+1, dir, lowLvl } : null;
        } else {
          run.end = z+1;
        }
      }
      if (run) spans.push(run);
    }

    // Spans along X (between z and z+1 rows)
    for (let z=0; z<h-1; z++){
      const fixed = z + 1; // boundary world line is at (z+1)*tileSize
      let run = null;
      for (let x=0; x<w; x++){
        const a = levels[idx(x,z)];
        const b = levels[idx(x,z+1)];

        let dir = DIR.None;
        let lowLvl = 0;

        if (b === a + 1){ dir = DIR.N; lowLvl = a; }       // low at (x,z)
        else if (a === b + 1){ dir = DIR.S; lowLvl = b; }  // low at (x,z+1)

        const ok = (dir !== DIR.None);
        const sameRun = ok && run && (run.dir === dir) && (run.lowLvl === lowLvl);

        if (!ok || !sameRun){
          if (run) spans.push(run);
          run = ok ? { axis:"X", fixed, start:x, end:x+1, dir, lowLvl } : null;
        } else {
          run.end = x+1;
        }
      }
      if (run) spans.push(run);
    }

    return spans;
  }

  // Weighted random select without replacement (mobile-safe / no allocations explosion)
  function pickWeightedSpans(rngPick, spans, count){
    const pool = spans.slice();
    const picked = [];
    const weight = (s)=> Math.max(1, (s.end - s.start)); // prefer longer spans
    while (pool.length && picked.length < count){
      let totalW = 0;
      for (let i=0;i<pool.length;i++) totalW += weight(pool[i]);
      let r = rngPick() * totalW;
      let chosenIndex = pool.length - 1;
      for (let i=0;i<pool.length;i++){
        r -= weight(pool[i]);
        if (r <= 0){ chosenIndex = i; break; }
      }
      picked.push(pool[chosenIndex]);
      pool.splice(chosenIndex, 1);
    }
    return picked;
  }

  // Decide per-span whether it's ramp or rockwall.
  // "Wide spans" are biased toward ramps in mixed mode.
  function rampChanceForSpan(span){
    if (vertMode === "ramps") return 1;
    if (vertMode === "rockwalls") return 0;
    // mixed
    const base = clamp((vertRampFrac ?? 0.6), 0, 1);
    const len = Math.max(1, span.end - span.start);

    // Treat wide spans more "ramp-like" (your request).
    // len<=2 => base; len>=8 => strongly ramp-biased.
    const t = clamp((len - 2) / 6, 0, 1);
    const boosted = clamp(base + t * (1 - base) * 0.75, 0, 1);

    return boosted;
  }

  // Apply a span by stamping vertDir/vertType into the low-side tiles it covers.
  function applySpan(span, kind /*1 ramp, 2 rockwall*/){
    let edgesCovered = 0;
    if (span.axis === "Z"){
      // boundary between x=(fixed-1) and x=fixed
      const xLeft = span.fixed - 1;
      const xRight = span.fixed;

      for (let z=span.start; z<span.end; z++){
        const lowX = (span.dir === DIR.E) ? xLeft : xRight;
        const lowZ = z;
        const i = idx(lowX, lowZ);
        if (vertDir[i] !== 0) continue; // tile already has a vertical feature
        vertDir[i] = span.dir;
        vertType[i] = kind;
        edgesCovered++;
      }
    } else {
      // axis === "X": boundary between z=(fixed-1) and z=fixed
      const zDown = span.fixed - 1;
      const zUp = span.fixed;

      for (let x=span.start; x<span.end; x++){
        const lowX = x;
        const lowZ = (span.dir === DIR.N) ? zDown : zUp;
        const i = idx(lowX, lowZ);
        if (vertDir[i] !== 0) continue;
        vertDir[i] = span.dir;
        vertType[i] = kind;
        edgesCovered++;
      }
    }
    return edgesCovered;
  }

  const allSpans = computeStep1Spans();
  const rngSpanPick = makeRng(seed+"::spanPick");
  const selectedSpans = pickWeightedSpans(rngSpanPick, allSpans, Math.max(0, rampCount|0));

  const rngSpanKind = makeRng(seed+"::spanKind");
  let rampSpanCount = 0;
  let rockSpanCount = 0;
  let edgesStamped = 0;

  for (let i=0;i<selectedSpans.length;i++){
    const s = selectedSpans[i];
    const chance = rampChanceForSpan(s);
    const kind = (rngSpanKind() < chance) ? 1 : 2;
    if (kind === 1) rampSpanCount++; else rockSpanCount++;
    edgesStamped += applySpan(s, kind);
  }

  // Derived count: how many tiles got any vertical feature
  let vertPlaced = 0;
  for (let i=0;i<vertType.length;i++) if (vertType[i] !== 0) vertPlaced++;

  return {
    levels,
    vertDir,
    vertType,
    vertPlaced,
    spanTotal: allSpans.length,
    spanSelected: selectedSpans.length,
    spanRamp: rampSpanCount,
    spanRock: rockSpanCount,
    spanEdgesStamped: edgesStamped
  };
}


// Apply the ramp/rockwall span layout algorithm to an existing heightmap (levels).
// Used for "Reimport (apply layout)" so imported .vox maps can be re-rendered with the current layout settings.
function computeVerticalLayoutOnLevels({ seed, w, h, levels, rampCount, vertMode, vertRampFrac }){
  const idx = (x,z)=>z*w+x;

  // Unified vertical-tile feature category:
  // vertType: 0 none, 1 ramp, 2 rockwall
  // vertDir:  direction from this tile toward the higher neighbor (DIR.*)
  const vertDir = new Int8Array(w*h);
  const vertType = new Int8Array(w*h);
  vertDir.fill(0);
  vertType.fill(0);

  function computeStep1Spans(){
    const spans = [];

    // Spans along Z (between x and x+1 columns)
    for (let x=0; x<w-1; x++){
      const fixed = x + 1;
      let run = null;
      for (let z=0; z<h; z++){
        const a = levels[idx(x,z)];
        const b = levels[idx(x+1,z)];

        let dir = DIR.None;
        let lowLvl = 0;

        if (b === a + 1){ dir = DIR.E; lowLvl = a; }
        else if (a === b + 1){ dir = DIR.W; lowLvl = b; }

        const ok = (dir !== DIR.None);
        const sameRun = ok && run && (run.dir === dir) && (run.lowLvl === lowLvl);

        if (!ok || !sameRun){
          if (run) spans.push(run);
          run = ok ? { axis:"Z", fixed, start:z, end:z+1, dir, lowLvl } : null;
        } else {
          run.end = z+1;
        }
      }
      if (run) spans.push(run);
    }

    // Spans along X (between z and z+1 rows)
    for (let z=0; z<h-1; z++){
      const fixed = z + 1;
      let run = null;
      for (let x=0; x<w; x++){
        const a = levels[idx(x,z)];
        const b = levels[idx(x,z+1)];

        let dir = DIR.None;
        let lowLvl = 0;

        if (b === a + 1){ dir = DIR.N; lowLvl = a; }
        else if (a === b + 1){ dir = DIR.S; lowLvl = b; }

        const ok = (dir !== DIR.None);
        const sameRun = ok && run && (run.dir === dir) && (run.lowLvl === lowLvl);

        if (!ok || !sameRun){
          if (run) spans.push(run);
          run = ok ? { axis:"X", fixed, start:x, end:x+1, dir, lowLvl } : null;
        } else {
          run.end = x+1;
        }
      }
      if (run) spans.push(run);
    }

    return spans;
  }

  // Weighted random select without replacement (mobile-safe)
  function pickWeightedSpans(rngPick, spans, count){
    const pool = spans.slice();
    const picked = [];
    const weight = (s)=> Math.max(1, (s.end - s.start)); // prefer longer spans
    while (pool.length && picked.length < count){
      let totalW = 0;
      for (let i=0;i<pool.length;i++) totalW += weight(pool[i]);
      let r = rngPick() * totalW;
      let chosenIndex = pool.length - 1;
      for (let i=0;i<pool.length;i++){
        r -= weight(pool[i]);
        if (r <= 0){ chosenIndex = i; break; }
      }
      picked.push(pool[chosenIndex]);
      pool.splice(chosenIndex, 1);
    }
    return picked;
  }

  // Decide per-span whether it's ramp or rockwall.
  function rampChanceForSpan(span){
    if (vertMode === "ramps") return 1;
    if (vertMode === "rockwalls") return 0;
    const base = clamp((vertRampFrac ?? 0.6), 0, 1);
    const len = Math.max(1, span.end - span.start);
    const t = clamp((len - 2) / 6, 0, 1);
    const boosted = clamp(base + t * (1 - base) * 0.75, 0, 1);
    return boosted;
  }

  // Apply a span by stamping vertDir/vertType into the low-side tiles it covers.
  function applySpan(span, kind /*1 ramp, 2 rockwall*/){
    let edgesCovered = 0;
    if (span.axis === "Z"){
      const xLeft = span.fixed - 1;
      const xRight = span.fixed;
      for (let z=span.start; z<span.end; z++){
        const lowX = (span.dir === DIR.E) ? xLeft : xRight;
        const lowZ = z;
        const i = idx(lowX, lowZ);
        if (vertDir[i] !== 0) continue;
        vertDir[i] = span.dir;
        vertType[i] = kind;
        edgesCovered++;
      }
    } else {
      const zDown = span.fixed - 1;
      const zUp = span.fixed;
      for (let x=span.start; x<span.end; x++){
        const lowX = x;
        const lowZ = (span.dir === DIR.N) ? zDown : zUp;
        const i = idx(lowX, lowZ);
        if (vertDir[i] !== 0) continue;
        vertDir[i] = span.dir;
        vertType[i] = kind;
        edgesCovered++;
      }
    }
    return edgesCovered;
  }

  const allSpans = computeStep1Spans();
  const rngSpanPick = makeRng(seed+"::spanPick");
  const selectedSpans = pickWeightedSpans(rngSpanPick, allSpans, Math.max(0, rampCount|0));

  const rngSpanKind = makeRng(seed+"::spanKind");
  let rampSpanCount = 0;
  let rockSpanCount = 0;
  let edgesStamped = 0;

  for (let i=0;i<selectedSpans.length;i++){
    const s = selectedSpans[i];
    const chance = rampChanceForSpan(s);
    const kind = (rngSpanKind() < chance) ? 1 : 2;
    if (kind === 1) rampSpanCount++; else rockSpanCount++;
    edgesStamped += applySpan(s, kind);
  }

  let vertPlaced = 0;
  for (let i=0;i<vertType.length;i++) if (vertType[i] !== 0) vertPlaced++;

  return {
    vertDir,
    vertType,
    vertPlaced,
    spanTotal: allSpans.length,
    spanSelected: selectedSpans.length,
    spanRamp: rampSpanCount,
    spanRock: rockSpanCount,
    spanEdgesStamped: edgesStamped
  };
}

// Derive a 2.5D heightmap (levels) from the current imported voxel grid by taking the highest solid voxel at each (x,z).
// levels are in "voxel heights" (0 means empty, 1 means one voxel tall, etc).
function deriveLevelsFromImportedVoxels(w, h){
  if (!importedVoxelGrid || !importedVoxelGridDims?.depth) return null;
  const depth = importedVoxelGridDims.depth;
  const levels = new Int16Array(w*h);
  for (let z=0; z<h; z++){
    for (let x=0; x<w; x++){
      let top = -1;
      for (let y=depth-1; y>=0; y--){
        const idx3d = y*(w*h) + z*w + x;
        if (isVoxelSolid(importedVoxelGrid[idx3d])){ top = y; break; }
      }
      levels[z*w + x] = (top >= 0) ? (top + 1) : 0;
    }
  }
  return levels;
}
function computeTileCornerHeights(x, z, params, levels, vertDir, vertType){
      const { w, levelHeight } = params;
      const idx = (x,z)=>z*w+x;
      const L = (x,z)=>levels[idx(x,z)];
      const VDir = (x,z)=>vertDir[idx(x,z)];
      const VType = (x,z)=>vertType[idx(x,z)];

      const baseLvl = L(x,z) * levelHeight;
      const x0w = x * params.tileSize;
      const z0w = z * params.tileSize;
      const x1w = (x+1) * params.tileSize;
      const z1w = (z+1) * params.tileSize;
      let y00 = baseLvl;
      let y10 = baseLvl;
      let y11 = baseLvl;
      let y01 = baseLvl;
      const dir = (VType(x,z) === 1) ? VDir(x,z) : 0;
      if (dir !== 0){
        const upLvl = (L(x,z)+1) * levelHeight;
        const up00 = upLvl;
        const up10 = upLvl;
        const up11 = upLvl;
        const up01 = upLvl;
if (dir === DIR.N){ y01 = up01; y11 = up11; }
        else if (dir === DIR.S){ y00 = up00; y10 = up10; }
        else if (dir === DIR.E){ y10 = up10; y11 = up11; }
        else if (dir === DIR.W){ y00 = up00; y01 = up01; }
      }

// --- NEW: cliff lip variation (only on edges where THIS tile is higher than neighbor) ---
// This warps the supporting tier ground near the cliff, producing non-machined terrain.
const simple = params._simplexCliffVar; // injected from regenerate
let cliffVarMaxAbs = 0; // debug: max abs delta applied by cliff variation on this tile (world units)
let cliffVarEdges = 0;  // debug: number of cliff edges on this tile that received variation
if (simple && (params.cliffVar || 0) > 0){
  const idx2 = (x,z)=>z*w+x;
  const L2 = (x,z)=>levels[idx2(x,z)];
  const VDir2 = (x,z)=>vertDir[idx2(x,z)];
  const VType2 = (x,z)=>vertType[idx2(x,z)];

  const isRamp2 = (x,z)=>VType2(x,z) === 1;
  const edgeBridged2 = (ax,az,bx,bz)=>{
    if (isRamp2(ax,az) && pointsToNeighbor(VDir2(ax,az), ax,az,bx,bz)) return true;
    if (isRamp2(bx,bz) && pointsToNeighbor(VDir2(bx,bz), bx,bz,ax,az)) return true;
    return false;
  };

  const addEdgeDelta = (edge, d0, d1)=>{
    if (edge==="E"){ y10 += d0; y11 += d1; }
    if (edge==="W"){ y00 += d0; y01 += d1; }
    if (edge==="N"){ y01 += d0; y11 += d1; }
    if (edge==="S"){ y00 += d0; y10 += d1; }
    cliffVarMaxAbs = Math.max(cliffVarMaxAbs, Math.abs(d0), Math.abs(d1));
    cliffVarEdges++;
  };

  const myL = L2(x,z);

  if (x+1 < params.w){
    const nbL = L2(x+1,z);
    if (myL > nbL && !edgeBridged2(x,z,x+1,z)){
      const d0 = cliffDeltaAt(x1w, z0w, params, simple);
      const d1 = cliffDeltaAt(x1w, z1w, params, simple);
      addEdgeDelta("E", d0, d1);
    }
  }
  if (x-1 >= 0){
    const nbL = L2(x-1,z);
    if (myL > nbL && !edgeBridged2(x,z,x-1,z)){
      const d0 = cliffDeltaAt(x0w, z0w, params, simple);
      const d1 = cliffDeltaAt(x0w, z1w, params, simple);
      addEdgeDelta("W", d0, d1);
    }
  }
  if (z+1 < params.h){
    const nbL = L2(x,z+1);
    if (myL > nbL && !edgeBridged2(x,z,x,z+1)){
      const d0 = cliffDeltaAt(x0w, z1w, params, simple);
      const d1 = cliffDeltaAt(x1w, z1w, params, simple);
      addEdgeDelta("N", d0, d1);
    }
  }
  if (z-1 >= 0){
    const nbL = L2(x,z-1);
    if (myL > nbL && !edgeBridged2(x,z,x,z-1)){
      const d0 = cliffDeltaAt(x0w, z0w, params, simple);
      const d1 = cliffDeltaAt(x1w, z0w, params, simple);
      addEdgeDelta("S", d0, d1);
    }
  }
}

	return { y00, y10, y11, y01, baseLevel: L(x,z), rampDir: dir, cliffVarMaxAbs, cliffVarEdges };

    }

    function buildTopGeometriesByTierSegments(params, levels, vertDir, vertType){
      const { w,h, tileSize } = params;
      const idx = (x,z)=>z*w+x;

      const tileInfo = new Array(w*h);
      let cliffVarMaxAbsAll = 0;   // used by HUD to confirm cliff variation is actually applying
      let cliffVarEdgesAll = 0;    // used by HUD to show how many edges received variation
      for (let z=0; z<h; z++){
        for (let x=0; x<w; x++){
          tileInfo[idx(x,z)] = computeTileCornerHeights(x,z,params,levels,vertDir,vertType);
          cliffVarMaxAbsAll = Math.max(cliffVarMaxAbsAll, tileInfo[idx(x,z)].cliffVarMaxAbs || 0);
          cliffVarEdgesAll += (tileInfo[idx(x,z)].cliffVarEdges || 0);
        }
      }

      // Persist for debugging (HUD).
      params._cliffVarMaxAbsAll = cliffVarMaxAbsAll;
      params._cliffVarEdgesAll = cliffVarEdgesAll;

      const keyFor = (x,z)=>{
        const t = tileInfo[idx(x,z)];
        const type = (t.rampDir !== 0) ? "R" : "F";
        return `${t.baseLevel}|${type}|${t.rampDir}`;
      };

      const EPS = 1e-5;
      function edgeHeightsMatch(ax,az, bx,bz){
        const a = tileInfo[idx(ax,az)];
        const b = tileInfo[idx(bx,bz)];
        const dx = bx-ax;
        const dz = bz-az;

        if (dx === 1 && dz === 0){
          return (Math.abs(a.y10 - b.y00) < EPS) && (Math.abs(a.y11 - b.y01) < EPS);
        }
        if (dx === -1 && dz === 0){
          return (Math.abs(a.y00 - b.y10) < EPS) && (Math.abs(a.y01 - b.y11) < EPS);
        }
        if (dx === 0 && dz === 1){
          return (Math.abs(a.y01 - b.y00) < EPS) && (Math.abs(a.y11 - b.y10) < EPS);
        }
        if (dx === 0 && dz === -1){
          return (Math.abs(a.y00 - b.y01) < EPS) && (Math.abs(a.y10 - b.y11) < EPS);
        }
        return false;
      }

      const visited = new Uint8Array(w*h);
      const components = [];

      for (let z=0; z<h; z++){
        for (let x=0; x<w; x++){
          const i = idx(x,z);
          if (visited[i]) continue;

          visited[i] = 1;
          const k = keyFor(x,z);
          const q = [[x,z]];
          const tiles = [[x,z]];

          while (q.length){
            const [cx,cz] = q.pop();
            const nbs = [[cx+1,cz],[cx-1,cz],[cx,cz+1],[cx,cz-1]];
            for (const [nx,nz] of nbs){
              if (nx<0||nz<0||nx>=w||nz>=h) continue;
              const ni = idx(nx,nz);
              if (visited[ni]) continue;
              if (keyFor(nx,nz) !== k) continue;
              if (!edgeHeightsMatch(cx,cz,nx,nz)) continue;

              visited[ni] = 1;
              q.push([nx,nz]);
              tiles.push([nx,nz]);
            }
          }

          components.push({ key: k, tiles });
        }
      }

      const geometries = [];
      let totalTopVerts = 0;

      for (const comp of components){
        const pos = [];
        const uv = [];
        const idxs = [];
        const vmap = new Map();
        const yKey = (y)=> y.toFixed(5);

        const getVid = (cx,cz,y)=>{
          const k = `${cx},${cz},${yKey(y)}`;
          const existing = vmap.get(k);
          if (existing !== undefined) return existing;

          const vid = (pos.length/3);
          pos.push(cx*tileSize, y, cz*tileSize);
          uv.push(cx/params.w, cz/params.h);
          vmap.set(k, vid);
          return vid;
        };

        for (const [x,z] of comp.tiles){
          const t = tileInfo[idx(x,z)];
          const v00 = getVid(x,   z,   t.y00);
          const v10 = getVid(x+1, z,   t.y10);
          const v11 = getVid(x+1, z+1, t.y11);
          const v01 = getVid(x,   z+1, t.y01);
          idxs.push(v00, v10, v11,  v00, v11, v01);
        }

        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
        g.setAttribute("uv", new THREE.Float32BufferAttribute(uv, 2));
        g.setIndex(idxs);
        const gFinal = globalThis.applySmoothNormalsIfEnabled(g);
        gFinal.computeBoundingSphere();

        totalTopVerts += gFinal.getAttribute("position").count;
        geometries.push(gFinal);
      }

      return { geometries, componentCount: components.length, totalTopVerts };
    }

    // Generate bottom surfaces (ceilings) for arches/caves/tunnels
    function buildBottomSurfacesFromVoxels(params){
      if (!importedVoxelGrid || !importedVoxelGridDims.depth) return [];
      
      const { w, h, tileSize, levelHeight } = params;
      const geometries = [];
      
      // Scan voxel grid for "ceiling faces" (voxels with empty space BELOW)
      for (let level = 1; level < importedVoxelGridDims.depth; level++) {
        const positions = [];
        const uvs = [];
        const colors = []; // NEW: Add vertex colors
        const indices = [];
        const vmap = new Map();
        let vc = 0;
        
        const getVid = (cx, cz, y, voxelType) => { // NEW: Pass voxelType
          const k = `${cx},${cz},${y.toFixed(5)}`;
          const existing = vmap.get(k);
          if (existing !== undefined) return existing;
          
          const vid = vc++;
          
          // NEW: Lower river voxels for depth effect
          let yOffset = 0;
          if (voxelType >= VOXEL_TYPES.RIVER_N && voxelType <= VOXEL_TYPES.RIVER_SW) {
            yOffset = -0.15;
          }
          
          positions.push(cx * tileSize, y + yOffset, cz * tileSize);
          uvs.push(cx / w, cz / h);
          
          // NEW: Add vertex color
          const hexColor = getVoxelColor(voxelType);
          const color = new THREE.Color(hexColor);
          colors.push(color.r, color.g, color.b);
          
          vmap.set(k, vid);
          return vid;
        };
        
        for (let z = 0; z < h; z++) {
          for (let x = 0; x < w; x++) {
            const idxCurrent = level * (w * h) + z * w + x;
            const idxBelow = (level - 1) * (w * h) + z * w + x;
            
            // Check if this voxel exists and has empty space BELOW
            const voxelType = importedVoxelGrid[idxCurrent];
            const voxelBelow = importedVoxelGrid[idxBelow];
            if (isVoxelSolid(voxelType) && isVoxelEmpty(voxelBelow)) {
              
              // Generate a bottom face (ceiling) at the BOTTOM of this voxel
              const y = level * levelHeight;
              
              const v00 = getVid(x,   z,   y, voxelType);
              const v10 = getVid(x+1, z,   y, voxelType);
              const v11 = getVid(x+1, z+1, y, voxelType);
              const v01 = getVid(x,   z+1, y, voxelType);
              
              // Reverse winding for bottom face (faces downward)
              indices.push(v00, v11, v10, v00, v01, v11);
            }
          }
        }
        
        if (indices.length > 0) {
          const g = new THREE.BufferGeometry();
          g.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
          g.setAttribute("uv", new THREE.Float32BufferAttribute(uvs, 2));
          g.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3)); // NEW: Add colors
          g.setIndex(indices);
          const gFinal = globalThis.applySmoothNormalsIfEnabled(g);
          gFinal.computeBoundingSphere();
          geometries.push(gFinal);
        }
      }
      
      return geometries;
    }

    // Generate top surfaces directly from voxels (respects hollow spaces)
    // Returns { grassSurfaces, nonGrassSurfaces } to apply different materials
    function buildTopSurfacesFromVoxels(params){
      if (!importedVoxelGrid || !importedVoxelGridDims.depth) return { grassSurfaces: [], nonGrassSurfaces: [] };
      
      const { w, h, tileSize, levelHeight } = params;
      const grassGeometries = [];
      const nonGrassGeometries = [];
      const riverGeometries = [];
      
      // Helper: Check if voxel type should have grass
      const isGrassType = (voxelType) => {
        // Grass types: GRASS_FLAT, GRASS_RAMP_*, DIRT (grass can grow on dirt)
        return voxelType === VOXEL_TYPES.GRASS_FLAT ||
               voxelType === VOXEL_TYPES.GRASS_RAMP_N ||
               voxelType === VOXEL_TYPES.GRASS_RAMP_S ||
               voxelType === VOXEL_TYPES.GRASS_RAMP_E ||
               voxelType === VOXEL_TYPES.GRASS_RAMP_W ||
               voxelType === VOXEL_TYPES.DIRT;
      };
      
      // Helper: Check if voxel type is road/river (no grass)
      const isRiverType = (voxelType) => (voxelType >= VOXEL_TYPES.RIVER_N && voxelType <= VOXEL_TYPES.RIVER_SW);
      
      const isNoGrassType = (voxelType) => {
        // Roads (including ramps)
        if (voxelType >= VOXEL_TYPES.ROAD_NS && voxelType <= VOXEL_TYPES.ROAD_RAMP_W) return true;
        // Stone
        if (voxelType === VOXEL_TYPES.STONE) return true;
        return false;
      };
      
      // For each level, find voxels with empty space above and generate top faces
      for (let level = 0; level < importedVoxelGridDims.depth; level++) {
        // Separate arrays for grass vs non-grass vs river water
        const grassPositions = [], grassUvs = [], grassColors = [], grassIndices = [];
        const nonGrassPositions = [], nonGrassUvs = [], nonGrassColors = [], nonGrassIndices = [];
        const riverPositions = [], riverUvs = [], riverColors = [], riverIndices = [];
        
        const grassVmap = new Map();
        const nonGrassVmap = new Map();
        const riverVmap = new Map();
        let grassVc = 0;
        let nonGrassVc = 0;
        let riverVc = 0;
        
        const getGrassVid = (cx, cz, y, voxelType) => {
          const k = `${cx},${cz},${y.toFixed(5)}`;
          const existing = grassVmap.get(k);
          if (existing !== undefined) return existing;
          
          const vid = grassVc++;
          grassPositions.push(cx * tileSize, y, cz * tileSize);
          grassUvs.push(cx / w, cz / h);
          
          const hexColor = getVoxelColor(voxelType);
          const color = new THREE.Color(hexColor);
          grassColors.push(color.r, color.g, color.b);
          
          grassVmap.set(k, vid);
          return vid;
        };


        const getRiverVid = (cx, cz, y, voxelType) => {
          const k = `${cx},${cz},${y.toFixed(5)}`;
          const existing = riverVmap.get(k);
          if (existing !== undefined) return existing;

          const vid = riverVc++;

          // Rivers are slightly recessed to read as a channel
          const yOffset = -0.15;

          riverPositions.push(cx * tileSize, y + yOffset, cz * tileSize);
          riverUvs.push(cx / w, cz / h);

          const hexColor = getVoxelColor(voxelType);
          const color = new THREE.Color(hexColor);
          riverColors.push(color.r, color.g, color.b);

          riverVmap.set(k, vid);
          return vid;
        };

        
        const getNonGrassVid = (cx, cz, y, voxelType) => {
          const k = `${cx},${cz},${y.toFixed(5)}`;
          const existing = nonGrassVmap.get(k);
          if (existing !== undefined) return existing;
          
          const vid = nonGrassVc++;
          
          nonGrassPositions.push(cx * tileSize, y, cz * tileSize);
          nonGrassUvs.push(cx / w, cz / h);
          
          const hexColor = getVoxelColor(voxelType);
          const color = new THREE.Color(hexColor);
          nonGrassColors.push(color.r, color.g, color.b);
          
          nonGrassVmap.set(k, vid);
          return vid;
        };
        
        for (let z = 0; z < h; z++) {
          for (let x = 0; x < w; x++) {
            const idxCurrent = level * (w * h) + z * w + x;
            
            // Check if this voxel exists
            const voxelType = importedVoxelGrid[idxCurrent];
            if (isVoxelEmpty(voxelType)) continue;
            
            // Check if there's empty space above (or we're at the top)
            const hasEmptyAbove = (level === importedVoxelGridDims.depth - 1) ||
                                  (isVoxelEmpty(importedVoxelGrid[(level + 1) * (w * h) + z * w + x]));
            
            if (hasEmptyAbove) {
              // Generate a top face for this voxel
              const y = (level + 1) * levelHeight; // Top of this voxel

              // --- Ramp geometry (wedge top) ---
              // Ramps are represented by voxel types, but the *mesh* needs to slope.
              // We encode this by lifting two corners by +levelHeight.
              // Convention (matches grass auto-ramp marking):
              //   RAMP_N rises toward +Z
              //   RAMP_S rises toward -Z
              //   RAMP_E rises toward +X
              //   RAMP_W rises toward -X
              const yBase = y;
              const yHigh = y + levelHeight;
              let y00 = yBase, y10 = yBase, y11 = yBase, y01 = yBase;

              const isRamp = (
                voxelType === VOXEL_TYPES.GRASS_RAMP_N || voxelType === VOXEL_TYPES.GRASS_RAMP_S ||
                voxelType === VOXEL_TYPES.GRASS_RAMP_E || voxelType === VOXEL_TYPES.GRASS_RAMP_W ||
                voxelType === VOXEL_TYPES.ROAD_RAMP_N  || voxelType === VOXEL_TYPES.ROAD_RAMP_S  ||
                voxelType === VOXEL_TYPES.ROAD_RAMP_E  || voxelType === VOXEL_TYPES.ROAD_RAMP_W
              );

              if (isRamp) {
                if (voxelType === VOXEL_TYPES.GRASS_RAMP_N || voxelType === VOXEL_TYPES.ROAD_RAMP_N) {
                  // +Z edge is higher
                  y01 = yHigh; y11 = yHigh;
                } else if (voxelType === VOXEL_TYPES.GRASS_RAMP_S || voxelType === VOXEL_TYPES.ROAD_RAMP_S) {
                  // -Z edge is higher
                  y00 = yHigh; y10 = yHigh;
                } else if (voxelType === VOXEL_TYPES.GRASS_RAMP_E || voxelType === VOXEL_TYPES.ROAD_RAMP_E) {
                  // +X edge is higher
                  y10 = yHigh; y11 = yHigh;
                } else if (voxelType === VOXEL_TYPES.GRASS_RAMP_W || voxelType === VOXEL_TYPES.ROAD_RAMP_W) {
                  // -X edge is higher
                  y00 = yHigh; y01 = yHigh;
                }
              }

              // Route to grass vs non-grass vs river geometry
              if (isRiverType(voxelType)) {
                // Rivers - water material later
                // NOTE: All verts MUST come from the river vertex map. Mixing vid sources corrupts indices and
                // makes the river surface disappear.
                const v00 = getRiverVid(x,   z,   y00, voxelType);
                const v10 = getRiverVid(x+1, z,   y10, voxelType);
                const v11 = getRiverVid(x+1, z+1, y11, voxelType);
                const v01 = getRiverVid(x,   z+1, y01, voxelType);
                riverIndices.push(v00, v10, v11, v00, v11, v01);
              } else if (isNoGrassType(voxelType)) {
                const v00 = getNonGrassVid(x,   z,   y00, voxelType);
                const v10 = getNonGrassVid(x+1, z,   y10, voxelType);
                const v11 = getNonGrassVid(x+1, z+1, y11, voxelType);
                const v01 = getNonGrassVid(x,   z+1, y01, voxelType);
                nonGrassIndices.push(v00, v10, v11, v00, v11, v01);
              } else {
                // Default: grass shader
                const v00 = getGrassVid(x,   z,   y00, voxelType);
                const v10 = getGrassVid(x+1, z,   y10, voxelType);
                const v11 = getGrassVid(x+1, z+1, y11, voxelType);
                const v01 = getGrassVid(x,   z+1, y01, voxelType);
                grassIndices.push(v00, v10, v11, v00, v11, v01);
              }
            }
          }
        }
        
        // Build grass geometry
        if (grassIndices.length > 0) {
          const g = new THREE.BufferGeometry();
          g.setAttribute("position", new THREE.Float32BufferAttribute(grassPositions, 3));
          g.setAttribute("uv", new THREE.Float32BufferAttribute(grassUvs, 2));
          g.setAttribute("color", new THREE.Float32BufferAttribute(grassColors, 3));
          g.setIndex(grassIndices);
          const gFinal = globalThis.applySmoothNormalsIfEnabled(g);
          gFinal.computeBoundingSphere();
          grassGeometries.push(gFinal);
        }
        
        // Build non-grass geometry
        if (nonGrassIndices.length > 0) {
          const g = new THREE.BufferGeometry();
          g.setAttribute("position", new THREE.Float32BufferAttribute(nonGrassPositions, 3));
          g.setAttribute("uv", new THREE.Float32BufferAttribute(nonGrassUvs, 2));
          g.setAttribute("color", new THREE.Float32BufferAttribute(nonGrassColors, 3));
          g.setIndex(nonGrassIndices);
          const gFinal = globalThis.applySmoothNormalsIfEnabled(g);
          gFinal.computeBoundingSphere();
          nonGrassGeometries.push(gFinal);
        }



        // Build river geometry (water surfaces)
        if (riverIndices.length > 0) {
          const g = new THREE.BufferGeometry();
          g.setAttribute("position", new THREE.Float32BufferAttribute(riverPositions, 3));
          g.setAttribute("uv", new THREE.Float32BufferAttribute(riverUvs, 2));
          g.setAttribute("color", new THREE.Float32BufferAttribute(riverColors, 3));
          g.setIndex(riverIndices);
          const gFinal = globalThis.applySmoothNormalsIfEnabled(g);

          // Water shader expects these attributes (water plane has them); provide defaults for voxel rivers too.
          try{
            const vCount = gFinal.getAttribute("position").count;
            const mask = new Float32Array(vCount);
            const depth = new Float32Array(vCount);
            for (let i=0;i<vCount;i++){
              mask[i] = 1.0;
              depth[i] = 2.0;
            }
            gFinal.setAttribute("aWaterMask", new THREE.Float32BufferAttribute(mask, 1));
            gFinal.setAttribute("aWaterDepth", new THREE.Float32BufferAttribute(depth, 1));
          }catch(_e){}

          gFinal.computeBoundingSphere();
          riverGeometries.push(gFinal);
        }
      }
      
      return { grassSurfaces: grassGeometries, nonGrassSurfaces: nonGrassGeometries, riverSurfaces: riverGeometries };
    }

    // Generate walls for voxel data by checking solid/empty boundaries
    
function buildWallsFromVoxels(params){
  if (!importedVoxelGrid || !importedVoxelGridDims.depth) return null;

  const { w, h, tileSize, levelHeight } = params;

  // We split walls by voxel material so water voxels can render with the water shader.
  const mkBuf = ()=>({ positions: [], uvs: [], indices: [], vc: 0, quads: 0 });
  const solidBuf = mkBuf();  // used by most terrain voxels (rock/dirt/grass/road)
  const waterBuf = mkBuf();  // used by river voxels

  const addQuadTo = (buf, x0,y0,z0, x1,y1,z1, x2,y2,z2, x3,y3,z3) => {
    const base = buf.vc;
    buf.positions.push(x0,y0,z0, x1,y1,z1, x2,y2,z2, x3,y3,z3);
    buf.uvs.push(0,0, 1,0, 1,1, 0,1);
    buf.indices.push(base, base+1, base+2, base, base+2, base+3);
    buf.vc += 4;
    buf.quads += 1;
  };

  const addFace = (voxelType, x0,y0,z0, x1,y1,z1, x2,y2,z2, x3,y3,z3) => {
    const isWater = isWaterVoxelType(voxelType);
    addQuadTo(isWater ? waterBuf : solidBuf, x0,y0,z0, x1,y1,z1, x2,y2,z2, x3,y3,z3);
  };

  // For each voxel, check 4 horizontal directions for empty neighbors.
  // Only exposed faces become walls. This respects hollow spaces in imported voxel data.
  for (let level = 0; level < importedVoxelGridDims.depth; level++) {
    for (let z = 0; z < h; z++) {
      for (let x = 0; x < w; x++) {
        const idx = level * (w * h) + z * w + x;
        const voxelType = importedVoxelGrid[idx];
        if (isVoxelEmpty(voxelType)) continue;

        const y0 = level * levelHeight;
        const y1 = (level + 1) * levelHeight;

        // X+ (right)
        if (x < w-1) {
          const idxRight = level * (w * h) + z * w + (x+1);
          if (isVoxelEmpty(importedVoxelGrid[idxRight])) {
            const wx = (x+1) * tileSize;
            const wz0 = z * tileSize;
            const wz1 = (z+1) * tileSize;
            addFace(voxelType, wx,y0,wz0, wx,y0,wz1, wx,y1,wz1, wx,y1,wz0);
          }
        }

        // X- (left)
        if (x > 0) {
          const idxLeft = level * (w * h) + z * w + (x-1);
          if (isVoxelEmpty(importedVoxelGrid[idxLeft])) {
            const wx = x * tileSize;
            const wz0 = z * tileSize;
            const wz1 = (z+1) * tileSize;
            addFace(voxelType, wx,y0,wz1, wx,y0,wz0, wx,y1,wz0, wx,y1,wz1);
          }
        }

        // Z+ (forward)
        if (z < h-1) {
          const idxForward = level * (w * h) + (z+1) * w + x;
          if (isVoxelEmpty(importedVoxelGrid[idxForward])) {
            const wz = (z+1) * tileSize;
            const wx0 = x * tileSize;
            const wx1 = (x+1) * tileSize;
            addFace(voxelType, wx0,y0,wz, wx1,y0,wz, wx1,y1,wz, wx0,y1,wz);
          }
        }

        // Z- (backward)
        if (z > 0) {
          const idxBackward = level * (w * h) + (z-1) * w + x;
          if (isVoxelEmpty(importedVoxelGrid[idxBackward])) {
            const wz = z * tileSize;
            const wx0 = x * tileSize;
            const wx1 = (x+1) * tileSize;
            addFace(voxelType, wx1,y0,wz, wx0,y0,wz, wx0,y1,wz, wx1,y1,wz);
          }
        }
      }
    }
  }

  const makeGeo = (buf)=>{
    if (!buf || buf.indices.length === 0) return null;
    let geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.Float32BufferAttribute(buf.positions, 3));
    geo.setAttribute("uv", new THREE.Float32BufferAttribute(buf.uvs, 2));
    geo.setIndex(buf.indices);
    geo = globalThis.applySmoothNormalsIfEnabled(geo);

    // Water shader expects these attributes; provide sane defaults for walls.
    const vCount = geo.getAttribute("position").count;
    const mask = new Float32Array(vCount);
    const depth = new Float32Array(vCount);
    for (let i=0;i<vCount;i++){
      mask[i] = 1.0;
      depth[i] = 2.0; // "deep" so shore-foam doesn't dominate on vertical faces
    }
    geo.setAttribute("aWaterMask", new THREE.Float32BufferAttribute(mask, 1));
    geo.setAttribute("aWaterDepth", new THREE.Float32BufferAttribute(depth, 1));

    geo.computeBoundingSphere();
    return geo;
  };

  const solidGeo = makeGeo(solidBuf);
  const waterGeo = makeGeo(waterBuf);
  if (!solidGeo && !waterGeo) return null;

  return {
    solid: solidGeo,
    water: waterGeo,
    stats: {
      solidQuads: solidBuf.quads,
      waterQuads: waterBuf.quads
    }
  };
}


    function spreadBoundaryWeight(geo, steps){
      const boundaryW = geo.getAttribute("boundaryW");
      const isTop = geo.getAttribute("isTop");
      const index = geo.index;
      if (!boundaryW || !isTop || !index) return;
      const V = isTop.count;
      if (V === 0) return;

      const adj = Array.from({ length: V }, ()=>[]);
      const idx = index.array;

      for (let i=0;i<idx.length;i+=3){
        const a = idx[i], b = idx[i+1], c = idx[i+2];
        if (isTop.array[a] === 1 && isTop.array[b] === 1){ adj[a].push(b); adj[b].push(a); }
        if (isTop.array[b] === 1 && isTop.array[c] === 1){ adj[b].push(c); adj[c].push(b); }
        if (isTop.array[c] === 1 && isTop.array[a] === 1){ adj[c].push(a); adj[a].push(c); }
      }

      const w = boundaryW.array;
      let cur = new Float32Array(V);
      let nxt = new Float32Array(V);

      for (let i=0;i<V;i++){ cur[i] = w[i]; nxt[i] = w[i]; }
      const decay = 1 / Math.max(1, steps);

      for (let s=0; s<steps; s++){
        for (let i=0;i<V;i++){
          if (isTop.array[i] !== 1){ nxt[i] = cur[i]; continue; }
          let best = cur[i];
          const list = adj[i];
          for (let k=0;k<list.length;k++){
            const j = list[k];
            best = Math.max(best, cur[j] - decay);
          }
          nxt[i] = clamp(best, 0, 1);
        }
        const tmp = cur; cur = nxt; nxt = tmp;
      }

      for (let i=0;i<V;i++){ w[i] = cur[i]; }
      boundaryW.needsUpdate = true;
    }

    function solidifyFromTop(geoTop, depth, balloonOut, balloonDown){
      const posAttr = geoTop.getAttribute("position");
      const idxAttr = geoTop.index;
      if (!posAttr || !idxAttr) return null;

      const V = posAttr.count;
      const srcPos = posAttr.array;
      const srcIdx = idxAttr.array;
      
      // Helper: Check how far down voxels exist at a given (x, z) position
      const getVoxelDepth = (x, z, topY) => {
        if (!importedVoxelGrid || !importedVoxelGridDims.depth) {
          return depth; // No voxel grid = use full depth
        }
        
        const gridW = importedVoxelGridDims.w;
        const gridH = importedVoxelGridDims.h;
        const gridX = Math.floor(x);
        const gridZ = Math.floor(z);
        
        if (gridX < 0 || gridX >= gridW || gridZ < 0 || gridZ >= gridH) {
          return depth; // Out of bounds = use full depth
        }
        
        // topY is the terrain height at this position
        // Convert to grid level (assuming levelHeight = 1)
        const topLevel = Math.round(topY);
        
        // Start from the top and go DOWN until we hit empty space
        let wallLevels = 0;
        
        for (let level = topLevel; level >= 0; level--) {
          if (level >= importedVoxelGridDims.depth) continue;
          
          const idx3d = level * (gridW * gridH) + gridZ * gridW + gridX;
          
          if (isVoxelSolid(importedVoxelGrid[idx3d])) {
            // Voxel exists - continue wall downward
            wallLevels++;
          } else {
            // Hit empty space - STOP HERE!
            break;
          }
        }
        
        // If no continuous voxels from top, no wall
        if (wallLevels === 0) return 0;
        
        // Convert levels to world units (assuming levelHeight = 1)
        return Math.max(0, Math.min(wallLevels, depth));
      };

      const edgeCount = new Map();
      const edgeOriented = new Map();
      const keyUndir = (a,b)=> (a<b) ? (a+"|"+b) : (b+"|"+a);

      for (let i=0; i<srcIdx.length; i+=3){
        const a = srcIdx[i+0], b = srcIdx[i+1], c = srcIdx[i+2];
        const e0 = keyUndir(a,b), e1 = keyUndir(b,c), e2 = keyUndir(c,a);
        edgeCount.set(e0, (edgeCount.get(e0)||0)+1);
        edgeCount.set(e1, (edgeCount.get(e1)||0)+1);
        edgeCount.set(e2, (edgeCount.get(e2)||0)+1);
        if (!edgeOriented.has(e0)) edgeOriented.set(e0, [a,b]);
        if (!edgeOriented.has(e1)) edgeOriented.set(e1, [b,c]);
        if (!edgeOriented.has(e2)) edgeOriented.set(e2, [c,a]);
      }

      const isBoundaryVert = new Uint8Array(V);
      for (const [k, cnt] of edgeCount.entries()){
        if (cnt !== 1) continue;
        const [oa, ob] = edgeOriented.get(k);
        isBoundaryVert[oa] = 1;
        isBoundaryVert[ob] = 1;
      }

      const outX = new Float32Array(V);
      const outZ = new Float32Array(V);
      for (const [k, cnt] of edgeCount.entries()){
        if (cnt !== 1) continue;
        const [oa, ob] = edgeOriented.get(k);

        const ax = srcPos[oa*3+0], az = srcPos[oa*3+2];
        const bx = srcPos[ob*3+0], bz = srcPos[ob*3+2];

        const dx = bx - ax;
        const dz = bz - az;

        const px = -dz;
        const pz =  dx;

        outX[oa] += px; outZ[oa] += pz;
        outX[ob] += px; outZ[ob] += pz;
      }

      
      // Edge falloff (0..1) for boundary draping in accumulation/snow.
      // This is a small-ring distance transform on the top-surface vertex graph.
      const EDGE_RINGS = 3;
      const edgeDist = new Int16Array(V);
      edgeDist.fill(32767);

      const nbrs = new Array(V);
      for (let i=0;i<V;i++) nbrs[i] = [];
      for (let i=0;i<srcIdx.length;i+=3){
        const a = srcIdx[i], b = srcIdx[i+1], c = srcIdx[i+2];
        nbrs[a].push(b, c);
        nbrs[b].push(a, c);
        nbrs[c].push(a, b);
      }

      const q = [];
      for (let i=0;i<V;i++){
        if (isBoundaryVert[i]){
          edgeDist[i] = 0;
          q.push(i);
        }
      }

      for (let qi=0; qi<q.length; qi++){
        const v = q[qi];
        const d = edgeDist[v];
        if (d >= EDGE_RINGS) continue;
        const nd = d + 1;
        const arr = nbrs[v];
        for (let k=0; k<arr.length; k++){
          const u = arr[k];
          if (edgeDist[u] > nd){
            edgeDist[u] = nd;
            q.push(u);
          }
        }
      }

      const edgeWVals = new Float32Array(V);
      for (let i=0;i<V;i++){
        const d = edgeDist[i];
        edgeWVals[i] = (d <= EDGE_RINGS) ? (1.0 - (d / EDGE_RINGS)) : 0.0;
      }

const uvAttr = geoTop.getAttribute("uv");

      const topPos = new Float32Array(V*3);
      topPos.set(srcPos);

      for (let vi=0; vi<V; vi++){
        if (!isBoundaryVert[vi]) continue;

        let ox = outX[vi], oz = outZ[vi];
        const len = Math.hypot(ox, oz);
        if (len > 1e-6 && balloonOut !== 0){
          ox /= len; oz /= len;
          topPos[vi*3+0] += ox * balloonOut;
          topPos[vi*3+2] += oz * balloonOut;
        }
        if (balloonDown !== 0) topPos[vi*3+1] -= balloonDown;
      }

      const positions = [];
      const uvs = [];
      const indices = [];
      const isTop = [];

      const boundaryW = [];
      const outDirXZ = [];
      const edgeW = [];

      for (let i=0;i<V;i++){
        positions.push(topPos[i*3+0], topPos[i*3+1], topPos[i*3+2]);
        if (uvAttr) uvs.push(uvAttr.array[i*2+0], uvAttr.array[i*2+1]);
        else uvs.push(0,0);
        isTop.push(1);

        const b = isBoundaryVert[i] ? 1 : 0;
        boundaryW.push(b);
        edgeW.push(edgeWVals[i]);

        if (isBoundaryVert[i]){
          let ox = outX[i], oz = outZ[i];
          const len = Math.hypot(ox, oz);
          if (len > 1e-6){ ox/=len; oz/=len; } else { ox=0; oz=0; }
          outDirXZ.push(ox, oz);
        } else {
          outDirXZ.push(0, 0);
        }
      }

      for (let i=0;i<V;i++){
        const x = topPos[i*3+0];
        const y = topPos[i*3+1];
        const z = topPos[i*3+2];
        
        // Calculate depth based on voxel existence at this (x,z) position
        const vertexDepth = getVoxelDepth(x, z, y);
        
        positions.push(x, y - vertexDepth, z);
        if (uvAttr) uvs.push(uvAttr.array[i*2+0], uvAttr.array[i*2+1]);
        else uvs.push(0,0);
        isTop.push(0);

        const b = isBoundaryVert[i] ? 1 : 0;
        boundaryW.push(b);
        edgeW.push(edgeWVals[i]);

        if (isBoundaryVert[i]){
          let ox = outX[i], oz = outZ[i];
          const len = Math.hypot(ox, oz);
          if (len > 1e-6){ ox/=len; oz/=len; } else { ox=0; oz=0; }
          outDirXZ.push(ox, oz);
        } else {
          outDirXZ.push(0, 0);
        }
      }

      for (let i=0;i<srcIdx.length;i+=3){
        indices.push(srcIdx[i+0], srcIdx[i+1], srcIdx[i+2]);
      }

      const off = V;
      for (let i=0;i<srcIdx.length;i+=3){
        indices.push(off + srcIdx[i+2], off + srcIdx[i+1], off + srcIdx[i+0]);
      }

      for (const [k, cnt] of edgeCount.entries()){
        if (cnt !== 1) continue;
        const [oa, ob] = edgeOriented.get(k);
        const a0 = oa, b0 = ob, a1 = off + oa, b1 = off + ob;
        indices.push(a0, b0, b1);
        indices.push(a0, b1, a1);
      }

      let geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute("uv", new THREE.Float32BufferAttribute(uvs, 2));
      geo.setAttribute("isTop", new THREE.Float32BufferAttribute(isTop, 1));
      geo.setAttribute("boundaryW", new THREE.Float32BufferAttribute(boundaryW, 1));
      geo.setAttribute("outDirXZ", new THREE.Float32BufferAttribute(outDirXZ, 2));
      geo.setAttribute("edgeW", new THREE.Float32BufferAttribute(edgeW, 1));
      geo.setIndex(indices);
      geo = globalThis.applySmoothNormalsIfEnabled(geo);
      geo = globalThis.ensureEdgeAttrs(geo);
      geo.computeBoundingSphere();
      return geo;
    }

    function splitByIsTop(geo){
      const pos = geo.getAttribute("position");
      const uv = geo.getAttribute("uv");
      const isTop = geo.getAttribute("isTop");
      const boundaryW = geo.getAttribute("boundaryW");
      const outDirXZ = geo.getAttribute("outDirXZ");
      const edgeW = geo.getAttribute("edgeW");
      const index = geo.index;
      if (!pos || !isTop || !index) return { top:null, side:null };

      const srcIdx = index.array;
      const mapTop = new Map();
      const mapSide = new Map();

      const topPos = [];
      const topUv = [];
      const topBW = [];
      const topOD = [];
      const topEW = [];
      const topIdx = [];

      const sidePos = [];
      const sideUv = [];
      const sideBW = [];
      const sideOD = [];
      const sideEW = [];
      const sideIdx = [];

      const pushVert = (map, outPos, outUv, outBW, outOD, outEW, vi)=>{
        const hit = map.get(vi);
        if (hit !== undefined) return hit;
        const j = (outPos.length/3)|0;
        outPos.push(pos.array[vi*3+0], pos.array[vi*3+1], pos.array[vi*3+2]);
        if (uv) outUv.push(uv.array[vi*2+0], uv.array[vi*2+1]);
        else outUv.push(0,0);

        if (boundaryW) outBW.push(boundaryW.array[vi]);
        if (outDirXZ)  outOD.push(outDirXZ.array[vi*2+0], outDirXZ.array[vi*2+1]);
        if (edgeW)     outEW.push(edgeW.array[vi]);

        map.set(vi, j);
        return j;
      };

      for (let i=0;i<srcIdx.length;i+=3){
        const a = srcIdx[i], b = srcIdx[i+1], c = srcIdx[i+2];
        const tA = isTop.array[a] === 1;
        const tB = isTop.array[b] === 1;
        const tC = isTop.array[c] === 1;
        const allTop = tA && tB && tC;

        if (allTop){
          const na = pushVert(mapTop, topPos, topUv, topBW, topOD, topEW, a);
          const nb = pushVert(mapTop, topPos, topUv, topBW, topOD, topEW, b);
          const nc = pushVert(mapTop, topPos, topUv, topBW, topOD, topEW, c);
          topIdx.push(na, nb, nc);
        } else {
          const na = pushVert(mapSide, sidePos, sideUv, sideBW, sideOD, sideEW, a);
          const nb = pushVert(mapSide, sidePos, sideUv, sideBW, sideOD, sideEW, b);
          const nc = pushVert(mapSide, sidePos, sideUv, sideBW, sideOD, sideEW, c);
          sideIdx.push(na, nb, nc);
        }
      }

      const makeGeo = (p,u,bw,od,ew,i)=>{
        if (i.length === 0) return null;
        let g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.Float32BufferAttribute(p, 3));
        g.setAttribute("uv", new THREE.Float32BufferAttribute(u, 2));
        if (bw && bw.length) g.setAttribute("boundaryW", new THREE.Float32BufferAttribute(bw, 1));
        if (od && od.length) g.setAttribute("outDirXZ", new THREE.Float32BufferAttribute(od, 2));
        if (ew && ew.length) g.setAttribute("edgeW", new THREE.Float32BufferAttribute(ew, 1));
        g.setIndex(i);
        g = globalThis.applySmoothNormalsIfEnabled(g);
        g = globalThis.ensureEdgeAttrs(g);
        g.computeBoundingSphere();
        return g;
      };

      return {
        top: makeGeo(topPos, topUv, topBW, topOD, topEW, topIdx),
        side: makeGeo(sidePos, sideUv, sideBW, sideOD, sideEW, sideIdx)
      };
    }

    // Terrain warp (slabs) - now only handles ground noise, lump, muffin, and round
    function warpSolidGeometry(geo, params, simplexGround, simplexLump){
      const posAttr = geo.getAttribute("position");
      const isTopAttr = geo.getAttribute("isTop");
      if (!posAttr || !isTopAttr) return;

      const boundaryW = geo.getAttribute("boundaryW");
      const outDirXZ = geo.getAttribute("outDirXZ");

      const p = params;
      const pos = posAttr.array;

      const ampGround = p.groundAmp * p.levelHeight;
      const ampLump   = p.lumpAmp   * p.levelHeight;

      const muffinLift = p.muffinLift * p.levelHeight;
      const muffinOver = p.muffinOver * p.tileSize;
      const round = Math.max(0, p.round) * p.levelHeight;

      for (let i=0;i<pos.length;i+=3){
        const vi = (i/3);
        const x0 = pos[i+0];
        const y0 = pos[i+1];
        const z0 = pos[i+2];

        let x = x0;
        let z = z0;
        let dy = 0;

        const gN = simplexGround.noise(x * p.groundScale, z * p.groundScale);
        dy += clamp(gN / 70.0, -1, 1) * ampGround;

        const lN = simplexLump.noise(x * p.lumpScale, z * p.lumpScale);
        dy += clamp(lN / 70.0, -1, 1) * ampLump;

        if (boundaryW && outDirXZ){
          const bw = boundaryW.array[vi];
          if (bw > 0){
            const t = smoothstep(0.0, 1.0, bw);
            const ox = outDirXZ.array[vi*2+0];
            const oz = outDirXZ.array[vi*2+1];

            if (isTopAttr.array[vi] === 1){
              x += ox * muffinOver * t;
              z += oz * muffinOver * t;
              dy += muffinLift * t;
            }

            if (round > 0){
              dy -= round * t;
              x -= ox * (round * 0.35) * t;
              z -= oz * (round * 0.35) * t;
            }
          }
        }

        pos[i+0] = x;
        pos[i+2] = z;
        pos[i+1] = y0 + dy;
      }

      posAttr.needsUpdate = true;
      geo.computeVertexNormals();
      geo.computeBoundingSphere();
    }

    // NEW: wall warp (applies to cliff backs + rock walls)
    // Roughens along the wall normal so it reads as actual terrain, not flat sheets.
    function warpWallGeometry(geo, params, simplex, roughMul){
      if (!geo) return;
      const posAttr = geo.getAttribute("position");
      if (!posAttr) return;

      geo.computeVertexNormals();
      const norAttr = geo.getAttribute("normal");
      if (!norAttr) return;

      const p = params;
      const pos = posAttr.array;
      const nor = norAttr.array;

      // strength comes from LumpAmp + a bit of Round (so "Round" affects cliffs too)
      const base = (p.lumpAmp * p.levelHeight * 0.35) + (p.round * p.levelHeight * 0.20);
      const strength = base * clamp(roughMul, 0, 6);

      if (strength <= 0) return;

      const scale = Math.max(0.01, p.lumpScale) * 0.9;

      for (let i=0;i<pos.length;i+=3){
        const x = pos[i+0], y = pos[i+1], z = pos[i+2];

        // stable noise in world space
        const n = simplex.noise(x * scale, z * scale); // [-70..70-ish]
        const t = clamp(n / 70.0, -1, 1);

        // add a small vertical component so walls don't look "stamped"
        const n2 = simplex.noise((x+17.7) * scale, (z-9.2) * scale);
        const t2 = clamp(n2 / 70.0, -1, 1);

        const d = (t * 0.75 + t2 * 0.25) * strength;

        // push along the vertex normal (keeps it "wall-ish")
        pos[i+0] += nor[i+0] * d;
        pos[i+1] += nor[i+1] * (d * 0.20);
        pos[i+2] += nor[i+2] * d;
      }

      posAttr.needsUpdate = true;
      geo.computeVertexNormals();
      geo.computeBoundingSphere();
    }

    function makeGrassBladeGeometry(radius, height){
      const geo = new THREE.PlaneGeometry(radius*2, radius*2, 2, 2);
      geo.rotateX(-Math.PI/2);

      const pos = geo.attributes.position.array;
      const vCount = geo.attributes.position.count;

      let centerIdx = 0, best = Infinity;
      for (let i=0;i<vCount;i++){
        const x = pos[i*3+0], y = pos[i*3+1], z = pos[i*3+2];
        const d = x*x + y*y + z*z;
        if (d < best){ best = d; centerIdx = i; }
      }

      for (let i=0;i<vCount;i++){
        const i3 = i*3;
        pos[i3+1] = (i === centerIdx) ? height : -height * 0.12;
      }
      geo.attributes.position.needsUpdate = true;

      const isPeak = new Float32Array(vCount);
      isPeak.fill(0);
      isPeak[centerIdx] = 1;
      geo.setAttribute("isPeak", new THREE.BufferAttribute(isPeak, 1));

      geo.computeVertexNormals();
      geo.computeBoundingSphere();
      return geo;
    }

    function facingDirVector(label){
      switch(label){
        case "X+": return new THREE.Vector3(1,0,0);
        case "X-": return new THREE.Vector3(-1,0,0);
        case "Z+": return new THREE.Vector3(0,0,1);
        case "Z-": return new THREE.Vector3(0,0,-1);
        default: return new THREE.Vector3(1,0,0);
      }
    }

    function buildWallsGeometry(params, levels, vertDir, vertType, preset, cliffFacingLabel){
      const { w,h, tileSize, levelHeight, maxLevel } = params;
      const idx = (x,z)=>z*w+x;
      const L = (x,z)=>levels[idx(x,z)];
      const VDir = (x,z)=>vertDir[idx(x,z)];
      const VType = (x,z)=>vertType[idx(x,z)];
      const isRamp = (x,z)=>VType(x,z) === 1;


      // NEW: precompute corner heights so wall tops match warped tier lips
      const tileInfo = new Array(w*h);
      for (let zz=0; zz<h; zz++){
        for (let xx=0; xx<w; xx++){
          tileInfo[idx(xx,zz)] = computeTileCornerHeights(xx, zz, params, levels, vertDir, vertType);
        }
      }
      function edgeBridged(ax,az,bx,bz){
        if (isRamp(ax,az) && pointsToNeighbor(VDir(ax,az), ax,az,bx,bz)) return true;
        if (isRamp(bx,bz) && pointsToNeighbor(VDir(bx,bz), bx,bz,ax,az)) return true;
        return false;
      }

      const other = { positions:[], uvs:[], indices:[], vc:0 };
      const back  = { positions:[], uvs:[], indices:[], vc:0 };
      const cliffBack = { positions:[], uvs:[], indices:[], vc:0 };
      const rampBack = { positions:[], uvs:[], indices:[], vc:0 }; // walls under ramps (grass-colored)

      const cliffEdges = [];

      function addQuad(buf, v0,v1,v2,v3){
        const base = buf.vc;
        buf.positions.push(...v0, ...v1, ...v2, ...v3);
        buf.uvs.push(0,0, 1,0, 1,1, 0,1);
        buf.indices.push(base+0, base+1, base+2, base+0, base+2, base+3);
        buf.vc += 4;
      }

      const up = new THREE.Vector3(0,1,0);
      const verticalMaxAbsNy = clamp(preset.cliffSelection.verticalMaxAbsNy, 0, 1);
      const minFacingDot = clamp(preset.cliffSelection.minFacingDot, -1, 1);

      const facingIsAny = (cliffFacingLabel === "ANY");
      const facing = facingIsAny ? new THREE.Vector3(1,0,0) : facingDirVector(cliffFacingLabel).normalize();

      function classifyWallByNormal(nx, ny, nz){
        const n = new THREE.Vector3(nx,ny,nz).normalize();
        if (Math.abs(n.dot(up)) > verticalMaxAbsNy) return "other";
        if (facingIsAny) return "cliff";
        const d = n.dot(facing);
        if (d >= minFacingDot) return "cliff";
        if (d <= -minFacingDot) return "back";
        return "other";
      }

      function addWallBetween(ax,az, bx,bz, kind, bridged){
        const a = L(ax,az);
        const b = L(bx,bz);
        if (a === b) return;

        const lowLvl = Math.min(a,b);
        const highLvl = Math.max(a,b);
        const low = lowLvl * levelHeight;
        const high = highLvl * levelHeight;

        const height01 = clamp(highLvl / Math.max(1, maxLevel), 0, 1);
        const passesMinHeight = height01 >= clamp(preset.cliffSelection.minHeight01, 0, 1);

        if (kind === "E"){
          const X = (ax+1) * tileSize;
          const z0 = az * tileSize;
          const z1 = (az+1) * tileSize;

          const v0 = [X, low,  z0];
          const v1 = [X, low,  z1];
                 // pick the higher tile to source warped lip heights
const hiIsA = (a > b);
const hiX = hiIsA ? ax : bx;
const hiZ = hiIsA ? az : bz;
const hiT = tileInfo[idx(hiX, hiZ)];

// if higher tile is left (ax,az), use its east edge corners y10/y11
// if higher tile is right (bx,bz), use its west edge corners y00/y01
const high0 = hiIsA ? hiT.y10 : hiT.y00; // at z0
const high1 = hiIsA ? hiT.y11 : hiT.y01; // at z1

const v2 = [X, high1, z1];
const v3 = [X, high0, z0];

          if (bridged){
            // Keep a backing wall under the ramp slope, but tint it like "grass/soil".
            addQuad(rampBack, v0,v1,v2,v3);
            return;
          }

          const bigDrop = (high - low) > (levelHeight + 1e-6);
          const cls0 = classifyWallByNormal(1,0,0);
          let cls = (!passesMinHeight && cls0 === "cliff") ? "other" : cls0;
          if (bigDrop) cls = "cliff";

          const wantsRampFill = (isRamp(ax,az) || isRamp(bx,bz));
          if (wantsRampFill && cls !== "cliff"){
            // Fill ramp-adjacent cutouts so we never see sky through missing walls.
            // Uses the same material routing as the top surface.
            addQuad(rampBack, v0,v1,v2,v3);
            return;
          }

          if (cls === "cliff"){
            addQuad(cliffBack, v0,v1,v2,v3);
            cliffEdges.push({ axis:"Z", fixed:X, start:z0, end:z1, low, high, normal:new THREE.Vector3(1,0,0) });
          } else if (cls === "back"){
            addQuad(back, v0,v1,v2,v3);
          } else {
            addQuad(other, v0,v1,v2,v3);
          }
        } else if (kind === "N"){
          const Z = (az+1) * tileSize;
          const x0 = ax * tileSize;
          const x1 = (ax+1) * tileSize;

          const v0 = [x0, low,  Z];
          const v1 = [x1, low,  Z];
                 const hiIsA = (a > b);
const hiX = hiIsA ? ax : bx;
const hiZ = hiIsA ? az : bz;
const hiT = tileInfo[idx(hiX, hiZ)];

// if higher tile is lower (ax,az), use its north edge y01/y11
// if higher tile is upper (bx,bz), use its south edge y00/y10
const high0 = hiIsA ? hiT.y01 : hiT.y00; // at x0
const high1 = hiIsA ? hiT.y11 : hiT.y10; // at x1

const v2 = [x1, high1, Z];
const v3 = [x0, high0, Z];

          if (bridged){
            addQuad(rampBack, v0,v1,v2,v3);
            return;
          }

          const bigDrop = (high - low) > (levelHeight + 1e-6);
          const cls0 = classifyWallByNormal(0,0,1);
          let cls = (!passesMinHeight && cls0 === "cliff") ? "other" : cls0;
          if (bigDrop) cls = "cliff";

          const wantsRampFill = (isRamp(ax,az) || isRamp(bx,bz));
          if (wantsRampFill && cls !== "cliff"){
            // Fill ramp-adjacent cutouts so we never see sky through missing walls.
            // Uses the same material routing as the top surface.
            addQuad(rampBack, v0,v1,v2,v3);
            return;
          }

          if (cls === "cliff"){
            addQuad(cliffBack, v0,v1,v2,v3);
            cliffEdges.push({ axis:"X", fixed:Z, start:x0, end:x1, low, high, normal:new THREE.Vector3(0,0,1) });
          } else if (cls === "back"){
            addQuad(back, v0,v1,v2,v3);
          } else {
            addQuad(other, v0,v1,v2,v3);
          }
        }
      }

      for (let z=0; z<h; z++){
        for (let x=0; x<w; x++){
          if (x < w-1){
            const a = L(x,z), b = L(x+1,z);
            if (a !== b) addWallBetween(x,z,x+1,z,"E", edgeBridged(x,z,x+1,z));
          }
          if (z < h-1){
            const a = L(x,z), b = L(x,z+1);
            if (a !== b) addWallBetween(x,z,x,z+1,"N", edgeBridged(x,z,x,z+1));
          }
        }
      }

      cliffEdges.sort((a,b)=>{
        if (a.axis !== b.axis) return a.axis < b.axis ? -1 : 1;
        if (a.fixed !== b.fixed) return a.fixed - b.fixed;
        if (a.low !== b.low) return a.low - b.low;
        if (a.high !== b.high) return a.high - b.high;
        return a.start - b.start;
      });

      const cliffRuns = [];
      const eps = 1e-6;
      for (const e of cliffEdges){
        const last = cliffRuns[cliffRuns.length-1];
        if (last &&
          last.axis === e.axis &&
          Math.abs(last.fixed - e.fixed) < eps &&
          Math.abs(last.low - e.low) < eps &&
          Math.abs(last.high - e.high) < eps &&
          Math.abs(last.end - e.start) < eps
        ){
          last.end = e.end;
        } else {
          cliffRuns.push({ ...e });
        }
      }

      const makeGeo = (buf)=>{
        let geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.Float32BufferAttribute(buf.positions, 3));
        geo.setAttribute("uv", new THREE.Float32BufferAttribute(buf.uvs, 2));
        geo.setIndex(buf.indices);
        geo = globalThis.applySmoothNormalsIfEnabled(geo);
        geo.computeBoundingSphere();
        return geo;
      };

      return {
        geoOther: makeGeo(other),
        geoBack: makeGeo(back),
        geoCliffBack: makeGeo(cliffBack),
        geoRampBack: makeGeo(rampBack),
        cliffRuns
      };
    }

    // ============================================================================
    // GENERATOR REGISTRY (token-friendly ‚Äúislands‚Äù you can extract later)
    // ============================================================================
    const Generators = (() => {
      const _map = new Map();
      return {
        register(name, spec){
          const key = String(name || "");
          if (!key) throw new Error("Generators.register: missing name");
          if (!spec || typeof spec.make !== "function") throw new Error("Generators.register(" + key + "): spec.make required");
          _map.set(key, { name: key, ...spec });
        },
        get(name){ return _map.get(String(name)); },
        list(){ return Array.from(_map.keys()).sort(); },
        make(name, params, seedStr, scale = 1){
          const g = _map.get(String(name));
          if (!g) throw new Error("Unknown generator: " + name);
          const base = (g.defaults && typeof g.defaults === "object") ? structuredClone(g.defaults) : {};
          const merged = { ...base, ...(params || {}) };
          return g.make(merged, String(seedStr || ""), scale);
        }
      };
    })();
    globalThis.Generators = Generators;
    const fract = (x)=>x - Math.floor(x);
    function hash3(ix, iy, iz, seed){
      let h = seed ^ (ix * 374761393) ^ (iy * 668265263) ^ (iz * 2147483647);
      h = Math.imul(h ^ (h >>> 13), 1274126177);
      return fract((h >>> 0) / 4294967296);
    }

// Float-coordinate hash helper used by some generators.
// Deterministic for a given (x,y,z,seed). Output in [0,1).
function hash3D(x, y, z, seed){
  // Quantize floats to stable integer lattice before hashing.
  // 4096 gives decent resolution while staying within 32-bit integer range for typical scene scales.
  const q = 4096;
  const ix = Math.floor(x * q);
  const iy = Math.floor(y * q);
  const iz = Math.floor(z * q);
  return hash3(ix, iy, iz, seed);
}
    function valueNoise3D(x, y, z, seed){
      const ix = Math.floor(x), iy = Math.floor(y), iz = Math.floor(z);
      const fx = x - ix, fy = y - iy, fz = z - iz;
      const u = fx*fx*fx*(fx*(fx*6-15)+10);
      const v = fy*fy*fy*(fy*(fy*6-15)+10);
      const w = fz*fz*fz*(fz*(fz*6-15)+10);

      const n000 = hash3(ix,   iy,   iz,   seed);
      const n100 = hash3(ix+1, iy,   iz,   seed);
      const n010 = hash3(ix,   iy+1, iz,   seed);
      const n110 = hash3(ix+1, iy+1, iz,   seed);

      const n001 = hash3(ix,   iy,   iz+1, seed);
      const n101 = hash3(ix+1, iy,   iz+1, seed);
      const n011 = hash3(ix,   iy+1, iz+1, seed);
      const n111 = hash3(ix+1, iy+1, iz+1, seed);

      const nx00 = lerp(n000, n100, u);
      const nx10 = lerp(n010, n110, u);
      const nx01 = lerp(n001, n101, u);
      const nx11 = lerp(n011, n111, u);

      const nxy0 = lerp(nx00, nx10, v);
      const nxy1 = lerp(nx01, nx11, v);
      return lerp(nxy0, nxy1, w);
    }
    function fbm3D(x,y,z,seed,octaves,lacunarity,gain){
      let amp = 0.5, freq = 1.0, sum = 0.0, norm = 0.0;
      const oct = Math.max(1, Math.floor(octaves));
      const lac = Math.max(1.0, lacunarity);
      const g = clamp(gain, 0.05, 0.95);
      for (let i=0;i<oct;i++){
        sum += valueNoise3D(x*freq, y*freq, z*freq, seed + i*1013) * amp;
        norm += amp;
        freq *= lac;
        amp *= g;
      }
      return sum / Math.max(1e-6, norm);
    }
    function makeRockGeometryFromPreset(preset, seedStr, baseSize){
      const carve = preset.carve;
      const micro = preset.micro;

      const seedU32 = xmur3(seedStr)();
      const seg = 10;
      const g = new THREE.BoxGeometry(baseSize, baseSize, baseSize, seg, seg, seg);

      g.computeVertexNormals();
      const posAttr = g.attributes.position;
      const pos = posAttr.array;
      const nor = g.attributes.normal.array;

      const worldScaleRef = baseSize;
      const noiseScale = Math.max(1e-4, carve.noiseScale);
      const octaves = Math.max(1, Math.floor(carve.octaves));
      const lac = Math.max(1.0, carve.lacunarity);
      const gain = clamp(carve.gain, 0.05, 0.95);

      const carveStrength = clamp(carve.carveStrength, 0, 4);
      const carveBias = clamp(carve.carveBias, -1, 1);
      const maxCarve = worldScaleRef * 0.20 * carveStrength;

      for (let i=0;i<pos.length;i+=3){
        const x = pos[i], y = pos[i+1], z = pos[i+2];
        const n = fbm3D(
          (x / Math.max(1e-6, worldScaleRef)) * noiseScale + 11.3,
          (y / Math.max(1e-6, worldScaleRef)) * noiseScale -  7.1,
          (z / Math.max(1e-6, worldScaleRef)) * noiseScale +  3.7,
          seedU32,
          octaves,
          lac,
          gain
        );
        const t = clamp((n - (0.5 - carveBias)) * 1.35, 0, 1);
        const d = maxCarve * t;
        pos[i]   = x - nor[i]   * d;
        pos[i+1] = y - nor[i+1] * d;
        pos[i+2] = z - nor[i+2] * d;
      }
      posAttr.needsUpdate = true;

      if (micro.quantize > 0){
        const step = micro.quantize;
        for (let i=0;i<pos.length;i+=3){
          pos[i+0] = Math.round(pos[i+0] / step) * step;
          pos[i+1] = Math.round(pos[i+1] / step) * step;
          pos[i+2] = Math.round(pos[i+2] / step) * step;
        }
        posAttr.needsUpdate = true;
      }

      g.computeVertexNormals();
      g.computeBoundingSphere();
      return globalThis.ensureEdgeAttrs ? globalThis.ensureEdgeAttrs(g) : g;
    }


    // ============================================================================
    // Generator island: ROCK (geometry)
    // ============================================================================
    (() => {
      Generators.register("rock", {
        kind: "geometry",
        defaults: { preset: DEFAULT_CLIFFSIDE_PRESET_V2, baseSize: 1.0 },
        make: (params, seedStr, scale)=>{
          const preset = params.preset || DEFAULT_CLIFFSIDE_PRESET_V2;
          const baseSize = (params.baseSize ?? 1.0) * scale;
          return makeRockGeometryFromPreset(preset, seedStr, baseSize);
        }
      });
    })();

    // ============================================================================
    // Generator island: WALL / ROAD / STACKS (object3d)
    // ============================================================================
    // NOTE: Keep this "generator island" self-contained so you can copy/paste it 
    // out later without dragging the entire app with it.
    // 
    // DEPENDENCIES:
    // - Requires THREE.js
    // - Requires Generators registry with "rock" generator registered
    // - Requires xmur3 hash function for seeding
    // ============================================================================

    (() => {
      // ============================================================================
      // HELPER: Simple RNG with seed
      // ============================================================================
      function makeRng(seed) {
        const h = xmur3(String(seed || ""));
        let state = h();
        
        function next() {
          state ^= state << 13;
          state ^= state >>> 17;
          state ^= state << 5;
          return Math.abs(state) / 0x7fffffff;
        }
        
        return {
          random: () => next(),
          range: (min, max) => min + next() * (max - min),
          int: (min, max) => Math.floor(min + next() * (max - min + 1))
        };
      }

      // ============================================================================
      // HELPER: Utilities
      // ============================================================================
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      const clamp01 = (v) => clamp(v, 0, 1);
      const lerp = (a, b, t) => a + (b - a) * t;
      const degToRad = (deg) => deg * (Math.PI / 180);

      function orderedRange(a, b) {
        return { min: Math.min(a, b), max: Math.max(a, b) };
      }

      // ============================================================================
      // DEFAULT PRESET
      // ============================================================================
      const DEFAULT_WALL_STACKS_PRESET = {
        version: 1,
        kind: "wall_stacks_preset",
        name: "wall-stacks-default",

        // What to build
        mode: "wall", // "wall", "road", or "stacks"

        // Rock generation params (passed to rock generator)
        rock: {
          baseSize: 1.0,
          preset: null // uses DEFAULT_CLIFFSIDE_PRESET_V2 if null
        },

        // Unit size (size of each rock after scaling)
        unitSize: { x: 1.0, y: 1.0, z: 1.0 },

        // Base gap between rocks
        gapBase: { x: 0.05, y: 0.05, z: 0.05 },

        // Density control (0=loose, 1=tight)
        density: {
          value01: 0.75,
          overlapFrac: 0.10
        },

        // Pre-transform applied to each rock before placement
        preTransform: {
          translate: [0, 0, 0],
          rotateDegXYZ: [0, 0, 0],
          scale: [1, 1, 1]
        },

        // Random variation ranges
        random: {
          rotationDeg: {
            x: { min: -5, max: 5 },
            y: { min: -180, max: 180 },
            z: { min: -5, max: 5 }
          },
          scale: {
            x: { min: 0.85, max: 1.15 },
            y: { min: 0.85, max: 1.15 },
            z: { min: 0.85, max: 1.15 }
          },
          translate: {
            x: { min: -0.05, max: 0.05 },
            y: { min: -0.05, max: 0.05 },
            z: { min: -0.05, max: 0.05 }
          }
        },

        // WALL MODE settings
        wall: {
          length: 14,      // units wide
          height: 6,       // units tall
          stagger: {
            enabled: true,
            amountInUnits: 0.5 // offset every other row by this many units
          },
          microJitter: { x: 0.03, y: 0.03, z: 0.03 },
          buildFromGround: true // start at y=0 and build upward
        },

        // ROAD MODE settings
        road: {
          length: 14,      // units long
          width: 6,        // units wide
          packing: {
            mode: "grid",
            stepMultiplier: 1.0
          },
          planarJitter: { x: 0.05, z: 0.05 },
          crown: {
            enabled: false,
            height: 0.0 // parabolic crown height at center
          }
        },

        // STACKS MODE settings
        stacks: {
          axis: "X",       // "X", "Y", or "Z"
          centered: true,  // center the line around origin
          count: 10,       // number of rocks in line
          stepMultiplier: 1.0,
          duplicates: {
            copies: 1,     // number of parallel lines
            offset: { x: 0, y: 0, z: 3 } // offset between parallel lines
          }
        }
      };

      // ============================================================================
      // CORE: Effective gap computation
      // ============================================================================
      function computeEffectiveGap(baseGap, unitSize, density01, overlapFrac) {
        const d = clamp01(density01);
        const extra = (0.5 - d) * 2.0 * overlapFrac;
        
        return {
          x: baseGap.x + extra * unitSize.x,
          y: baseGap.y + extra * unitSize.y,
          z: baseGap.z + extra * unitSize.z
        };
      }

      // ============================================================================
      // CORE: Pre-transform matrix
      // ============================================================================
      function preTRSToMatrix(translate, rotateDegXYZ, scale) {
        const pos = new THREE.Vector3(translate[0], translate[1], translate[2]);
        const rot = new THREE.Euler(
          degToRad(rotateDegXYZ[0]),
          degToRad(rotateDegXYZ[1]),
          degToRad(rotateDegXYZ[2]),
          "XYZ"
        );
        const scl = new THREE.Vector3(scale[0], scale[1], scale[2]);
        
        return new THREE.Matrix4().compose(
          pos,
          new THREE.Quaternion().setFromEuler(rot),
          scl
        );
      }

      // ============================================================================
      // CORE: Apply random TRS
      // ============================================================================
      function applyRandomTRS(rng, random) {
        const rx = rng.range(random.rotationDeg.x.min, random.rotationDeg.x.max);
        const ry = rng.range(random.rotationDeg.y.min, random.rotationDeg.y.max);
        const rz = rng.range(random.rotationDeg.z.min, random.rotationDeg.z.max);

        const sx = rng.range(random.scale.x.min, random.scale.x.max);
        const sy = rng.range(random.scale.y.min, random.scale.y.max);
        const sz = rng.range(random.scale.z.min, random.scale.z.max);

        const tx = rng.range(random.translate.x.min, random.translate.x.max);
        const ty = rng.range(random.translate.y.min, random.translate.y.max);
        const tz = rng.range(random.translate.z.min, random.translate.z.max);

        return {
          t: [tx, ty, tz],
          r: [degToRad(rx), degToRad(ry), degToRad(rz)],
          s: [sx, sy, sz]
        };
      }

      // ============================================================================
      // CORE: Generate instance matrices
      // ============================================================================
      function generateMatrices(preset, seedStr) {
        const rng = makeRng(seedStr);
        const preM = preTRSToMatrix(
          preset.preTransform.translate,
          preset.preTransform.rotateDegXYZ,
          preset.preTransform.scale
        );

        const mats = [];
        const mode = preset.mode || "wall";
        
        // Compute effective gap
        const effGap = computeEffectiveGap(
          preset.gapBase,
          preset.unitSize,
          preset.density.value01,
          preset.density.overlapFrac
        );

        // =========================
        // WALL MODE
        // =========================
        if (mode === "wall") {
          const w = preset.wall;
          const u = preset.unitSize;
          
          const stepX = u.x + effGap.x;
          const stepY = u.y + effGap.y;

          const cols = Math.max(1, Math.floor(w.length / stepX));
          const rows = Math.max(1, Math.floor(w.height / stepY));

          for (let row = 0; row < rows; row++) {
            const staggerUnits = (w.stagger.enabled && (row % 2 === 1)) 
              ? w.stagger.amountInUnits 
              : 0;
            const staggerX = staggerUnits * stepX;

            for (let col = 0; col < cols; col++) {
              // X centered, Y builds upward from 0
              const x0 = (col * stepX + staggerX) - (cols * stepX) / 2 + stepX / 2;
              const y0 = (row * stepY) + stepY / 2;

              const jx = rng.range(-w.microJitter.x, w.microJitter.x);
              const jy = rng.range(-w.microJitter.y, w.microJitter.y);
              const jz = rng.range(-w.microJitter.z, w.microJitter.z);

              const rt = applyRandomTRS(rng, preset.random);

              const pos = new THREE.Vector3(
                x0 + jx + rt.t[0],
                y0 + jy + rt.t[1],
                0 + jz + rt.t[2]
              );
              const eul = new THREE.Euler(rt.r[0], rt.r[1], rt.r[2], "XYZ");
              const scl = new THREE.Vector3(rt.s[0], rt.s[1], rt.s[2]);

              const inst = new THREE.Matrix4().compose(
                pos,
                new THREE.Quaternion().setFromEuler(eul),
                scl
              );
              mats.push(inst.clone().multiply(preM));
            }
          }
          return mats;
        }

        // =========================
        // STACKS MODE
        // =========================
        if (mode === "stacks") {
          const st = preset.stacks;
          const u = preset.unitSize;
          const axis = (st.axis || "X").toUpperCase();

          const stepX = (u.x + effGap.x) * (st.stepMultiplier ?? 1);
          const stepY = (u.y + effGap.y) * (st.stepMultiplier ?? 1);
          const stepZ = (u.z + effGap.z) * (st.stepMultiplier ?? 1);

          const step = (axis === "Y") ? stepY : (axis === "Z" ? stepZ : stepX);
          const count = Math.max(1, Math.floor(st.count ?? 1));

          const centered = !!st.centered;
          const lineStart = centered ? (-(count * step) / 2 + step / 2) : 0;

          const copies = Math.max(1, Math.floor(st.duplicates?.copies ?? 1));
          const off = st.duplicates?.offset ?? { x: 0, y: 0, z: 0 };

          for (let c = 0; c < copies; c++) {
            const baseX = (off.x || 0) * c;
            const baseY = (off.y || 0) * c;
            const baseZ = (off.z || 0) * c;

            for (let i = 0; i < count; i++) {
              const d = lineStart + i * step;

              let x0 = 0, y0 = 0, z0 = 0;
              if (axis === "Y") y0 = d;
              else if (axis === "Z") z0 = d;
              else x0 = d;

              const rt = applyRandomTRS(rng, preset.random);

              const pos = new THREE.Vector3(
                baseX + x0 + rt.t[0],
                baseY + y0 + rt.t[1],
                baseZ + z0 + rt.t[2]
              );
              const eul = new THREE.Euler(rt.r[0], rt.r[1], rt.r[2], "XYZ");
              const scl = new THREE.Vector3(rt.s[0], rt.s[1], rt.s[2]);

              const inst = new THREE.Matrix4().compose(
                pos,
                new THREE.Quaternion().setFromEuler(eul),
                scl
              );
              mats.push(inst.clone().multiply(preM));
            }
          }
          return mats;
        }

        // =========================
        // ROAD MODE (default)
        // =========================
        const rd = preset.road;
        const u = preset.unitSize;
        
        const stepX = (u.x + effGap.x) * rd.packing.stepMultiplier;
        const stepZ = (u.z + effGap.z) * rd.packing.stepMultiplier;

        const cols = Math.max(1, Math.floor(rd.length / stepX));
        const rows = Math.max(1, Math.floor(rd.width / stepZ));

        for (let rz = 0; rz < rows; rz++) {
          for (let cx = 0; cx < cols; cx++) {
            const x0 = (cx * stepX) - (cols * stepX) / 2 + stepX / 2;
            const z0 = (rz * stepZ) - (rows * stepZ) / 2 + stepZ / 2;

            const jx = rng.range(-rd.planarJitter.x, rd.planarJitter.x);
            const jz = rng.range(-rd.planarJitter.z, rd.planarJitter.z);

            let y0 = 0;
            if (rd.crown.enabled && rd.crown.height !== 0) {
              const nz = z0 / (rd.width / 2);
              const crownFactor = 1 - Math.min(1, Math.abs(nz));
              y0 = rd.crown.height * crownFactor * crownFactor;
            }

            const rt = applyRandomTRS(rng, preset.random);

            const pos = new THREE.Vector3(
              x0 + jx + rt.t[0],
              y0 + rt.t[1],
              z0 + jz + rt.t[2]
            );
            const eul = new THREE.Euler(rt.r[0], rt.r[1], rt.r[2], "XYZ");
            const scl = new THREE.Vector3(rt.s[0], rt.s[1], rt.s[2]);

            const inst = new THREE.Matrix4().compose(
              pos,
              new THREE.Quaternion().setFromEuler(eul),
              scl
            );
            mats.push(inst.clone().multiply(preM));
          }
        }
        return mats;
      }

      // ============================================================================
      // MAIN: Generate wall/road/stacks group
      // ============================================================================
      function makeWallStacksGroupFromPreset(preset, seedStr, scale = 1) {
        const p = { ...DEFAULT_WALL_STACKS_PRESET, ...preset };
        const s = Math.max(0.01, scale);
        
        // Generate instance matrices
        const matrices = generateMatrices(p, seedStr);
        
        if (matrices.length === 0) {
          return new THREE.Group(); // Empty group if no instances
        }

        // Get rock generator
        const rockGen = Generators.get("rock");
        if (!rockGen) {
          throw new Error("Wall/stacks generator requires 'rock' generator to be registered");
        }

        // Generate a single rock geometry (all instances share this)
        const rockGeometry = rockGen.make(
          { 
            preset: p.rock.preset, 
            baseSize: p.rock.baseSize * s 
          },
          seedStr,
          1.0
        );

        // Create a basic material (you can customize this)
        const rockMaterial = new THREE.MeshStandardMaterial({
          color: 0x808080,
          roughness: 0.9,
          metalness: 0.1
        });

        // Create instanced mesh
        const instancedMesh = new THREE.InstancedMesh(
          rockGeometry,
          rockMaterial,
          matrices.length
        );
        instancedMesh.frustumCulled = false;

        // Apply all matrices
        for (let i = 0; i < matrices.length; i++) {
          instancedMesh.setMatrixAt(i, matrices[i]);
        }
        instancedMesh.instanceMatrix.needsUpdate = true;

        // Wrap in a group
        const group = new THREE.Group();
        group.name = `wall_stacks_${p.mode}`;
        group.add(instancedMesh);
        
        group.userData.__wallStacksPresetName = p.name || "";
        group.userData.__mode = p.mode;
        group.userData.__instanceCount = matrices.length;
        
        return group;
      }

      // ============================================================================
      // REGISTRATION
      // ============================================================================
      Generators.register("wall_stacks", {
        kind: "object3d",
        defaults: DEFAULT_WALL_STACKS_PRESET,
        make: (params, seedStr, scale) => makeWallStacksGroupFromPreset(params, seedStr, scale)
      });

      // Also register convenient aliases for each mode
      Generators.register("wall", {
        kind: "object3d",
        defaults: { ...DEFAULT_WALL_STACKS_PRESET, mode: "wall" },
        make: (params, seedStr, scale) => makeWallStacksGroupFromPreset(
          { ...params, mode: "wall" }, 
          seedStr, 
          scale
        )
      });

      Generators.register("road", {
        kind: "object3d",
        defaults: { ...DEFAULT_WALL_STACKS_PRESET, mode: "road" },
        make: (params, seedStr, scale) => makeWallStacksGroupFromPreset(
          { ...params, mode: "road" }, 
          seedStr, 
          scale
        )
      });

      Generators.register("stacks", {
        kind: "object3d",
        defaults: { ...DEFAULT_WALL_STACKS_PRESET, mode: "stacks" },
        make: (params, seedStr, scale) => makeWallStacksGroupFromPreset(
          { ...params, mode: "stacks" }, 
          seedStr, 
          scale
        )
      });

    })();

    // ============================================================================
    // Wall/Road/Stacks Generator - Presets Library
    // ============================================================================
    // Presets converted from recipe JSONs for use with the wall/stacks generator
    // ============================================================================

    const WALL_ROAD_PRESETS = {
      
      // ===========================================================================
      // ROCK PRESETS
      // ===========================================================================
      
      /**
       * Rough Brick Rock Preset (from roughbrick2_rockrecipe.json)
       * A textured rock with high detail, good for walls and roads
       */
      ROUGH_BRICK_ROCK: {
        version: 2,
        kind: "rock_preset",
        name: "rough-brick-rock",
        
        // Core carving parameters
        carve: {
          noiseScale: 3.86,
          octaves: 4,
          lacunarity: 2.0,
          gain: 0.52,
          carveStrength: 0.55,
          carveBias: 0.1
        },
        
        // Micro detail
        micro: {
          quantize: 0.025  // Subtle voxelization for texture
        },
        
        // Note: Original preset had additional features (warp, chip, plateau, erosion)
        // that could be added to the rock generator in the future
        
        // Original full parameters for reference:
        _originalPreset: {
          warp: {
            warpStrength: 0,
            warpDisplace: 0,
            warpScale: 3.15,
            warpOctaves: 4,
            warpLacunarity: 2.35,
            warpGain: 0.55
          },
          chip: {
            chipSteps: 11,
            chipStrength: 0.22,
            chipBias: 0.82,
            chipBiasDir: "Z+",
            chipDepthRandom: 0.37,
            chipJitter: 0.35
          },
          erosion: {
            erosionSteps: 6,
            erosionStrength: 0.47,
            preserveEdges: 0.4,
            erosionSpherify: 0.14
          },
          micro: {
            microNoise: 0.035,
            microNoiseScale: 10,
            quantize: 0.025,
            flatShading: true
          }
        }
      },
      
      // ===========================================================================
      // WALL PRESETS
      // ===========================================================================
      
      /**
       * Standard Wall (from wallrecipe2.json)
       * A classic brick-style wall with subtle variation
       */
      STANDARD_WALL: {
        version: 1,
        kind: "wall_stacks_preset",
        name: "standard-wall",
        mode: "wall",
        
        // Rock generation using rough brick preset
        rock: {
          baseSize: 1.0,
          preset: null  // Will use ROUGH_BRICK_ROCK preset - set manually
        },
        
        // Unit sizing
        unitSize: { x: 1.0, y: 1.0, z: 1.0 },
        gapBase: { x: 0.05, y: 0.05, z: 0.05 },
        
        // Density control
        density: {
          value01: 0.75,
          overlapFrac: 0.1
        },
        
        // Pre-transform
        preTransform: {
          translate: [0, 0, 0],
          rotateDegXYZ: [0.5, 1, 0],
          scale: [1, 1, 1]
        },
        
        // Random variation - from wallrecipe2.json
        random: {
          rotationDeg: {
            x: { min: 2, max: 4 },
            y: { min: 0, max: 0 },      // No Y rotation
            z: { min: -1.5, max: -0.5 }
          },
          scale: {
            x: { min: 0.9, max: 1.39 },
            y: { min: 0.9, max: 1.33 },
            z: { min: 0.8, max: 1.19 }
          },
          translate: {
            x: { min: -0.02, max: 0.02 },
            y: { min: -0.01, max: 0.01 },
            z: { min: -0.02, max: 0.02 }
          }
        },
        
        // Wall-specific settings
        wall: {
          length: 14,
          height: 6,
          stagger: {
            enabled: true,
            amountInUnits: 0.5
          },
          microJitter: { x: 0.03, y: 0.02, z: 0.03 },
          buildFromGround: true
        },
        
        // Unused modes (for completeness)
        road: {
          length: 14, width: 6,
          packing: { mode: "grid", stepMultiplier: 1.0 },
          planarJitter: { x: 0.05, z: 0.05 },
          crown: { enabled: false, height: 0.0 }
        },
        stacks: {
          axis: "X", centered: true, count: 10, stepMultiplier: 1.0,
          duplicates: { copies: 1, offset: { x: 0, y: 0, z: 3 } }
        }
      },
      
      // ===========================================================================
      // ROAD PRESETS
      // ===========================================================================
      
      /**
       * Stone Road with Crown (from roadrecipe1.json)
       * A cobblestone-style road with parabolic crown and rough texture
       */
      STONE_ROAD: {
        version: 1,
        kind: "wall_stacks_preset",
        name: "stone-road",
        mode: "road",
        
        // Rock generation using rough brick preset
        rock: {
          baseSize: 1.0,
          preset: null  // Will use ROUGH_BRICK_ROCK preset - set manually
        },
        
        // Unit sizing
        unitSize: { x: 1.0, y: 1.0, z: 1.0 },
        gapBase: { x: 0.05, y: 0.05, z: 0.05 },
        
        // Density control
        density: {
          value01: 0.75,
          overlapFrac: 0.1
        },
        
        // Pre-transform (180¬∞ Y rotation from original recipe)
        preTransform: {
          translate: [0, 0, 0],
          rotateDegXYZ: [0, 180, 0],
          scale: [1, 1, 1]
        },
        
        // Random variation - from roadrecipe1.json
        random: {
          rotationDeg: {
            x: { min: -6, max: 6 },
            y: { min: 0, max: 0 },      // No Y rotation
            z: { min: -6, max: 6 }
          },
          scale: {
            x: { min: 0.9, max: 1.1 },
            y: { min: 0.9, max: 1.1 },
            z: { min: 0.9, max: 1.1 }
          },
          translate: {
            x: { min: 0.052, max: 0.088 },  // Offset X slightly
            y: { min: -0.01, max: 0.01 },
            z: { min: -0.02, max: 0.02 }
          }
        },
        
        // Road-specific settings
        road: {
          length: 14.5,
          width: 8,
          packing: {
            mode: "grid",
            stepMultiplier: 1.0
          },
          planarJitter: { x: 0.311, z: 0.63 },  // High jitter for organic look
          crown: {
            enabled: true,
            height: 0.08  // Subtle crown for drainage
          }
        },
        
        // Unused modes (for completeness)
        wall: {
          length: 14, height: 6,
          stagger: { enabled: true, amountInUnits: 0.5 },
          microJitter: { x: 0.03, y: 0.03, z: 0.03 },
          buildFromGround: true
        },
        stacks: {
          axis: "X", centered: true, count: 10, stepMultiplier: 1.0,
          duplicates: { copies: 1, offset: { x: 0, y: 0, z: 3 } }
        }
      }
    };

    // ============================================================================
    // PRESET LOADER UTILITY
    // ============================================================================

    /**
     * Load a preset and inject the rock preset reference
     * @param {string} presetName - Name of the preset (e.g., "STANDARD_WALL")
     * @param {object} rockPreset - Rock generation preset to use
     * @returns {object} Complete preset ready for Generators.make()
     */
    function loadPreset(presetName, rockPreset = WALL_ROAD_PRESETS.ROUGH_BRICK_ROCK) {
      const preset = WALL_ROAD_PRESETS[presetName];
      if (!preset) {
        throw new Error(`Unknown preset: ${presetName}`);
      }
      
      // Clone the preset and inject rock preset
      const loaded = JSON.parse(JSON.stringify(preset));
      loaded.rock.preset = rockPreset;
      
      return loaded;
    }

    // Make presets available globally
    globalThis.WALL_ROAD_PRESETS = WALL_ROAD_PRESETS;
    globalThis.loadPreset = loadPreset;

        // ============================================================================
    // Generator island: TREE (object3d)
    // ============================================================================
    (() => {
      // NOTE: Keep this "generator island" self-contained so you can copy/paste it out later
      // without dragging the entire HHInstanceMap app with it.
    
      const DEFAULT_TREE_PRESET_V2 = {
        version: 2,
        kind: "tree_preset",
        name: "tree-2",
    
        // Quality
        radialSegments: 10,
        ringSegments: 22,
    
        // Trunk (units are multiplied by the generator "scale" arg)
        trunkLength: 2.6,
        trunkRadius: 0.22,
        trunkTaper: 0.92,
        trunkBend: 0.55,
        trunkWonk: 0.60,
        trunkWonkScale: 1.35,
        trunkTwist: 0.25,
        trunkNoise: 0.75,
        trunkNoiseScale: 2.2,
        trunkNoiseOctaves: 3,
    
        // Roots
        rootsEnabled: true,
        rootCount: 5,
        rootLength: 1.7,
        rootRadius: 0.12,
        rootTaper: 0.82,
        rootSpread: 0.90,
        rootCurl: 0.55,
        rootWonk: 0.55,
    
        // Knot / Branch tiers
        knotEnabled: true,
        knotAt: 0.58,             // 0..1 along trunk
        knotTiers: 1,
        knotTierSpacing: 0.10,
        knotTierSizeDelta: 0.00,
        knotCount: 4,
        knotLength: 1.25,
        knotRadius: 0.10,
        knotTaper: 0.84,
        knotSpread: 0.90,
        knotUpDownBias: 0.75,      // -1..+1 (down..up)
        knotCurl: 0.25,
        knotWonk: 0.55,
    
        // Leaves (attached to knot branches; uses PNG alpha if supplied)
        leavesEnabled: false,
        leavesPerBranch: 10,
    
        leafLength: 0.55,
        leafWidth: 0.18,
        leafAlong01: 0.80,
        leafBottomFacesTrunk: true,
    
        // Helps stabilize "roll" around the branch axis (bark side vs trunk side)
        trunkRollBiasDist: 0.30,
    
        // Optional offsets inside the branch prism frame (for off-center PNG art)
        leafOffsetX: 0.00,
        leafOffsetY: 0.00,
        leafOffsetZ: 0.00,
    
        // Base rotations (degrees) in prism-local space
        leafYawDeg: 0,
        leafPitchDeg: 0,
        leafRollDeg: 0,
    
        // Random rotation ranges (degrees)
        leafRandYawDeg: 35,
        leafRandPitchDeg: 20,
        leafRandRollDeg: 25,
    
        // Symmetric layout + jitter
        leafRadial: 0.18,
        leafSpread: 1.0,
        leafJitterAlong: 0.12,
        leafJitterSide: 0.05,
        leafJitterNormal: 0.08,
    
        leafOpacity: 0.92,

// Season tint (0=dry‚Üídark orange, 1=wet‚Üírich dark green)
// Note: leafSeasonTintEnabled affects only the PNG plane leaves (not terrain/grass).
leafSeasonTintEnabled: true,
leafSeasonTintStrength: 1.0,  // 0=off, 1=full tint

// HSL endpoints in [0..1]. Hue: 0=red, ~0.08=orange, ~0.33=green
leafSeasonDryH: 0.08,
leafSeasonDryS: 0.88,
leafSeasonDryL: 0.24,

leafSeasonWetH: 0.33,
leafSeasonWetS: 0.80,
leafSeasonWetL: 0.22,
    
        // PNG persistence (optional). If empty, a small procedural needle texture is used.
        leafPngDataURL: "",
    
        // Debug (off by default; useful for diagnosing orientation)
        debugBranchLines: false,
        debugPrisms: false,
        debugPrismAxes: false,
        prismWidth: 0.08,
        prismDepth: 0.08,
    
        // Post
        weldVertices: true,
        weldTolerance: 1e-5,
        flatShading: false,
        wireframe: false,
    
        // Material
        barkColor: 0x4a3b33
      };
    
      // ---------------------------
      // Leaves (shared, token-friendly)
      // ---------------------------
      const __leafPlaneGeom = new THREE.PlaneGeometry(1, 1, 1, 1);
      __leafPlaneGeom.userData = __leafPlaneGeom.userData || {};
      __leafPlaneGeom.userData.__noDispose = true; // shared
    
      const __leafCache = {
        defaultTex: null,
        texByURL: new Map(),
        loading: new Set(),
        matByKey: new Map(),
      };


// Leaf season tint (dry ‚Üî wet). We tint via material.color (multiplies the PNG).
function __lerp(a, b, t){ return a + (b - a) * t; }
function __lerpHue(h0, h1, t){
  // Hue wrap-aware lerp in [0,1): takes the shortest path around the circle.
  let dh = ((h1 - h0 + 1.5) % 1.0) - 0.5; // [-0.5, +0.5)
  return (h0 + dh * t + 1.0) % 1.0;
}
function __getLeafTintConfig(p){
  const enabled = (p && typeof p.leafSeasonTintEnabled === "boolean") ? p.leafSeasonTintEnabled : true;
  const strength = clamp(Number.isFinite(p?.leafSeasonTintStrength) ? p.leafSeasonTintStrength : 1.0, 0, 1);

  const dry = {
    h: clamp(Number.isFinite(p?.leafSeasonDryH) ? p.leafSeasonDryH : 0.08, 0, 1),
    s: clamp(Number.isFinite(p?.leafSeasonDryS) ? p.leafSeasonDryS : 0.88, 0, 1),
    l: clamp(Number.isFinite(p?.leafSeasonDryL) ? p.leafSeasonDryL : 0.24, 0, 1),
  };
  const wet = {
    h: clamp(Number.isFinite(p?.leafSeasonWetH) ? p.leafSeasonWetH : 0.33, 0, 1),
    s: clamp(Number.isFinite(p?.leafSeasonWetS) ? p.leafSeasonWetS : 0.80, 0, 1),
    l: clamp(Number.isFinite(p?.leafSeasonWetL) ? p.leafSeasonWetL : 0.22, 0, 1),
  };
  return { enabled, strength, dry, wet };
}

function __applyLeafTintToMaterial(mat, seasonValue){
  if (!mat) return;
  const cfg = mat.userData?.__leafTintCfg;
  const opacityScalar = Number.isFinite(mat.userData?.__leafOpacityScalar) ? mat.userData.__leafOpacityScalar : 1.0;

  // Legacy behavior: only brightness scalar.
  if (!cfg || !cfg.enabled || cfg.strength <= 0){
    mat.color.setScalar(opacityScalar);
    return;
  }

  const t = clamp(Number.isFinite(seasonValue) ? seasonValue : 0.5, 0, 1);
  const h = __lerpHue(cfg.dry.h, cfg.wet.h, t);
  const s = __lerp(cfg.dry.s, cfg.wet.s, t);
  const l = __lerp(cfg.dry.l, cfg.wet.l, t);

  const seasonal = new THREE.Color().setHSL(h, s, l);
  const neutral = new THREE.Color(1, 1, 1);

  // Blend so you can keep some of the original PNG coloration if desired.
  const tint = neutral.lerp(seasonal, cfg.strength);
  tint.multiplyScalar(opacityScalar);
  mat.color.copy(tint);
}

// Expose a global hook so the time/season system can update leaf tint live.
globalThis.__updateLeafSeasonTint = function(seasonValue){
  __leafCache.matByKey.forEach((mat)=>{
    if (mat && mat.userData && mat.userData.__leafTintCfg){
      __applyLeafTintToMaterial(mat, seasonValue);
      mat.needsUpdate = true;
    }
  });
};

    
      function __makeDefaultLeafTexture(){
        // Tiny procedural "needle" texture so leaves work out-of-the-box without big base64 strings.
        const c = document.createElement("canvas");
        c.width = 64; c.height = 64;
        const ctx = c.getContext("2d");
        if (!ctx) return null;
    
        ctx.clearRect(0,0,c.width,c.height);
    
        // Needle gradient
        const g = ctx.createLinearGradient(32, 4, 32, 60);
        g.addColorStop(0.0, "rgba(255,255,255,0.00)");
        g.addColorStop(0.10, "rgba(255,255,255,0.90)");
        g.addColorStop(0.60, "rgba(255,255,255,0.95)");
        g.addColorStop(1.0, "rgba(255,255,255,0.00)");
    
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(32, 2);
        ctx.lineTo(38, 62);
        ctx.lineTo(26, 62);
        ctx.closePath();
        ctx.fill();
    
        // A few faint side needles
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        for (let i = 0; i < 5; i++){
          const x = 18 + i * 8;
          ctx.beginPath();
          ctx.moveTo(x, 8);
          ctx.lineTo(x+2, 58);
          ctx.lineTo(x-2, 58);
          ctx.closePath();
          ctx.fill();
        }
    
        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.flipY = false;
        tex.needsUpdate = true;
        return tex;
      }
    
      function __leafStartLoad(url){
        __leafCache.loading.add(url);
        const img = new Image();
        img.onload = ()=>{
          const tex = new THREE.Texture(img);
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.flipY = false;
          tex.needsUpdate = true;
    
          __leafCache.texByURL.set(url, tex);
          __leafCache.loading.delete(url);
    
          const mat = __leafCache.matByKey.get(url);
          if (mat){
            mat.map = tex;
            mat.needsUpdate = true;
          }
        };
        img.onerror = ()=>{
          __leafCache.loading.delete(url);
          __leafCache.texByURL.delete(url);
    
          const mat = __leafCache.matByKey.get(url);
          if (mat){
            mat.map = null;
            mat.needsUpdate = true;
          }
        };
        img.src = url;
      }
    
function __getLeafMaterial(p){
  const opacityScalar = clamp(Number.isFinite(p.leafOpacity) ? p.leafOpacity : 1.0, 0, 1);
  const key = (p.leafPngDataURL && String(p.leafPngDataURL).startsWith("data:image/"))
    ? String(p.leafPngDataURL)
    : "__default";

  let mat = __leafCache.matByKey.get(key);
  if (!mat){
    mat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      // Alpha cutout (no blending) so leaves are NOT subject to transparency sort / z-order quirks.
      transparent: false,
      opacity: 1.0,
      alphaTest: 0.5,
      side: THREE.DoubleSide,
      depthTest: true,
      depthWrite: true,
    });
    mat.userData = mat.userData || {};
    mat.userData.__noDispose = true; // shared across trees
    mat.userData.__outlineGroup = 'leaf'; // used by live material-ID pass (to suppress PNG silhouette outlines)
    __leafCache.matByKey.set(key, mat);
  }

  // Store settings on the cached material so we can retint live when season changes.
  mat.userData.__leafOpacityScalar = opacityScalar;     // used by __applyLeafTintToMaterial(...)
  mat.userData.__leafTintCfg = __getLeafTintConfig(p);  // used by __applyLeafTintToMaterial(...)

  // Use leafOpacity as a brightness control (not translucency), to avoid z-sorting artifacts.
  mat.opacity = 1.0;
  mat.transparent = false;

  const seasonValue = globalThis.__integratedTimeSeasonState?.seasonValue;
  __applyLeafTintToMaterial(mat, seasonValue);

  if (key === "__default"){
    if (!__leafCache.defaultTex) __leafCache.defaultTex = __makeDefaultLeafTexture();
    mat.map = __leafCache.defaultTex;
  } else {
    mat.map = __leafCache.texByURL.get(key) || null;
    if (!__leafCache.texByURL.has(key) && !__leafCache.loading.has(key)){
      __leafStartLoad(key);
    }
  }
  mat.needsUpdate = true;
  return mat;
}

    
      // Debug materials (shared)
      const __branchLineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
      __branchLineMat.userData = __branchLineMat.userData || {};
      __branchLineMat.userData.__noDispose = true;
    
      const __prismWireMat = new THREE.MeshBasicMaterial({ color: 0x39d6d6, wireframe: true, transparent: true, opacity: 0.65 });
      __prismWireMat.userData = __prismWireMat.userData || {};
      __prismWireMat.userData.__noDispose = true;
    
      // ---------------------------
      // Geometry helpers
      // ---------------------------
      function weldGeometry(geom, tolerance = 1e-5){
        const g = geom.clone();
        if (g.getAttribute("normal")) g.deleteAttribute("normal");
        if (g.getAttribute("uv")) g.deleteAttribute("uv");
        const welded = globalThis.mergeVertices(g, tolerance);
        g.dispose();
        return welded;
      }
    
      function ensureOutwardWinding(geom, sampleTris = 200){
        if (!geom || !geom.index || !geom.getAttribute("position")) return { flipped:false, confidence:0 };
    
        if (!geom.boundingSphere) geom.computeBoundingSphere();
        const center = geom.boundingSphere?.center ? geom.boundingSphere.center.clone() : new THREE.Vector3();
    
        const pos = geom.getAttribute("position");
        const idx = geom.index.array;
    
        const a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
        const ab = new THREE.Vector3(), ac = new THREE.Vector3();
        const n = new THREE.Vector3(), centroid = new THREE.Vector3(), outward = new THREE.Vector3();
    
        const triCount = Math.floor(idx.length / 3);
        const take = Math.max(1, Math.min(triCount, Math.floor(sampleTris)));
        const stride = Math.max(1, Math.floor(triCount / take));
    
        let inward = 0;
        let outwardCount = 0;
    
        for (let t = 0, picked = 0; t < triCount && picked < take; t += stride, picked++){
          const i0 = idx[t * 3 + 0], i1 = idx[t * 3 + 1], i2 = idx[t * 3 + 2];
    
          a.fromBufferAttribute(pos, i0);
          b.fromBufferAttribute(pos, i1);
          c.fromBufferAttribute(pos, i2);
    
          ab.copy(b).sub(a);
          ac.copy(c).sub(a);
          n.copy(ab).cross(ac);
    
          const nLen = n.length();
          if (nLen < 1e-10) continue;
          n.multiplyScalar(1 / nLen);
    
          centroid.copy(a).add(b).add(c).multiplyScalar(1 / 3);
          outward.copy(centroid).sub(center);
          if (outward.lengthSq() < 1e-10) continue;
    
          const d = n.dot(outward);
          if (d < 0) inward++;
          else outwardCount++;
        }
    
        const usable = inward + outwardCount;
        const confidence = usable > 0 ? Math.abs(outwardCount - inward) / usable : 0;
    
        if (usable > 12 && inward > outwardCount){
          for (let i = 0; i < idx.length; i += 3){
            const tmp = idx[i + 1];
            idx[i + 1] = idx[i + 2];
            idx[i + 2] = tmp;
          }
          geom.index.needsUpdate = true;
          return { flipped:true, confidence };
        }
    
        return { flipped:false, confidence };
      }
    
      // ---------------------------
      // Stable frames: parallel transport
      // ---------------------------
      function buildSpine({
        seedU32,
        length,
        rings,
        origin,
        direction,
        bend,
        wonk,
        wonkScale,
        gravityDir,
        curl
      }){
        const pts = [];
        const tangents = [];
    
        const dir0 = direction.clone().normalize();
        const g = gravityDir.clone().normalize();
    
        let p = origin.clone();
        let dir = dir0.clone();
    
        // bend axis basis
        const tmp = new THREE.Vector3();
        const right0 = tmp.copy(dir0).cross(new THREE.Vector3(0,1,0));
        if (right0.lengthSq() < 1e-6) right0.set(1,0,0);
        right0.normalize();
        const up0 = new THREE.Vector3().copy(right0).cross(dir0).normalize();
    
        const step = rings > 1 ? (length / (rings - 1)) : 0;
    
        for (let i = 0; i < rings; i++){
          const t = rings <= 1 ? 0 : i / (rings - 1);
    
          const bendAxis = (Math.abs(up0.y) < 0.99 ? up0 : right0).clone().normalize();
          const bendAngle = bend * 1.15 * (t - 0.25);
          dir.applyAxisAngle(bendAxis, bendAngle * 0.02);
    
          if (curl > 0){
            const curlAmt = curl * (0.15 + 0.85 * t);
            dir.lerp(g, curlAmt * 0.08).normalize();
          }
    
          if (i > 0) p = p.clone().addScaledVector(dir, step);
    
          const wn = Math.max(0, wonk);
          const ws = Math.max(0.05, wonkScale);
    
          const ox = (fbm3D(t * ws + 11.1, 0.0, 0.0, seedU32 ^ 0x12345, 4, 2.1, 0.55) - 0.5) * 2.0;
          const oy = (fbm3D(0.0, t * ws + 27.7, 0.0, seedU32 ^ 0x23456, 4, 2.1, 0.55) - 0.5) * 2.0;
          const oz = (fbm3D(0.0, 0.0, t * ws + 39.9, seedU32 ^ 0x34567, 4, 2.1, 0.55) - 0.5) * 2.0;
    
          const amp = wn * 0.18 * (0.35 + 0.65 * length);
          const pp = p.clone().add(new THREE.Vector3(ox, oy, oz).multiplyScalar(amp));
    
          pts.push(pp);
          tangents.push(dir.clone().normalize());
        }
    
        // Parallel transport frames
        const normals = [];
        const binormals = [];
    
        const worldUp = new THREE.Vector3(0,1,0);
        const T0 = tangents[0].clone();
        let N0 = new THREE.Vector3().copy(worldUp).cross(T0);
        if (N0.lengthSq() < 1e-6) N0.set(1,0,0).cross(T0);
        N0.normalize();
        let B0 = new THREE.Vector3().copy(T0).cross(N0).normalize();
    
        normals.push(N0.clone());
        binormals.push(B0.clone());
    
        const axis = new THREE.Vector3();
        for (let i = 1; i < rings; i++){
          const Tprev = tangents[i - 1];
          const Tcur  = tangents[i];
    
          axis.copy(Tprev).cross(Tcur);
          const axisLen = axis.length();
    
          let N = normals[i - 1].clone();
    
          if (axisLen > 1e-6){
            axis.multiplyScalar(1.0 / axisLen);
            const dot = clamp(Tprev.dot(Tcur), -1, 1);
            const angle = Math.acos(dot);
            N.applyAxisAngle(axis, angle);
            N.normalize();
          }
          const B = new THREE.Vector3().copy(Tcur).cross(N).normalize();
    
          normals.push(N);
          binormals.push(B);
        }
    
        return { pts, tangents, normals, binormals };
      }
    
      function buildMeshFromSpine({
        seedU32,
        spine,
        baseRadius,
        taperPerRing,
        radialSegments,
        twist,
        noiseAmt,
        noiseScale,
        noiseOctaves
      }){
        const positions = [];
        const indices = [];
    
        const radial = Math.max(3, Math.floor(radialSegments));
        const rings = spine.pts.length;
    
        const tmp = new THREE.Vector3();
    
        for (let i = 0; i < rings; i++){
          const t = rings <= 1 ? 0 : i / (rings - 1);
          const r = Math.max(1e-6, baseRadius) * Math.pow(clamp(taperPerRing, 0.4, 0.9999), i);
    
          const center = spine.pts[i];
          const N = spine.normals[i];
          const B = spine.binormals[i];
    
          const tw = twist * t * Math.PI * 2.0;
    
          for (let j = 0; j < radial; j++){
            const a = (j / radial) * Math.PI * 2.0 + tw;
    
            let rr = r;
            if (noiseAmt > 0){
              let n = 0;
              const ns = Math.max(0.001, noiseScale);
              const x = center.x * ns;
              const y = center.y * ns;
              const z = center.z * ns;
              for (let o = 0; o < Math.max(1, Math.floor(noiseOctaves)); o++){
                const f = Math.pow(2, o);
                n += (hash3D(x*f + Math.cos(a)*0.13, y*f + Math.sin(a)*0.13, z*f + 0.17, seedU32 ^ (o*1315423911)) - 0.5) * 2.0 / f;
              }
              rr = r * (1.0 + n * noiseAmt * 0.15);
            }
    
            const nx = Math.cos(a);
            const ny = Math.sin(a);
    
            positions.push(
              center.x + N.x * (nx * rr) + B.x * (ny * rr),
              center.y + N.y * (nx * rr) + B.y * (ny * rr),
              center.z + N.z * (nx * rr) + B.z * (ny * rr)
            );
          }
        }
    
        for (let i = 0; i < rings - 1; i++){
          const r0 = i * radial;
          const r1 = (i + 1) * radial;
          for (let j = 0; j < radial; j++){
            const a0 = r0 + j;
            const a1 = r0 + ((j + 1) % radial);
            const b0 = r1 + j;
            const b1 = r1 + ((j + 1) % radial);
            indices.push(a0, b0, a1);
            indices.push(a1, b0, b1);
          }
        }
    
        const geom = new THREE.BufferGeometry();
        geom.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
        geom.setIndex(indices);
        return geom;
      }
    
      function buildWonkyChain(options){
        const rings = Math.max(2, Math.floor(options.ringSegments));
        const spine = buildSpine({
          seedU32: options.seedU32,
          length: options.length,
          rings,
          origin: options.origin,
          direction: options.direction,
          bend: options.bend,
          wonk: options.wonk,
          wonkScale: options.wonkScale ?? 1.35,
          gravityDir: options.gravityDir,
          curl: options.curl
        });
    
        const geom = buildMeshFromSpine({
          seedU32: options.seedU32,
          spine,
          baseRadius: options.baseRadius,
          taperPerRing: options.taperPerRing,
          radialSegments: options.radialSegments,
          twist: options.twist,
          noiseAmt: options.noiseAmt,
          noiseScale: options.noiseScale,
          noiseOctaves: options.noiseOctaves
        });
    
        return { geom, spine };
      }
    
      function mergeBufferGeometries(geoms){
        let totalVerts = 0;
        let totalIdx = 0;
    
        for (const g of geoms){
          const pos = g.getAttribute("position");
          const idx = g.index;
          if (!pos || !idx) continue;
          totalVerts += pos.count;
          totalIdx += idx.count;
        }
    
        const positions = new Float32Array(totalVerts * 3);
        const indices = new (totalVerts > 65535 ? Uint32Array : Uint16Array)(totalIdx);
    
        let vOff = 0;
        let iOff = 0;
    
        for (const g of geoms){
          const pos = g.getAttribute("position");
          const idx = g.index;
          if (!pos || !idx) continue;
    
          positions.set(pos.array, vOff * 3);
    
          const idxArr = idx.array;
          for (let i = 0; i < idxArr.length; i++){
            indices[iOff + i] = idxArr[i] + vOff;
          }
    
          vOff += pos.count;
          iOff += idxArr.length;
        }
    
        const out = new THREE.BufferGeometry();
        out.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        out.setIndex(new THREE.BufferAttribute(indices, 1));
    
        for (const g of geoms) g.dispose();
        return out;
      }
    
      // ---------------------------
      // Branch prism frame (local-space)
      // ---------------------------
      function computePrismLocalFrame(aL, bL, trunkPL){
        const zAxis = bL.clone().sub(aL);
        const dist = zAxis.length();
        if (dist < 1e-6) return null;
        zAxis.multiplyScalar(1 / dist);
    
        const mid = aL.clone().add(bL).multiplyScalar(0.5);
    
        // "Outward" points away from trunk reference (stabilizes roll)
        let outward = mid.clone().sub(trunkPL);
        // Remove any component along z to get a usable x axis
        outward.addScaledVector(zAxis, -outward.dot(zAxis));
    
        let xAxis = outward;
        if (xAxis.lengthSq() < 1e-8){
          // Fallback axis orthogonal to z
          const tmp = (Math.abs(zAxis.y) < 0.95) ? new THREE.Vector3(0,1,0) : new THREE.Vector3(1,0,0);
          xAxis = tmp.clone().cross(zAxis);
        }
        xAxis.normalize();
    
        const yAxis = new THREE.Vector3().copy(zAxis).cross(xAxis).normalize();
    
        const m = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
        const quat = new THREE.Quaternion().setFromRotationMatrix(m);
    
        return { mid, quat, dist };
      }
    
      function makeTreeGroupFromPreset(preset, seedStr, scale){
        const p = preset || DEFAULT_TREE_PRESET_V2;
        const s = Math.max(1e-6, scale ?? 1);
        const seedU32 = xmur3(seedStr)();
        const rand = makeRng(seedStr + "::rand");
    
        const group = new THREE.Group();
        group.name = "tree";
    
        /** @type {Array<{a:THREE.Vector3,b:THREE.Vector3}>} */
        const branchSegmentsLocal = []; // used for leaf placement + debug prisms
    
        // Trunk (up)
        const trunkOrigin = new THREE.Vector3(0, 0, 0);
        const trunkDir = new THREE.Vector3(0, 1, 0);
    
        const trunk = buildWonkyChain({
          seedU32: seedU32 ^ 0xA11CE,
          length: Math.max(0.01, p.trunkLength) * s,
          baseRadius: Math.max(0.001, p.trunkRadius) * s,
          taperPerRing: clamp(p.trunkTaper, 0.45, 0.9995),
          ringSegments: Math.max(2, Math.floor(p.ringSegments)),
          radialSegments: Math.max(3, Math.floor(p.radialSegments)),
          bend: clamp(p.trunkBend, 0, 2),
          wonk: clamp(p.trunkWonk, 0, 2),
          wonkScale: Math.max(0.05, p.trunkWonkScale),
          twist: clamp(p.trunkTwist, 0, 2),
          noiseAmt: clamp(p.trunkNoise, 0, 2),
          noiseScale: Math.max(0.05, p.trunkNoiseScale),
          noiseOctaves: Math.max(1, Math.floor(p.trunkNoiseOctaves)),
          origin: trunkOrigin,
          direction: trunkDir,
          gravityDir: new THREE.Vector3(0, -1, 0),
          curl: 0
        });
    
        const geoms = [trunk.geom];
    
        // Roots (down)
        if (p.rootsEnabled){
          const count = Math.max(0, Math.floor(p.rootCount));
          for (let i = 0; i < count; i++){
            const ang = (i / Math.max(1, count)) * Math.PI * 2.0 + (rand() - 0.5) * 0.35;
            const spread = p.rootSpread * (0.55 + 0.65 * rand());
    
            const dir = new THREE.Vector3(Math.cos(ang), -0.55, Math.sin(ang)).normalize();
            dir.x *= (1.0 + spread);
            dir.z *= (1.0 + spread);
            dir.normalize();
    
            const rootOrigin = trunkOrigin.clone().add(new THREE.Vector3((rand()-0.5)*0.05*s, (rand()-0.5)*0.04*s, (rand()-0.5)*0.05*s));
    
            const root = buildWonkyChain({
              seedU32: seedU32 ^ (0xBADC0DE + i * 997),
              length: Math.max(0.01, p.rootLength) * s * (0.65 + 0.65 * rand()),
              baseRadius: Math.max(0.001, p.rootRadius) * s * (0.70 + 0.50 * rand()),
              taperPerRing: clamp(p.rootTaper, 0.45, 0.999),
              ringSegments: Math.max(3, Math.floor(p.ringSegments * 0.70)),
              radialSegments: Math.max(3, Math.floor(p.radialSegments * 0.85)),
              bend: clamp(p.trunkBend * 0.25, 0, 2),
              wonk: clamp(p.rootWonk, 0, 2),
              wonkScale: Math.max(0.05, p.trunkWonkScale),
              twist: clamp(p.trunkTwist * 0.6, 0, 2),
              noiseAmt: clamp(p.trunkNoise * 0.85, 0, 2),
              noiseScale: Math.max(0.05, p.trunkNoiseScale * 1.15),
              noiseOctaves: Math.max(1, Math.floor(p.trunkNoiseOctaves)),
              origin: rootOrigin,
              direction: dir,
              gravityDir: new THREE.Vector3(0, -1, 0),
              curl: clamp(p.rootCurl, 0, 2)
            });
    
            geoms.push(root.geom);
          }
        }
    
        // Knot / Branch tiers
        if (p.knotEnabled){
          const trunkPts = trunk.spine.pts;
          const trunkTans = trunk.spine.tangents;
    
          const tiers = Math.max(1, Math.min(8, Math.floor(p.knotTiers)));
          const spacing = clamp(p.knotTierSpacing, 0.0, 0.5);
    
          const rawDelta = clamp(p.knotTierSizeDelta, -0.75, 0.75);
          const tierFactor = clamp(1.0 + rawDelta, 0.15, 3.0);
    
          const center = clamp01(p.knotAt);
          const mid = (tiers - 1) * 0.5;
    
          const worldUp = new THREE.Vector3(0,1,0);
          const worldDown = new THREE.Vector3(0,-1,0);
    
          const bias = clamp(p.knotUpDownBias, -1, 1);
          const biasVec = (bias >= 0) ? worldUp : worldDown;
          const biasAmt = Math.abs(bias);
    
          for (let tier = 0; tier < tiers; tier++){
            const tierAt = clamp01(center + (tier - mid) * spacing);
            const idx = Math.max(0, Math.min(trunkPts.length - 1, Math.round(tierAt * (trunkPts.length - 1))));
            const anchor = trunkPts[idx].clone();
            const tan = trunkTans[idx].clone().normalize();
    
            let right = new THREE.Vector3().copy(tan).cross(worldUp);
            if (right.lengthSq() < 1e-6) right.set(1,0,0);
            right.normalize();
            let up = new THREE.Vector3().copy(right).cross(tan).normalize();
    
            const tierScale = Math.pow(tierFactor, tier);
    
            const count = Math.max(0, Math.floor(p.knotCount));
            for (let i = 0; i < count; i++){
              const a = (i / Math.max(1, count)) * Math.PI * 2.0 + (rand() - 0.5) * 0.4;
              const spread = p.knotSpread * (0.6 + 0.6 * rand());
    
              const outward = new THREE.Vector3()
                .addScaledVector(right, Math.cos(a))
                .addScaledVector(up, Math.sin(a))
                .normalize();
    
              const dir = new THREE.Vector3()
                .addScaledVector(outward, 1.0)
                .addScaledVector(biasVec, biasAmt * 1.35)
                .addScaledVector(tan, 0.15)
                .normalize();
    
              dir.add(new THREE.Vector3((rand()-0.5)*0.12, (rand()-0.5)*0.10, (rand()-0.5)*0.12)).normalize();
    
              const origin = anchor.clone().addScaledVector(outward, (rand()-0.5) * 0.08 * s);
    
              const knot = buildWonkyChain({
                seedU32: seedU32 ^ (0xC0FFEE + tier * 1009 + i * 271),
                length: Math.max(0.01, p.knotLength) * s * tierScale * (0.75 + 0.55 * rand()),
                baseRadius: Math.max(0.001, p.knotRadius) * s * tierScale * (0.75 + 0.5 * rand()),
                taperPerRing: clamp(p.knotTaper, 0.4, 0.999),
                ringSegments: Math.max(4, Math.floor(p.ringSegments * 0.75)),
                radialSegments: Math.max(3, Math.floor(p.radialSegments)),
                bend: clamp(p.trunkBend * 0.25, 0, 2),
                wonk: clamp(p.knotWonk, 0, 2),
                wonkScale: Math.max(0.05, p.trunkWonkScale * 1.25),
                twist: clamp(p.trunkTwist * 0.7, 0, 2),
                noiseAmt: clamp(p.trunkNoise * 0.9, 0, 2),
                noiseScale: Math.max(0.05, p.trunkNoiseScale * 1.15),
                noiseOctaves: Math.max(1, Math.floor(p.trunkNoiseOctaves)),
                origin,
                direction: dir,
                gravityDir: biasVec,
                curl: clamp(p.knotCurl, 0, 2)
              });
    
              geoms.push(knot.geom);
    
              // Capture a branch segment for leaves (base=origin, tip=last spine point)
              const tip = knot.spine.pts[knot.spine.pts.length - 1].clone();
              branchSegmentsLocal.push({ a: origin.clone(), b: tip });
            }
          }
        }
    
        const merged = mergeBufferGeometries(geoms);
    
        let geom = merged;
        if (p.weldVertices){
          const tol = clamp(p.weldTolerance, 1e-7, 1e-3);
          geom = weldGeometry(merged, tol);
          merged.dispose();
        }
    
        const winding = ensureOutwardWinding(geom, 260);
        geom.computeVertexNormals();
    
        if (p.flatShading){
          const non = geom.toNonIndexed();
          geom.dispose();
          geom = non;
          geom.computeVertexNormals();
        }
    
        // Bark material: prefer shared two-tone toon bark, fallback to standard material.
        // - globalThis.__matBarkShaderBrown is defined near the terrain materials (after StylizedTerrainShader init).
        let mat = null;
        if (p.wireframe){
          mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
        } else if (globalThis.__matBarkShaderBrown){
          mat = globalThis.__matBarkShaderBrown;
        } else {
          mat = new THREE.MeshStandardMaterial({
            color: p.barkColor ?? 0x4a3b33,
            roughness: 1.0,
            metalness: 0.0,
            flatShading: !!p.flatShading,
            wireframe: !!p.wireframe,
            side: THREE.DoubleSide
          });
        }
    
        mat.userData = mat.userData || {};
        mat.userData.__outlineGroup = 'wood'; // used by live material-ID pass (wood‚ÜîPNG intersections)

        const mesh = new THREE.Mesh(geom, mat);
        mesh.name = "tree_mesh";
        mesh.userData.__winding = winding; // used by HUD/debug if needed
        group.add(mesh);
    
        // Stage 2/3: Branch prisms + leaves (optional)
        if ((p.debugBranchLines || p.debugPrisms || p.leavesEnabled) && branchSegmentsLocal.length){
          const prismStageGroup = new THREE.Group();
          prismStageGroup.name = "tree_branch_prisms";
          group.add(prismStageGroup);
    
          const branchDebugGroup = new THREE.Group();
          branchDebugGroup.name = "tree_branch_debug";
          group.add(branchDebugGroup);
    
          // Choose a trunk reference point behind the first branch base to stabilize roll.
          const branchBaseL = branchSegmentsLocal[0].a.clone();
          const trunkPtsL = trunk.spine.pts;
          const trunkTansL = trunk.spine.tangents;
    
          let nearestIdx = 0;
          let bestD2 = Infinity;
          for (let ti = 0; ti < trunkPtsL.length; ti++){
            const d2 = trunkPtsL[ti].distanceToSquared(branchBaseL);
            if (d2 < bestD2){ bestD2 = d2; nearestIdx = ti; }
          }
          const trunkDirL = trunkTansL[nearestIdx].clone().normalize();
          const biasDist = Math.max(0, Number.isFinite(p.trunkRollBiasDist) ? p.trunkRollBiasDist : 0.30) * s;
          const trunkPL = branchBaseL.clone().addScaledVector(trunkDirL, -biasDist);
    
          const leafMat = p.leavesEnabled ? __getLeafMaterial(p) : null;
    
          for (let i = 0; i < branchSegmentsLocal.length; i++){
            const seg = branchSegmentsLocal[i];
            const frame = computePrismLocalFrame(seg.a, seg.b, trunkPL);
            if (!frame) continue;
    
            if (p.debugBranchLines){
              const lineGeomLocal = new THREE.BufferGeometry().setFromPoints([seg.a.clone(), seg.b.clone()]);
              const line = new THREE.Line(lineGeomLocal, __branchLineMat);
              line.name = `branch_line_${i}`;
              branchDebugGroup.add(line);
            }
    
            const prismRoot = new THREE.Object3D();
            prismRoot.name = `branch_prism_${i}`;
            prismRoot.position.copy(frame.mid);
            prismRoot.quaternion.copy(frame.quat);
    
            if (p.debugPrisms){
              const box = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), __prismWireMat);
              box.name = "prism_box";
              box.scale.set(
                Math.max(1e-4, (Number.isFinite(p.prismWidth) ? p.prismWidth : 0.08) * s),
                Math.max(1e-4, (Number.isFinite(p.prismDepth) ? p.prismDepth : 0.08) * s),
                Math.max(1e-4, frame.dist)
              );
              prismRoot.add(box);
    
              if (p.debugPrismAxes){
                const axes = new THREE.AxesHelper(0.25 * s);
                axes.name = "prism_axes";
                prismRoot.add(axes);
              }
            }
    
            // Leaves (symmetric layout inside the prism frame)
            if (p.leavesEnabled && leafMat){
              const count = Math.max(0, Math.floor(p.leavesPerBranch));
              const distL = Math.max(1e-4, frame.dist);
    
              // Prism is centered at mid. With our prism frame:
              // Z = along branch, so endpoints are at z=-dist/2 and z=+dist/2.
              const zBase = lerp(-distL * 0.5, distL * 0.5, clamp01(p.leafAlong01));
    
              for (let k = 0; k < count; k++){
                const leaf = new THREE.Mesh(__leafPlaneGeom, leafMat);
                leaf.name = `leaf_${i}_${k}`;

    
                leaf.scale.set(
                  Math.max(1e-4, (Number.isFinite(p.leafWidth) ? p.leafWidth : 0.18) * s),
                  Math.max(1e-4, (Number.isFinite(p.leafLength) ? p.leafLength : 0.55) * s),
                  1
                );
    
                leaf.position.set(0, 0, zBase);
    
                let sideIndex = 0;
                if (k > 0){
                  const step = Math.ceil(k / 2);
                  sideIndex = (k % 2 === 1) ? -step : +step;
                }
    
                const radial = (Number.isFinite(p.leafRadial) ? p.leafRadial : 0.18) * s;
                leaf.position.x = sideIndex * radial;
    
                const spread = Number.isFinite(p.leafSpread) ? p.leafSpread : 1.0;
                if (k > 0){
                  leaf.position.z += (rand() - 0.5) * (Number.isFinite(p.leafJitterAlong) ? p.leafJitterAlong : 0.12) * s;
                  leaf.position.x += (rand() - 0.5) * (Number.isFinite(p.leafJitterSide) ? p.leafJitterSide : 0.05) * s * spread;
                  leaf.position.y += (rand() - 0.5) * (Number.isFinite(p.leafJitterNormal) ? p.leafJitterNormal : 0.08) * s * spread;
                }
    
                // Manual prism-local translation (helps compensate for off-center PNG art)
                leaf.position.x += (Number.isFinite(p.leafOffsetX) ? p.leafOffsetX : 0) * s;
                leaf.position.y += (Number.isFinite(p.leafOffsetY) ? p.leafOffsetY : 0) * s;
                leaf.position.z += (Number.isFinite(p.leafOffsetZ) ? p.leafOffsetZ : 0) * s;
    
                const yaw   = (k === 0) ? 0 : (rand() * 2 - 1) * THREE.MathUtils.degToRad(Number.isFinite(p.leafRandYawDeg) ? p.leafRandYawDeg : 35);
                const pitch = (rand() * 2 - 1) * THREE.MathUtils.degToRad(Number.isFinite(p.leafRandPitchDeg) ? p.leafRandPitchDeg : 20);
                const roll  = (rand() * 2 - 1) * THREE.MathUtils.degToRad(Number.isFinite(p.leafRandRollDeg) ? p.leafRandRollDeg : 25);
    
                const bottomFlip = p.leafBottomFacesTrunk ? Math.PI * 0.5 : 0;
    
                leaf.rotation.set(
                  THREE.MathUtils.degToRad(Number.isFinite(p.leafPitchDeg) ? p.leafPitchDeg : 0) + pitch,
                  THREE.MathUtils.degToRad(Number.isFinite(p.leafYawDeg) ? p.leafYawDeg : 0) + yaw,
                  THREE.MathUtils.degToRad(Number.isFinite(p.leafRollDeg) ? p.leafRollDeg : 0) + roll + bottomFlip,
                  "XYZ"
                );
    
                prismRoot.add(leaf);
              }
            }
    
            prismStageGroup.add(prismRoot);
          }
        }
    
        group.userData.__treePresetName = p.name || "";
        return group;
      }
    
      Generators.register("tree", {
        kind: "object3d",
        defaults: DEFAULT_TREE_PRESET_V2,
        make: (params, seedStr, scale)=>makeTreeGroupFromPreset(params, seedStr, scale)
      });
    })();


    const app = document.getElementById("sceneRoot");
    function __getViewSize(){
      const r = app.getBoundingClientRect();
      return { w: Math.max(1, Math.floor(r.width)), h: Math.max(1, Math.floor(r.height)) };
    }
    let __vw = 1, __vh = 1;
    function __updateViewSize(){ const s = __getViewSize(); __vw = s.w; __vh = s.h; return s; }
    __updateViewSize();
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
    renderer.setSize(__vw, __vh, false);
      if (typeof globalThis.StylizedTerrainShader !== "undefined"){
        globalThis.StylizedTerrainShader.setSharedFromRendererSize(__vw, __vh);
      }
    app.appendChild(renderer.domElement);
    globalThis.renderer = renderer; // Make renderer globally accessible for day/night cycle

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xbfd7ff); // Match hemisphere sky color
    globalThis.__sceneBackground = scene.background; // Make it updatable
    // Initialize fog for atmospheric depth (will be updated by day/night cycle)
    scene.fog = new THREE.FogExp2(0xbfd7ff, 0.003);
    globalThis.scene = scene; // Make scene globally accessible for day/night cycle
    
    const camera = new THREE.PerspectiveCamera(55, __vw/__vh, 0.1, 5000);
    camera.position.set(40, 45, 55);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    globalThis.__hhCamera = camera;
    globalThis.__hhControls = controls;

    // ===== 3D COMPASS OVERLAY (corner) =====
    // Draws a tiny world-axis compass in the top-right so you can tell which way is +X/+Y/+Z.
    // Convention in this app:
    //   - Up = +Y
    //   - East = +X
    //   - North = +Z  (matches your ‚Äú+Y in .vox becomes +Z here‚Äù mental model)
    function __makeTextSprite(text){
      const c = document.createElement('canvas');
      c.width = 128; c.height = 128;
      const ctx = c.getContext('2d');
      ctx.clearRect(0,0,c.width,c.height);
      ctx.font = 'bold 56px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.strokeStyle = 'rgba(0,0,0,0.65)';
      ctx.lineWidth = 10;
      ctx.strokeText(text, c.width/2, c.height/2);
      ctx.fillText(text, c.width/2, c.height/2);
      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, depthWrite: false });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(0.6, 0.6, 0.6);
      spr.renderOrder = 10000;
      return spr;
    }

    function __setupCompassOverlay(){
      const compass = {
        size: 128, // pixels
        pad: 10,   // pixels
        scene: new THREE.Scene(),
        camera: new THREE.OrthographicCamera(-1.6, 1.6, 1.6, -1.6, 0.1, 10),
        root: new THREE.Group(),
        enabled: true
      };
      compass.camera.position.set(0, 0, 4);
      compass.camera.lookAt(0, 0, 0);

      // Axes
      const ax = new THREE.AxesHelper(1.25);
      compass.root.add(ax);

      // Cardinal labels (world directions)
      const lblN = __makeTextSprite('N');
      const lblS = __makeTextSprite('S');
      const lblE = __makeTextSprite('E');
      const lblW = __makeTextSprite('W');
      const lblU = __makeTextSprite('U');
      lblN.position.set(0, 0, 1.45);   // +Z
      lblS.position.set(0, 0, -1.45);  // -Z
      lblE.position.set(1.45, 0, 0);   // +X
      lblW.position.set(-1.45, 0, 0);  // -X
      lblU.position.set(0, 1.45, 0);   // +Y
      compass.root.add(lblN, lblS, lblE, lblW, lblU);

      compass.scene.add(compass.root);
      globalThis.__compass3d = compass;
      (globalThis.__uiLog ? globalThis.__uiLog('Compass: N=+Z, E=+X, U=+Y (voxel +Y depth maps to +Z here)') : console.log('Compass overlay ready'));
      return compass;
    }

    __setupCompassOverlay();

    function __renderCompassOverlay(){
      const c = globalThis.__compass3d;
      if (!c || !c.enabled) return;
      // Orient axes opposite the camera, so the compass shows world directions from the viewer‚Äôs perspective.
      try{
        c.root.quaternion.copy(camera.quaternion).invert();
      }catch(e){}

      // Render into a corner viewport using the SAME renderer.
      const prevAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      const prevScissorTest = renderer.getScissorTest ? renderer.getScissorTest() : false;
      renderer.setScissorTest(true);
      const size = c.size;
      const pad = c.pad;
      const x0 = Math.max(0, __vw - size - pad);
      const y0 = Math.max(0, __vh - size - pad);
      renderer.setViewport(x0, y0, size, size);
      renderer.setScissor(x0, y0, size, size);
      renderer.clearDepth();
      renderer.render(c.scene, c.camera);
      // Restore full viewport
      renderer.setViewport(0, 0, __vw, __vh);
      renderer.setScissorTest(!!prevScissorTest);
      renderer.autoClear = prevAutoClear;
    }
    
    // ===== DEPTH-BASED OUTLINE SYSTEM =====
    // This system uses post-processing to detect depth discontinuities for outlines
    
    // Import EffectComposer and passes
    import('three/addons/postprocessing/EffectComposer.js').then(module => {
      const EffectComposer = module.EffectComposer;
      
      return Promise.all([
        import('three/addons/postprocessing/RenderPass.js'),
        import('three/addons/postprocessing/ShaderPass.js')
      ]).then(([renderPassModule, shaderPassModule]) => {
        const RenderPass = renderPassModule.RenderPass;
        const ShaderPass = shaderPassModule.ShaderPass;
          
          // Custom depth-based outline shader - IMPROVED VERSION
          const DepthOutlineShader = {
            uniforms: {
              'tDiffuse': { value: null },
              'tDepth': { value: null },
              'cameraNear': { value: camera.near },
              'cameraFar': { value: camera.far },
              'resolution': { value: new THREE.Vector2(__vw, __vh) },
              'outlineThickness': { value: 20.0 },
              'depthSensitivity': { value: 1 },
              'outlineColor': { value: new THREE.Color(0x000000) },
              'distanceShrinkFactor': { value: 100.0 },
              'tWaterMask': { value: null },
              'waterEdgeEnabled': { value: 1.0 },
              'waterEdgeThickness': { value: 4.0 },
              'waterEdgeStrength': { value: 1.0 },
              'tMaterialID': { value: null },
              'leafIdColor': { value: (window.__OUTLINE_ID_LEAF_COLOR || new THREE.Color(0xff00ff)) },
              'woodIdColor': { value: (window.__OUTLINE_ID_WOOD_COLOR || new THREE.Color(0x00ffff)) },
              'materialEdgeEnabled': { value: 1.0 },
              'materialEdgeThickness': { value: 5.0 },
              'materialEdgeStrength': { value: 1.0 }
            },
            
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            
            fragmentShader: `
              uniform sampler2D tDiffuse;
              uniform sampler2D tDepth;
              uniform float cameraNear;
              uniform float cameraFar;
              uniform vec2 resolution;
              uniform float outlineThickness;
              uniform float depthSensitivity;
              uniform vec3 outlineColor;
              uniform float distanceShrinkFactor;
              uniform sampler2D tWaterMask;
              uniform float waterEdgeEnabled;
              uniform float waterEdgeThickness;
              uniform float waterEdgeStrength;
              uniform sampler2D tMaterialID;
              uniform vec3 leafIdColor;
              uniform vec3 woodIdColor;
              uniform float materialEdgeEnabled;
              uniform float materialEdgeThickness;
              uniform float materialEdgeStrength;
              
              varying vec2 vUv;
              
              // Linearize depth (0 = near, 1 = far)
              float getLinearDepth(vec2 uv) {
                float depth = texture2D(tDepth, uv).x;
                float z = depth * 2.0 - 1.0; // Back to NDC
                return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - z * (cameraFar - cameraNear));
              }
              
              // Simple depth edge detection using centered differences
              float detectDepthEdge(vec2 uv, vec2 texelSize, float centerDepth) {
                // Sample neighbors
                float depthN = getLinearDepth(uv + vec2(0.0, texelSize.y));
                float depthS = getLinearDepth(uv - vec2(0.0, texelSize.y));
                float depthE = getLinearDepth(uv + vec2(texelSize.x, 0.0));
                float depthW = getLinearDepth(uv - vec2(texelSize.x, 0.0));
                
                // Compute gradients
                float dx = abs(depthE - depthW);
                float dy = abs(depthN - depthS);
                float gradient = max(dx, dy);
                
                // Adaptive threshold based on distance (closer = smaller threshold needed)
                float depthRange = cameraFar - cameraNear;
                float normalizedDepth = (centerDepth - cameraNear) / depthRange;
                
                // Scale threshold: more sensitive at close range, less at far range
                float adaptiveThreshold = depthSensitivity * (1.0 + normalizedDepth * 3.0);
                
                return smoothstep(adaptiveThreshold, adaptiveThreshold * 1.5, gradient);
              }


              float sampleWaterMask(vec2 uv){
                return texture2D(tWaterMask, uv).r;
              }

              // Edge where water meets non-water (screen-space)
              float detectWaterBoundary(vec2 uv, vec2 texel){
                float c = sampleWaterMask(uv);
                float n = sampleWaterMask(uv + vec2(0.0, texel.y));
                float s = sampleWaterMask(uv - vec2(0.0, texel.y));
                float e = sampleWaterMask(uv + vec2(texel.x, 0.0));
                float w = sampleWaterMask(uv - vec2(texel.x, 0.0));
                float d = max(max(abs(c-n), abs(c-s)), max(abs(c-e), abs(c-w)));
                // tighten: only draw where either side is water
                float anyWater = clamp(c + n + s + e + w, 0.0, 1.0);
                return d * anyWater;
              }

              // Material ID boundary detection - detects where different materials meet
              float detectMaterialBoundary(vec2 uv, vec2 texel){
  vec3 c = texture2D(tMaterialID, uv).rgb;
  vec3 n = texture2D(tMaterialID, uv + vec2(0.0, texel.y)).rgb;
  vec3 s = texture2D(tMaterialID, uv - vec2(0.0, texel.y)).rgb;
  vec3 e = texture2D(tMaterialID, uv + vec2(texel.x, 0.0)).rgb;
  vec3 w = texture2D(tMaterialID, uv - vec2(texel.x, 0.0)).rgb;

  // Special-case PNG/leaf cards:
  // - Never draw outline ON the card itself (the art already contains outlines).
  // - Only draw an outline on WOOD pixels that touch a PNG/leaf pixel (wood‚ÜîPNG intersection).
  float leafEps = 0.02;
  float woodEps = 0.02;

  bool cIsLeaf = (distance(c, leafIdColor) < leafEps);
  if (cIsLeaf) return 0.0;

  bool cIsWood = (distance(c, woodIdColor) < woodEps);

  bool nIsLeaf = (distance(n, leafIdColor) < leafEps);
  bool sIsLeaf = (distance(s, leafIdColor) < leafEps);
  bool eIsLeaf = (distance(e, leafIdColor) < leafEps);
  bool wIsLeaf = (distance(w, leafIdColor) < leafEps);

  bool touchesLeaf = (nIsLeaf || sIsLeaf || eIsLeaf || wIsLeaf);
  if (touchesLeaf){
    // Draw ONLY on wood side, and only when the wood pixel borders the PNG/leaf card.
    if (!cIsWood) return 0.0;
    return 1.0;
  }

  // Default material boundary detection (symmetric) for non-leaf materials.
  float dn = length(c - n);
  float ds = length(c - s);
  float de = length(c - e);
  float dw = length(c - w);

  float maxDiff = max(max(dn, ds), max(de, dw));

  // Threshold to determine if materials are different
  return smoothstep(0.01, 0.05, maxDiff);
}

              void main() {
                float centerDepth = getLinearDepth(vUv);
                
                // **KEY FIX**: Scale outline thickness based on distance
                // Far away objects get thinner outlines, close objects get thicker
                // distanceShrinkFactor controls how aggressively outlines shrink with distance
                float depthRange = cameraFar - cameraNear;
                float normalizedDepth = (centerDepth - cameraNear) / depthRange;
                float distanceScale = 1.0 / (1.0 + normalizedDepth * distanceShrinkFactor);
                
                vec2 texelSize = (outlineThickness * distanceScale) / resolution;
                
                // Detect depth edge
                float edge = detectDepthEdge(vUv, texelSize, centerDepth);
                
                // Water boundary outlines (shoreline / intersections)
                float waterEdge = 0.0;
                if (waterEdgeEnabled > 0.5) {
                  vec2 wTexel = (waterEdgeThickness * distanceScale) / resolution;
                  waterEdge = detectWaterBoundary(vUv, wTexel) * waterEdgeStrength;
                }
                edge = max(edge, waterEdge);
                
                // Material boundary outlines (where different materials meet)
                float materialEdge = 0.0;
                if (materialEdgeEnabled > 0.5) {
                  vec2 mTexel = (materialEdgeThickness * distanceScale) / resolution;
                  materialEdge = detectMaterialBoundary(vUv, mTexel) * materialEdgeStrength;
                }
                edge = max(edge, materialEdge);
                
                // Get the original color
                vec4 color = texture2D(tDiffuse, vUv);
                
                // Mix outline color where edges are detected
                gl_FragColor = mix(color, vec4(outlineColor, 1.0), edge);
              }
            `
          };
          
          // Create render target with depth texture FIRST.
          // NOTE: EffectComposer internally swaps between two buffers. If only ONE has a depth texture,
          // the outline pass can flicker every other frame on some devices/drivers.
          const isWebGL2 = !!renderer?.capabilities?.isWebGL2;
          let lowPrecisionDepth = !isWebGL2;

          const depthTexture = new THREE.DepthTexture(__vw, __vh);
          depthTexture.format = THREE.DepthFormat;
          depthTexture.type = THREE.UnsignedIntType;

          // Second depth texture for the composer's second buffer (prevents every-other-frame depth mismatch flicker).
          const depthTexture2 = new THREE.DepthTexture(__vw, __vh);
          depthTexture2.format = THREE.DepthFormat;
          depthTexture2.type = THREE.UnsignedIntType;

          const makeRT = (dt) => new THREE.WebGLRenderTarget(
            __vw,
            __vh,
            {
              minFilter: THREE.NearestFilter,
              magFilter: THREE.NearestFilter,
              format: THREE.RGBAFormat,
              type: THREE.UnsignedByteType,
              depthTexture: dt,
              depthBuffer: true,
              stencilBuffer: false
            }
          );

          let renderTarget;
          try{
            renderTarget = makeRT(depthTexture);
          }catch(e){
            // Fallback to UNSIGNED_SHORT depth textures (common on some WebGL1/mobile stacks).
            lowPrecisionDepth = true;
            depthTexture.type = THREE.UnsignedShortType;
            depthTexture2.type = THREE.UnsignedShortType;
            renderTarget = makeRT(depthTexture);
            (globalThis.__uiLog ? globalThis.__uiLog(String('Outline: fell back to UNSIGNED_SHORT depth texture (driver limitation).')) : console.warn('Outline: fell back to UNSIGNED_SHORT depth texture (driver limitation).'));
          }

          // Water mask render target (for shoreline/intersection outlines)
          const waterMaskTarget = new THREE.WebGLRenderTarget(
            __vw,
            __vh,
            {
              minFilter: THREE.NearestFilter,
              magFilter: THREE.NearestFilter,
              format: THREE.RGBAFormat,
              type: THREE.UnsignedByteType,
              depthBuffer: true,
              stencilBuffer: false
            }
          );
          const waterMaskMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
          window.waterMaskTarget = waterMaskTarget;
          window.waterMaskMaterial = waterMaskMaterial;

          // Black mask material is used to write depth for non-water geometry so shoreline/edges respect occlusion.
          const waterMaskMaterialBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });
          window.waterMaskMaterialBlack = waterMaskMaterialBlack;
          waterMaskMaterialBlack.colorWrite = false; // depth-only prepass; keep mask black

          // Material ID render target (for material boundary outlines)
          const materialIDTarget = new THREE.WebGLRenderTarget(
            __vw,
            __vh,
            {
              minFilter: THREE.NearestFilter,
              magFilter: THREE.NearestFilter,
              format: THREE.RGBAFormat,
              type: THREE.UnsignedByteType,
              depthBuffer: true,
              stencilBuffer: false
            }
          );
          window.materialIDTarget = materialIDTarget;
          
          // Material ID mapping: assign unique colors to different material types
          window.materialIDMap = new Map();
          window.materialIDColors = [];
          
          
          // Cache original-material -> ID override material to avoid reallocating every frame.
          window.materialIDOverrideCache = new Map();
          // Special ID colors (used to suppress PNG plane silhouettes while still outlining wood‚ÜîPNG intersections).
          // These are fed into the outline shader and also used during the ID-pass override material selection.
          window.__OUTLINE_ID_LEAF_COLOR = new THREE.Color(0xff00ff); // magenta = PNG/leaf cards
          window.__OUTLINE_ID_WOOD_COLOR = new THREE.Color(0x00ffff); // cyan = trunk/branch "wood"

// Helper function to assign material IDs
          window.assignMaterialID = function(material) {
            if (!material) return;
            if (window.materialIDMap.has(material)) return window.materialIDMap.get(material);
            
            const id = window.materialIDColors.length;
            // Create a unique color for this material ID
            // Using distinctive colors in RGB space for better edge detection
            const color = new THREE.Color();
            // Generate a color based on ID (using a hash-like distribution)
            const hue = (id * 0.618033988749895) % 1.0; // Golden ratio for even distribution
            color.setHSL(hue, 1.0, 0.5);
            
            window.materialIDColors.push(color);
            window.materialIDMap.set(material, id);
            
            return id;
          };

          
          // Create composer
          const composer = new EffectComposer(renderer, renderTarget);


          // Ensure BOTH internal buffers have depth textures; otherwise outlines can flicker every other frame.
          if (composer?.renderTarget2 && depthTexture2){
            composer.renderTarget2.depthTexture = depthTexture2;
            composer.renderTarget2.depthBuffer = true;
            composer.renderTarget2.stencilBuffer = false;
          }
          
          // First pass: render the scene
          const renderPass = new RenderPass(scene, camera);
          composer.addPass(renderPass);
          
          // Second pass: depth-based outlines
          const outlinePass = new ShaderPass(DepthOutlineShader);
          outlinePass.uniforms['tDepth'].value = depthTexture;
          if (outlinePass.uniforms['tWaterMask']) outlinePass.uniforms['tWaterMask'].value = waterMaskTarget.texture;
          if (outlinePass.uniforms['tMaterialID']) outlinePass.uniforms['tMaterialID'].value = materialIDTarget.texture;
          if (outlinePass.uniforms['leafIdColor']) outlinePass.uniforms['leafIdColor'].value = (window.__OUTLINE_ID_LEAF_COLOR || new THREE.Color(0xff00ff));
          if (outlinePass.uniforms['woodIdColor']) outlinePass.uniforms['woodIdColor'].value = (window.__OUTLINE_ID_WOOD_COLOR || new THREE.Color(0x00ffff));
          composer.addPass(outlinePass);

          if (lowPrecisionDepth){
            (globalThis.__uiLog ? globalThis.__uiLog(String('Outline: low-precision depth detected (likely WebGL1). If you see contour banding, raise Depth sensitivity or lower Thickness.')) : console.warn('Outline: low-precision depth detected (likely WebGL1).'));
          }
          
          // Make globally accessible
          window.composer = composer;
          window.depthOutlinePass = outlinePass;
          window.depthRenderTarget = renderTarget;
          window.__depthTexture2 = depthTexture2;
          window.__waterMaskEnabled = true;
          
          (globalThis.__uiLog ? globalThis.__uiLog(String('‚úì Depth-based outline system initialized')) : console.log('‚úì Depth-based outline system initialized'));
          (globalThis.__uiLog ? globalThis.__uiLog(String('  Depth texture format:', depthTexture.format, depthTexture.type)) : console.log('  Depth texture format:', depthTexture.format, depthTexture.type));
          (globalThis.__uiLog ? globalThis.__uiLog(String('  Render target size:', renderTarget.width, 'x', renderTarget.height)) : console.log('  Render target size:', renderTarget.width, 'x', renderTarget.height));
        });
      });

    scene.add(new THREE.AmbientLight(0xffffff, 0.65));
    // Sky light (hemisphere) to lift shadows and help stylized shader read
    const hemi = new THREE.HemisphereLight(0xcfe8ff, 0x2b2b2b, 0.55);
    globalThis.__hemiLight = hemi;
    scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 1.45);
    globalThis.__sunLight = sun;
    sun.position.set(80, -120, 40);
    scene.add(sun);
    scene.add(sun.target);

    // Sun debug gizmo: shows light position + direction (ArrowHelper) for mobile debugging
    const sunGizmo = new THREE.Group();
    sunGizmo.name = "SunGizmo";
    const sunBall = new THREE.Mesh(
      new THREE.SphereGeometry(1.6, 12, 10),
      new THREE.MeshBasicMaterial({ color: 0xfff2a8 })
    );
    sunGizmo.add(sunBall);

    const sunArrow = new THREE.ArrowHelper(
      new THREE.Vector3(1,0,0),
      new THREE.Vector3(0,0,0),
      28,
      0xfff2a8
    );
    sunGizmo.add(sunArrow);

    const sunLineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    const sunLine = new THREE.Line(sunLineGeo, new THREE.LineBasicMaterial({ color: 0xfff2a8, transparent: true, opacity: 0.65 }));
    sunGizmo.add(sunLine);

    globalThis.__sunGizmo = { group: sunGizmo, ball: sunBall, arrow: sunArrow, line: sunLine, lineGeo: sunLineGeo };
    scene.add(sunGizmo);

    const rim = new THREE.DirectionalLight(0xbfd7ff, 0.5);
    rim.position.set(-60, 40, -50);
    scene.add(rim);

    const matWire = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, side: THREE.DoubleSide });
    const matNormal = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });

    const matTopsGrass = new THREE.MeshStandardMaterial({ color: 0x2d6f35, roughness: 1.0, metalness: 0.0, side: THREE.DoubleSide });
    const matCliffBasalt = new THREE.MeshStandardMaterial({ color: 0x2a2f38, roughness: 0.95, metalness: 0.0, side: THREE.DoubleSide });

    const matSideRock = new THREE.MeshStandardMaterial({ color: 0x3a3b40, roughness: 0.98, metalness: 0.0, side: THREE.DoubleSide });
    const matBackWire = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.55, side: THREE.DoubleSide });
    const matGrassBlades = new THREE.MeshStandardMaterial({ color: 0x2f8c34, roughness: 0.95, metalness: 0.0, side: THREE.DoubleSide });

    // Prevent disposeObject() from disposing shared/global materials.
    for (const m of [matWire, matNormal, matTopsGrass, matCliffBasalt, matSideRock, matBackWire, matGrassBlades]){
      m.userData = m.userData || {};
      m.userData.__noDispose = true;
    }


    
    /* ======================================================================
       IGNORE_SEARCH_BEGIN: stylized_terrain_shader_module
       This block contains the "hand-drawn / toon / outline" shader stack
       copied/adapted from shittydrawing3Dshaderpreview19-1.html, structured so:
       - It‚Äôs easy to ignore while scanning.
       - It can be lifted into its own JS module later.
       Notes for this project:
       - Water is disabled for now (waterModeMix always 0).
       - We build TWO looks:
         * Rock/Cliff (gray)  => grassModeMix=0
         * Ground/Grass (green) => grassModeMix=1 (uses grass vertex variant)
       ====================================================================== */
    globalThis.StylizedTerrainShader = (() => {
      const clamp01 = (x)=>Math.max(0, Math.min(1, x));

      // Shared uniforms (time/resolution/light) are referenced by all shader materials.
      const shared = {
        time:         { value: 0.0 },                 // updated in tick()
        resolution:   { value: new THREE.Vector2(__vw, __vh) }, // updated on resize
        lightDirWorld:{ value: new THREE.Vector3(0.55, 0.85, 0.25).normalize() }, // set from scene's "sun"
        screenWidth:  { value: 4.5 },                 // outline width in px
        
        // Proximity lights (up to 4 point lights that brighten materials based on distance)
        pointLightPositions: { value: [
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, 0)
        ]},
        pointLightRadii:     { value: [0.0, 0.0, 0.0, 0.0] }, // 0 = disabled
        pointLightIntensities: { value: [0.0, 0.0, 0.0, 0.0] }, // brightness boost
        pointLightColors:    { value: [
          new THREE.Color(1, 1, 1),
          new THREE.Color(1, 1, 1),
          new THREE.Color(1, 1, 1),
          new THREE.Color(1, 1, 1)
        ]},
        
        // Seasonal system (Andes highlands altitude)
        seasonValue:    { value: 0.5 },               // 0=dry season, 1=wet season
        grassCoverage:  { value: 0.7 },               // how much grass covers terrain (0.4 dry, 0.95 wet)
        dryGrassColor:  { value: new THREE.Color(0.7, 0.55, 0.25) },   // golden-brown
        wetGrassColor:  { value: new THREE.Color(0.15, 0.55, 0.2) },   // vibrant green
        currentGrassColor: { value: new THREE.Color(0.3, 0.6, 0.3) },  // interpolated
        terrainTileSize: { value: 1.0 },              // tile size for patch calculation
      };

      // Style knobs (kept close to the preview defaults)

            // Style knobs (kept close to the preview defaults)
      function makeStyleUniforms(){
        return {
        // 2-tone / cel feel
        shadeDarken:   { value: 0.30 },
        shadeWarpAmp:  { value: 0.15 },
        shadeThreshold:{ value: 0.55 },

        // silhouette-attached shadow band controls
        edgeAttach:    { value: 0.85 },
        edgeBand:      { value: 0.22 },

        // rim shading controls
        rimLit:        { value: 0.18 },
        rimShadow:     { value: 0.55 },
        rimWidthLit:   { value: 0.10 },
        rimWidthShadow:{ value: 0.28 },

        // terminator ink
        termInk:       { value: 0.20 },
        termWidth:     { value: 1.25 },

        // Atmospheric fog (distance-based lightening)
        fogColor:      { value: new THREE.Color(0.75, 0.82, 0.90) },  // Sky blue-ish
        fogNear:       { value: 80.0 },
        fogFar:        { value: 200.0 },
        fogStrength:   { value: 0.35 },

        // Ambient occlusion approximation
        aoStrength:    { value: 0.25 },
        aoRadius:      { value: 2.0 },

        // Specular highlight (optional, mostly for water)
        specularStrength: { value: 0.0 },
        specularPower:    { value: 32.0 },

        // Stone/cliff deformation (new - makes wonky outlines on cliffs)
        stoneModeMix:           { value: 0.0 },  // 0=off, 1=full stone deform
        stoneFacingDir:         { value: new THREE.Vector3(1, 0, 0) },
        stoneIsotropic:        { value: 0.0 },  // 0=directional strata/bite, 1=isotropic crumbly
        stoneMinFacingDot:      { value: -0.25 },
        stoneVerticalMaxAbsNy:  { value: 0.65 },
        stoneNoiseScale:        { value: 1.8 },
        stoneErodeStrength:     { value: 0.18 },
        stoneChipStrength:      { value: 0.12 },
        stoneStrataScale:       { value: 8.0 },
        stoneStrataStrength:    { value: 0.08 },

        // deform controls (kept OFF by default in terrain builder)
        deformBaseMix: { value: 0.0 },
        deformAmount:  { value: 0.00 },
        wobbleTurns:   { value: 1.00 },
        wobbleAmp:     { value: 0.10 },
        jitterAmp:     { value: 0.03 },
        kinkStrength:  { value: 0.06 },
        convexBias:    { value: 0.35 },
        inwardClamp:   { value: 0.55 },

        // grass controls (applied only to grass materials)
        grassHeight:   { value: 0.80 },
        grassJagged:   { value: 1.10 },
        grassWidth:    { value: 0.5 },  // controls tuft width (lower = narrower spikes)
        grassFreq:    { value: 50.0 }, // grass noise frequency (higher = finer blades)
        windVel:       { value: new THREE.Vector3(0.0, 0.0, 0.0) },
                windStrength:{ value: 0.12 }, // scales grass wind response (used only by grass shaders)
upAxisObj:    { value: new THREE.Vector3(0.0, 1.0, 0.0) }, // object-space "up" used for grass sprouting mask

        // Snow accumulation/displacement (used by Orographic Snowbelt biome; safe default = off)
        snowHeight:           { value: 1.0 },  // max snow displacement height (rock/cliff)
        snowNoiseScale:       { value: 1.1 },  // xz noise scale for uneven accumulation
        snowLayers:           { value: 5.0 },  // number of stepped layers
        snowLayerBulge:       { value: 0.65 }, // rounded bulge inside each layer
        snowLayerSharpness:   { value: 2.5 },  // bulge sharpness (higher = crisper)
        snowSlopeStart:       { value: 0.0 }, // start accumulating (dot(n, up))
        snowSlopeEnd:         { value: 1.0 }, // full accumulation
        // Edge-hold: keep accumulation snug at boundaries and lift interior (curve/bulge)
        // edgeW is 1 at the boundary, 0 in the interior.
        snowEdgeHold:         { value: 1.0 },  // 0=ignore edges, 1=pin edges to base height
        snowEdgePow:          { value: 0.0 },  // higher = tighter edge pinning
        snowTintColor:        { value: new THREE.Color(0xebf6ff) }, // fragment tint on snowy areas
        snowTintStrength:     { value: 1.0 },  // 0..1, mixes into baseColor

      
        // "Sky light" (hemisphere) term (shader-side; independent of Three.js lights)
        skyColor:      { value: new THREE.Color(0xbfd7ff) },  // used in toon shader
        groundColor:   { value: new THREE.Color(0x5b4a2f) },  // used in toon shader
        hemiIntensity: { value: 0.55 },                       // used in toon shader

        // Shape light & real light system
        shapeLightTrack: { value: 0.7 },        // How much shape light follows sun laterally (0-1)
        realLightBrightness: { value: 0.8 },    // Intensity of real lighting layer over 2-tone

      };
      }

      // Separate style sets so rock/cliff and grass can use different presets.
      const styleRock  = makeStyleUniforms();
      const styleGrass = makeStyleUniforms();
      const style = styleRock; // backward-compat: old code expects `style`

      // Enable stone deformation for rock/cliff materials (makes wonky outlines)
      styleRock.stoneModeMix.value = 1.0;


      // ---------------------------------------------------------------------
      // Shader preset library (imported from shaderpreset_*.json exports)
      // ---------------------------------------------------------------------
      const SHADER_PRESET_LIBRARY = {
        cliff1: {
          shadeDarken: 0.30,
          shadeWarpAmp: 0.8,
          shadeThreshold: 0.5,
          edgeAttach: 0.86,
          edgeBand: 0.22,
          termInk: 0.2,
          termWidth: 1.25,
          screenWidth: 5,
          deformAmount: 0.12,
          wobbleTurns: 1,
          wobbleAmp: 0.1,
          jitterAmp: 0.03,
          kinkStrength: 0.06,
          convexBias: 0.36,
          inwardClamp: 0.56,
          grassHeight: 0.27,
          grassJagged: 1.1,
          windX: 0,
          windY: 0,
          windZ: 0
        },
        shortgrass1: {
          shadeDarken: 0.30,
          shadeWarpAmp: 0.8,
          shadeThreshold: 0.5,
          edgeAttach: 0.06,
          edgeBand: 0.22,
          termInk: 0.2,
          termWidth: 1.25,
          screenWidth: 5,
          deformAmount: 0.12,
          wobbleTurns: 1,
          wobbleAmp: 0.1,
          jitterAmp: 0.03,
          kinkStrength: 0.06,
          convexBias: 0.36,
          inwardClamp: 0.56,
          grassHeight: 0.27,
          grassJagged: 1.1,
          windX: 0,
          windY: 0,
          windZ: 0
        },
        gentleriver1: {
          shadeDarken: 0.30,
          shadeWarpAmp: 0.8,
          shadeThreshold: 0.5,
          edgeAttach: 0.86,
          edgeBand: 0.22,
          termInk: 0.2,
          termWidth: 1.25,
          screenWidth: 5,
          deformAmount: 0.12,
          wobbleTurns: 1,
          wobbleAmp: 0.1,
          jitterAmp: 0.03,
          kinkStrength: 0.06,
          convexBias: 0.36,
          inwardClamp: 0.56,
          grassHeight: 0.25,
          grassJagged: 1.1,
          windX: 0,
          windY: 0,
          windZ: 0
        }
      };

      // Chosen to be "wisest": a single coherent default for the whole terrain look,
      // but switchable at runtime (and future-proof for more presets).
      const DEFAULT_SHADER_PRESET_ROCK = "cliff1";
      const DEFAULT_SHADER_PRESET_GRASS = "shortgrass1";
      let _activeShaderPresetRock = DEFAULT_SHADER_PRESET_ROCK;
      let _activeShaderPresetGrass = DEFAULT_SHADER_PRESET_GRASS;
      // ---------------------------------------------------------------------
      // ALWAYS-ON material debug registry (HUD-visible, mobile-safe)
      // ---------------------------------------------------------------------
      const __materialDebug = {
        list: [],
        clear(){ this.list.length = 0; },
        add(role, mat, extra){
          if (!mat) return;
          const info = Object.assign({
            role: String(role || "?"),
            type: mat.type || (mat.constructor && mat.constructor.name) || "Material",
            uuid: mat.uuid || "",
            name: mat.name || "",
            isShader: !!mat.isShaderMaterial,
          }, extra || {});

          // Snapshot a few key uniforms (mobile HUD friendly)
          if (mat && mat.uniforms){
            if (mat.uniforms.grassHeight) info.grassHeight = mat.uniforms.grassHeight.value;
            if (mat.uniforms.grassJagged) info.grassJagged = mat.uniforms.grassJagged.value;
            if (mat.uniforms.grassFreq) info.grassFreq = mat.uniforms.grassFreq.value;
            if (mat.uniforms.grassModeMix) info.grassModeMix = mat.uniforms.grassModeMix.value;
            if (mat.uniforms.windVel && mat.uniforms.windVel.value){
              const w = mat.uniforms.windVel.value;
              info.windLen = Math.sqrt((w.x||0)*(w.x||0) + (w.y||0)*(w.y||0) + (w.z||0)*(w.z||0));
            }
          }
          this.list.push(info);
          mat.userData = mat.userData || {};
          mat.userData.__debugRole = info.role;
        },
        dump(){
          // Dedup by role+uuid+type so HUD stays stable.
          const seen = new Set();
          const out = [];
          for (const it of this.list){
            const key = `${it.role}|${it.uuid}|${it.type}`;
            if (seen.has(key)) continue;
            seen.add(key);
            out.push(it);
          }
          out.sort((a,b)=> (a.role||"").localeCompare(b.role||""));
          return out;
        }
      };
 // used by HUD/debug

            function applyShaderPreset(name, target){
        const p = SHADER_PRESET_LIBRARY[name];
        if (!p) return false;

        const t = (target === "grass") ? "grass" : "rock";
        const styleSet = (t === "grass") ? styleGrass : styleRock;

        // shared (outline width) - prefer rock preset to avoid fighting
        if (t === "rock" && typeof p.screenWidth === "number") shared.screenWidth.value = p.screenWidth;

        // toon/shadow band
        if (typeof p.shadeDarken === "number") styleSet.shadeDarken.value = p.shadeDarken;
        if (typeof p.shadeWarpAmp === "number") styleSet.shadeWarpAmp.value = p.shadeWarpAmp;
        if (typeof p.shadeThreshold === "number") styleSet.shadeThreshold.value = p.shadeThreshold;
        if (typeof p.edgeAttach === "number") styleSet.edgeAttach.value = p.edgeAttach;
        if (typeof p.edgeBand === "number") styleSet.edgeBand.value = p.edgeBand;

        // rim / terminator
        if (typeof p.rimWidth === "number") {
          // Back-compat: some exports used a single rimWidth+rimDark. Map into lit/shadow widths.
          styleSet.rimWidthLit.value = Math.max(0.01, p.rimWidth * 0.30);
          styleSet.rimWidthShadow.value = Math.max(0.01, p.rimWidth * 0.70);
        }
        if (typeof p.rimDark === "number") styleSet.rimShadow.value = clamp01(0.35 + p.rimDark * 0.65);
        if (typeof p.termInk === "number") styleSet.termInk.value = p.termInk;
        if (typeof p.termWidth === "number") styleSet.termWidth.value = p.termWidth;

        // deform
        if (typeof p.deformAmount === "number") styleSet.deformAmount.value = p.deformAmount;
        if (typeof p.wobbleTurns === "number") styleSet.wobbleTurns.value = p.wobbleTurns;
        if (typeof p.wobbleAmp === "number") styleSet.wobbleAmp.value = p.wobbleAmp;
        if (typeof p.jitterAmp === "number") styleSet.jitterAmp.value = p.jitterAmp;
        if (typeof p.kinkStrength === "number") styleSet.kinkStrength.value = p.kinkStrength;
        if (typeof p.convexBias === "number") styleSet.convexBias.value = p.convexBias;
        if (typeof p.inwardClamp === "number") styleSet.inwardClamp.value = p.inwardClamp;

        // grass
        if (typeof p.grassHeight === "number") styleSet.grassHeight.value = p.grassHeight;
        if (typeof p.grassJagged === "number") styleSet.grassJagged.value = p.grassJagged;
        if (typeof p.windX === "number" || typeof p.windY === "number" || typeof p.windZ === "number"){
          const vx = (typeof p.windX === "number") ? p.windX : styleSet.windVel.value.x;
          const vy = (typeof p.windY === "number") ? p.windY : styleSet.windVel.value.y;
          const vz = (typeof p.windZ === "number") ? p.windZ : styleSet.windVel.value.z;
          styleSet.windVel.value.set(vx, vy, vz);
        }

        // snow (optional; used by Orographic Snowbelt biome)
        if (typeof p.snowHeight === "number") styleSet.snowHeight.value = p.snowHeight;
        if (typeof p.snowNoiseScale === "number") styleSet.snowNoiseScale.value = p.snowNoiseScale;
        if (typeof p.snowLayers === "number") styleSet.snowLayers.value = p.snowLayers;
        if (typeof p.snowLayerBulge === "number") styleSet.snowLayerBulge.value = p.snowLayerBulge;
        if (typeof p.snowLayerSharpness === "number") styleSet.snowLayerSharpness.value = p.snowLayerSharpness;
        if (typeof p.snowSlopeStart === "number") styleSet.snowSlopeStart.value = p.snowSlopeStart;
        if (typeof p.snowSlopeEnd === "number") styleSet.snowSlopeEnd.value = p.snowSlopeEnd;

        // snow tint (optional)
        if (typeof p.snowTintStrength === "number") styleSet.snowTintStrength.value = clamp01(p.snowTintStrength);
        if (typeof p.snowTintColor === "string") styleSet.snowTintColor.value.set(p.snowTintColor);

        if (t === "grass") _activeShaderPresetGrass = name;
        else _activeShaderPresetRock = name;

        return true;
      }

      // Apply default immediately so all existing shader materials inherit these defaults.
      applyShaderPreset(DEFAULT_SHADER_PRESET_ROCK, "rock");
        applyShaderPreset(DEFAULT_SHADER_PRESET_GRASS, "grass");

      const GLSL_COMMON = `
float hash1(float n){ return fract(sin(n) * 43758.5453123); }
float hash3(vec3 p){ return hash1(dot(p, vec3(127.1, 311.7, 74.7))); }
float noise3(vec3 x){
  vec3 i=floor(x), f=fract(x);
  f=f*f*(3.0-2.0*f);
  float n000=hash3(i+vec3(0,0,0));
  float n100=hash3(i+vec3(1,0,0));
  float n010=hash3(i+vec3(0,1,0));
  float n110=hash3(i+vec3(1,1,0));
  float n001=hash3(i+vec3(0,0,1));
  float n101=hash3(i+vec3(1,0,1));
  float n011=hash3(i+vec3(0,1,1));
  float n111=hash3(i+vec3(1,1,1));
  float nx00=mix(n000,n100,f.x);
  float nx10=mix(n010,n110,f.x);
  float nx01=mix(n001,n101,f.x);
  float nx11=mix(n011,n111,f.x);
  float nxy0=mix(nx00,nx10,f.y);
  float nxy1=mix(nx01,nx11,f.y);
  return mix(nxy0,nxy1,f.z);
}
float signedNoise(vec3 p){ return (noise3(p)-0.5)*2.0; }
float kinkNoise(vec3 p){ return step(0.88, noise3(p)); }

float deformScalarFull(vec3 posObj, float wobbleTurns, float wobbleAmp, float jitterAmp, float kinkStrength){
  float fBig=max(0.05, wobbleTurns*2.0);
  float big=signedNoise(posObj*fBig)*wobbleAmp;
  float small=signedNoise(posObj*11.0)*jitterAmp;
  float kink=kinkNoise(posObj*2.7)*kinkStrength;
  return big+small+kink;
}
float deformScalarBig(vec3 posObj, float wobbleTurns, float wobbleAmp){
  float fBig=max(0.05, wobbleTurns*2.0);
  return signedNoise(posObj*fBig)*wobbleAmp;
}
float applyConvexClamp(float raw, vec3 posObj, vec3 normalObj, float deformAmount, float convexBias, float inwardClamp){
  vec3 fromC=normalize(posObj+vec3(1e-6));
  float radial=max(0.0, dot(normalObj, fromC));
  float convexPush=convexBias*radial*deformAmount;
  float minIn=-abs(deformAmount)*inwardClamp;
  return clamp(raw, minIn, abs(deformAmount)) + convexPush;
}
`;

      function makeUniformsForMesh(baseColorVec3, grassModeMixValue, styleSet){
        styleSet = styleSet || styleRock;
        // per-mesh baseColor + per-mesh grassModeMix so outlines can differ
        return {
          // shared
          time: shared.time,
          resolution: shared.resolution,
          lightDirWorld: shared.lightDirWorld,
          screenWidth: shared.screenWidth,
          
          // proximity lights
          pointLightPositions: shared.pointLightPositions,
          pointLightRadii: shared.pointLightRadii,
          pointLightIntensities: shared.pointLightIntensities,
          pointLightColors: shared.pointLightColors,

          // seasonal (shared across all materials)
          seasonValue: shared.seasonValue,
          grassCoverage: shared.grassCoverage,
          dryGrassColor: shared.dryGrassColor,
          wetGrassColor: shared.wetGrassColor,
          currentGrassColor: shared.currentGrassColor,
          terrainTileSize: shared.terrainTileSize,

          // style
          baseColor: { value: baseColorVec3.clone() },  // used in frag
          shadeDarken: styleSet.shadeDarken,
          shadeWarpAmp: styleSet.shadeWarpAmp,
          shadeThreshold: styleSet.shadeThreshold,
          edgeAttach: styleSet.edgeAttach,
          edgeBand: styleSet.edgeBand,

          rimLit: styleSet.rimLit,
          rimShadow: styleSet.rimShadow,
          rimWidthLit: styleSet.rimWidthLit,
          rimWidthShadow: styleSet.rimWidthShadow,
          termInk: styleSet.termInk,
          termWidth: styleSet.termWidth,

          // hemisphere lighting (sky/ground colors)
          skyColor: styleSet.skyColor,
          groundColor: styleSet.groundColor,
          hemiIntensity: styleSet.hemiIntensity,

          // deform
          deformBaseMix: styleSet.deformBaseMix,
          deformAmount: styleSet.deformAmount,
          wobbleTurns: styleSet.wobbleTurns,
          wobbleAmp: styleSet.wobbleAmp,
          jitterAmp: styleSet.jitterAmp,
          kinkStrength: styleSet.kinkStrength,
          convexBias: styleSet.convexBias,
          inwardClamp: styleSet.inwardClamp,

          // grass
          grassModeMix: { value: clamp01(grassModeMixValue) }, // used by outline shader
          grassHeight: styleSet.grassHeight,
          grassJagged: styleSet.grassJagged,
          grassFreq: styleSet.grassFreq,
          windVel: styleSet.windVel,
          windStrength: styleSet.windStrength,
          upAxisObj: styleSet.upAxisObj,

          // stone/cliff deformation
          stoneModeMix: styleSet.stoneModeMix,
          stoneFacingDir: styleSet.stoneFacingDir,
          stoneIsotropic: styleSet.stoneIsotropic,
          stoneMinFacingDot: styleSet.stoneMinFacingDot,
          stoneVerticalMaxAbsNy: styleSet.stoneVerticalMaxAbsNy,
          stoneNoiseScale: styleSet.stoneNoiseScale,
          stoneErodeStrength: styleSet.stoneErodeStrength,
          stoneChipStrength: styleSet.stoneChipStrength,
          stoneStrataScale: styleSet.stoneStrataScale,
          stoneStrataStrength: styleSet.stoneStrataStrength,

          // snow (optional; only affects rock vertex/fragment when enabled)
          snowHeight: styleSet.snowHeight,
          snowNoiseScale: styleSet.snowNoiseScale,
          snowLayers: styleSet.snowLayers,
          snowLayerBulge: styleSet.snowLayerBulge,
          snowLayerSharpness: styleSet.snowLayerSharpness,
          snowSlopeStart: styleSet.snowSlopeStart,
          snowSlopeEnd: styleSet.snowSlopeEnd,
          snowEdgeHold: styleSet.snowEdgeHold,
          snowEdgePow: styleSet.snowEdgePow,
          snowTintColor: styleSet.snowTintColor,
          snowTintStrength: styleSet.snowTintStrength,

          // Per-material overlay control (used by Accumulation mode snow overlay)
          snowOverlayCutoff: { value: 0.0 }, // used in fragment shader; 0 disables discard
        };
      }

      function makeToonSurfaceMaterial(uniformsForMesh, isGrass){
        const vertexToon = `
          uniform float deformBaseMix, deformAmount, wobbleTurns, wobbleAmp, jitterAmp, kinkStrength, convexBias, inwardClamp;
          
          // Stone/cliff deformation uniforms
          uniform float stoneModeMix;
          uniform vec3  stoneFacingDir;
          uniform float stoneIsotropic;
          uniform float stoneMinFacingDot;
          uniform float stoneVerticalMaxAbsNy;
          uniform float stoneNoiseScale;
          uniform float stoneErodeStrength;
          uniform float stoneChipStrength;
          uniform float stoneStrataScale;
          uniform float stoneStrataStrength;

          // Snow accumulation/displacement (optional; used by Orographic Snowbelt biome)
          uniform float snowHeight;
          uniform float snowNoiseScale;
          uniform float snowLayers;
          uniform float snowLayerBulge;
          uniform float snowLayerSharpness;
          uniform float snowSlopeStart;
          uniform float snowSlopeEnd;
          uniform float snowEdgeHold;
          uniform float snowEdgePow;
          uniform vec3  upAxisObj;

          // Edge draping helpers (for accumulation/snow to wrap over boundaries)
          attribute float edgeW;
          attribute vec2  outDirXZ;
          attribute float isTop;

          varying float vSnowAmt;
          varying vec3 vPosObj;
          varying vec3 vNormalWorld;
          varying vec3 vPosWorld;
          varying vec3 vColor; // NEW: Pass vertex color to fragment shader
          ${GLSL_COMMON}

          void main(){
            vec3 posObj=position;
            vec2 baseXZ = posObj.xz; // used to prevent inward clipping at edges
            vec3 nObj=normal;
            
            // NEW: Pass vertex color through (defaults to white if not provided)
            #ifdef USE_COLOR
              vColor = color;
            #else
              vColor = vec3(1.0, 1.0, 1.0);
            #endif

            float raw = deformScalarFull(posObj, wobbleTurns, wobbleAmp, jitterAmp, kinkStrength) * deformAmount;
            float d = applyConvexClamp(raw, posObj, nObj, deformAmount, convexBias, inwardClamp) * deformBaseMix;

            vec3 deformedObj = posObj + nObj * d;

            // Stone/cliff displacement (matches outline deformation)
            float sMix = clamp(stoneModeMix, 0.0, 1.0);
            if (sMix > 0.001){
              vec3 fdS = normalize(stoneFacingDir + vec3(1e-6));
              float facingS = dot(normalize(nObj), fdS);
              float facingMaskS0 = smoothstep(stoneMinFacingDot, 1.0, facingS);
              float isoS = step(0.5, stoneIsotropic);
              float facingMaskS = mix(facingMaskS0, 1.0, isoS);
              float vMaskS = 1.0 - smoothstep(stoneVerticalMaxAbsNy, stoneVerticalMaxAbsNy + 0.25, abs(nObj.y));
              float mS = clamp(facingMaskS * vMaskS, 0.0, 1.0) * sMix;

              vec3 pS = deformedObj * stoneNoiseScale;
              float n0S = signedNoise(pS * 0.90 + vec3(0.0, 1.7, 0.0));
              float n1S = signedNoise(pS * 2.10 + vec3(11.0, -3.0, 7.0));
              float carveS = -abs(n0S) * stoneErodeStrength;
              float chipS  = -smoothstep(0.25, 0.85, n1S) * stoneChipStrength;
              float strataPhaseS = (deformedObj.y * stoneStrataScale) + signedNoise(pS * 0.35) * 1.2;
              float strataS = smoothstep(0.72, 1.0, sin(strataPhaseS)) * stoneStrataStrength;

              vec3 biteAxisS = mix(fdS, normalize(vec3(
                signedNoise(pS * 0.55 + vec3( 9.0,  2.0,  5.0)),
                signedNoise(pS * 0.55 + vec3(-3.0,  7.0,  1.0)),
                signedNoise(pS * 0.55 + vec3( 4.0, -6.0,  8.0))
              ) + vec3(1e-6)), isoS);
              vec3 tangentS = normalize(cross(nObj, biteAxisS) + vec3(1e-6));
              float biteS = signedNoise(pS * 3.30 + vec3(2.0, 0.0, -5.0)) * (stoneChipStrength * 0.22) * mS;

              vec3 stoneDisp = nObj * ((carveS + chipS + strataS) * mS) + tangentS * biteS;
              deformedObj += stoneDisp;
            }

            
            // Snow displacement (optional; safe when snowHeight = 0)
            float sH = max(0.0, snowHeight);
            if (sH > 1e-5){
              vec3 upA = normalize(upAxisObj + vec3(1e-6));
              vec3 nSnow = nObj;
              if (dot(nSnow, upA) < 0.0) nSnow = -nSnow;

              float upDot = dot(normalize(nSnow), upA);
              float slopeMask = smoothstep(snowSlopeStart, snowSlopeEnd, upDot) * clamp(isTop, 0.0, 1.0);

              // Edge-hold: pin snow at borders and lift interior to form a smooth curve.
              // edgeW is 1 at boundary, 0 interior.
              float e = clamp(edgeW, 0.0, 1.0);
              float edgeMask = pow(max(0.0, 1.0 - e), max(0.05, snowEdgePow));
              slopeMask *= mix(1.0, edgeMask, clamp(snowEdgeHold, 0.0, 1.0));

              vec2 xz = deformedObj.xz;
              float n0 = noise3(vec3(xz * snowNoiseScale, 0.0));
              float n1 = noise3(vec3((xz + vec2(13.7, -9.2)) * (snowNoiseScale * 0.55), 0.0));
              float lump = mix(n0, n1, 0.55);

              float H = sH * slopeMask * (0.65 + 0.35 * lump);

              float layers = max(1.0, snowLayers);
              // Fixed layer height approach: each layer is a constant height
              // This ensures all layers are visible regardless of total snow depth
              float layerH = max(1e-4, sH * 0.25);  // Each layer is 25% of max snow height
              float t = H / layerH;
              float baseL = floor(t);
              float frac = fract(t);

              float bulge = sin(frac * 3.1415926);
              bulge = pow(max(0.0, bulge), max(0.5, snowLayerSharpness));

              float disp = (baseL + bulge * clamp(snowLayerBulge, 0.0, 1.0)) * layerH;

              float micro = signedNoise(vec3(xz * (snowNoiseScale * 3.2), 1.7));
              disp += micro * layerH * 0.25 * clamp(snowLayerBulge, 0.0, 1.0);

              disp = clamp(disp, 0.0, sH * 1.35);

              vec3 dispDir = normalize(mix(nSnow, upA, 0.80));
              deformedObj += dispDir * disp;

              vSnowAmt = clamp(disp / max(1e-4, sH), 0.0, 1.0) * slopeMask;
            } else {
              vSnowAmt = 0.0;
            }

            // Edge no-penetration: allow outward overhang but prevent inward push-through into vertical walls.
            float eNP = clamp(edgeW, 0.0, 1.0);
            if (eNP > 1e-6){
              vec2 oD = normalize(outDirXZ + vec2(1e-6));
              vec2 moveXZ = deformedObj.xz - baseXZ;
              float dotM = dot(moveXZ, oD);
              float strength = pow(eNP, 1.35);
              if (dotM < 0.0){
                // Remove only the inward component (dotM < 0), leaving outward "leak" intact.
                deformedObj.xz -= oD * dotM * strength;
              }
              // Tiny outward clearance helps avoid seam z-fighting (mobile-friendly).
              deformedObj.xz += oD * (0.002 * strength);
            }


            vPosObj = deformedObj;

            #ifdef USE_INSTANCING
              vec4 worldPos = modelMatrix * instanceMatrix * vec4(deformedObj, 1.0);
              // normal approximation (good enough for stylized look)
              mat3 m3 = mat3(modelMatrix) * mat3(instanceMatrix);
              vNormalWorld = normalize(m3 * nObj);
            #else
              vec4 worldPos = modelMatrix * vec4(deformedObj, 1.0);
              vNormalWorld = normalize(normalMatrix * nObj);
            #endif

            vPosWorld = worldPos.xyz;
            gl_Position = projectionMatrix * viewMatrix * worldPos;
          }
        `;

        const vertexGrass = `
          uniform float time;
          uniform float grassHeight;
          uniform float grassJagged;
          uniform float grassWidth;
          uniform float grassFreq;
          uniform vec3 windVel;
            uniform float windStrength;
          uniform vec3 upAxisObj;

          // Edge draping helpers (for accumulation/snow to wrap over boundaries)
          attribute float edgeW;
          attribute vec2  outDirXZ;
          attribute float isTop;

          // Snow accumulation/displacement (shared uniforms; safe default = off)
          uniform float snowHeight;
          uniform float snowNoiseScale;
          uniform float snowLayers;
          uniform float snowLayerBulge;
          uniform float snowLayerSharpness;
          uniform float snowSlopeStart;
          uniform float snowSlopeEnd;
          uniform float snowEdgeHold;
          uniform float snowEdgePow;

          uniform float deformBaseMix, deformAmount, wobbleTurns, wobbleAmp, jitterAmp, kinkStrength, convexBias, inwardClamp;

          varying vec3 vPosObj;
          varying vec3 vNormalWorld;
          varying vec3 vPosWorld;
          varying vec3 vColor;
          varying float vSnowAmt; // NEW: Pass vertex color to fragment shader

          ${GLSL_COMMON}

          // Anime tuft function - creates chunky spikes like Sonic/Goku hair
          float animeTuft(float x) {
            // Sharp threshold for distinct tufts
            float t = smoothstep(0.35, 0.65, x);
            return step(0.5, t) * 2.0 - 1.0;
          }
          
          // Cluster noise - creates grouped tufts instead of uniform distribution
          float clusterNoise(vec2 p, float freq) {
            float n1 = noise3(vec3(p * freq * 0.3, 0.0));
            float n2 = noise3(vec3(p * freq, 0.0));
            // Combine low and high frequency for clustered effect
            return n1 * 0.7 + n2 * 0.3;
          }

          void main(){
            vec3 posObj = position;
            vec2 baseXZ = posObj.xz; // used to prevent inward clipping at edges
            vec3 nObj = normal;
            
            // NEW: Pass vertex color through (defaults to white if not provided)
            #ifdef USE_COLOR
              vColor = color;
            #else
              vColor = vec3(1.0, 1.0, 1.0);
            #endif

            // Align grass normal so tufts grow outward along chosen up axis
            vec3 upA = normalize(upAxisObj);
            if (dot(nObj, upA) < 0.0) nObj = -nObj;

            // optional hand wobble (off by default for terrain)
            float raw = deformScalarFull(posObj, wobbleTurns, wobbleAmp, jitterAmp, kinkStrength) * deformAmount;
            float dBase = applyConvexClamp(raw, posObj, nObj, deformAmount, convexBias, inwardClamp) * deformBaseMix;
            posObj = posObj + nObj * dBase;

            float upDot = dot(normalize(nObj), upA);
            float upMask = smoothstep(-0.10, 0.45, upDot);

            // Wind setup
            vec3 windXZ = vec3(windVel.x, 0.0, windVel.z);
            float wLen = length(windXZ);
            vec3 wDir = (wLen < 1e-5) ? vec3(1.0,0.0,0.0) : (windXZ / wLen);

            float w = clamp(wLen, 0.0, 1.0);
            float wAmt = w*w * windStrength;

            float tAnim = (wAmt < 1e-6) ? 0.0 : time;
            vec3 wVec = vec3(wDir.x, 0.0, wDir.z) * wAmt;

            vec3 p = posObj + wVec * tAnim * 0.25;
            
            // ANIME TUFT GENERATION
            // Create clustered tufts instead of uniform spikes
            float clusterBase = clusterNoise(p.xz, grassFreq * 0.5);
            
            // **grassWidth controls tuft narrowness**: Lower values = narrower, more selective tufts
            // At grassWidth=1.0: smoothstep(0.2, 0.6) = original wide tufts
            // At grassWidth=0.5: smoothstep(0.35, 0.65) = 50% narrower tufts
            // At grassWidth=0.25: smoothstep(0.425, 0.675) = 75% narrower tufts
            float widthFactor = clamp(grassWidth, 0.1, 2.0);
            float thresholdLow = mix(0.2, 0.45, 1.0 - widthFactor);
            float thresholdHigh = mix(0.6, 0.55, 1.0 - widthFactor);
            float tuftMask = smoothstep(thresholdLow, thresholdHigh, clusterBase);
            
            // Two layers of detail for chunky look
            float n1 = noise3(vec3(p.xz * (2.0 * grassFreq), tAnim * 0.35));
            float n2 = noise3(vec3((p.xz + vec2(1.7, -0.9)) * (4.0 * grassFreq), tAnim * 0.55));
            
            // Create sharp, distinct tufts
            float tuft1 = animeTuft(n1);
            float tuft2 = animeTuft(n2);
            float tuftShape = tuft1 * 0.7 + tuft2 * 0.3;

            // CHUNKY SPIKE HEIGHT (3-4x taller than old grass)
            float spikeHeight = abs(tuftShape) * grassHeight * 3.5 * upMask * tuftMask;

            // Snow: suppress tufts under snow and compute layered snowpack displacement
            float sH = max(0.0, snowHeight);
            float snowDisp = 0.0;
            vec3  snowDispDir = vec3(0.0, 0.0, 0.0);
            vSnowAmt = 0.0;
            if (sH > 1e-5){
              float upDotSnow = dot(normalize(nObj), upA);
              float slopeMaskSnow = smoothstep(snowSlopeStart, snowSlopeEnd, upDotSnow) * clamp(isTop, 0.0, 1.0);

              // Edge-hold: pin snow at borders and lift interior to form a smooth curve.
              float eEdge = clamp(edgeW, 0.0, 1.0);
              float edgeMask = pow(max(0.0, 1.0 - eEdge), max(0.05, snowEdgePow));
              slopeMaskSnow *= mix(1.0, edgeMask, clamp(snowEdgeHold, 0.0, 1.0));

              // Uneven accumulation (same core math as HHShaderPreviewer vertexSnow)
              vec2 xz = posObj.xz;
              float n0 = noise3(vec3(xz * snowNoiseScale, 0.0));
              float n1 = noise3(vec3((xz + vec2(13.7, -9.2)) * (snowNoiseScale * 0.55), 0.0));
              float lump = mix(n0, n1, 0.55);

              float H = sH * slopeMaskSnow * (0.65 + 0.35 * lump);

              // Layering: quantize into steps, then add a bulge inside each step
              float layers = max(1.0, snowLayers);
              // Fixed layer height approach: each layer is a constant height
              // This ensures all layers are visible regardless of total snow depth
              float layerH = max(1e-4, sH * 0.25);  // Each layer is 25% of max snow height
              float t = H / layerH;
              float baseL = floor(t);
              float frac = fract(t);

              float bulge = sin(frac * 3.1415926);
              bulge = pow(max(0.0, bulge), max(0.5, snowLayerSharpness));

              float disp = (baseL + bulge * clamp(snowLayerBulge, 0.0, 1.0)) * layerH;

              float micro = signedNoise(vec3(xz * (snowNoiseScale * 3.2), 1.7));
              disp += micro * layerH * 0.25 * clamp(snowLayerBulge, 0.0, 1.0);

              disp = clamp(disp, 0.0, sH * 1.35);

              snowDispDir = normalize(mix(nObj, upA, 0.80));
              snowDisp = disp;

              // Use normalized displacement as a stable visual mask
              float snowCover = clamp(disp / max(1e-4, sH), 0.0, 1.0) * slopeMaskSnow;
              vSnowAmt = snowCover;

              // Suppress spiky tufts under snow (keeps the snowpack looking smooth)
              spikeHeight *= mix(1.0, 0.15, snowCover);
            }

            
            // ANIME CURVE (bend forward dramatically like Sonic quills)
            // Cubic curve for dramatic swoosh
            float curveAmount = grassJagged * 0.8;
            vec3 curveDir = normalize(cross(upA, vec3(1.0, 0.0, 0.0)) + vec3(0.01));
            float curvePower = pow(abs(tuftShape), 0.7); // More curve = more dramatic
            vec3 curveOffset = curveDir * curveAmount * spikeHeight * curvePower;
            
            // WIND TEAR (makes tufts lean with wind)
            float tear = tuftShape * grassHeight * 0.7 * grassJagged * upMask * wAmt * tuftMask;

            vec3 deformedObj = posObj;
            // Main spike (upward)
            deformedObj += nObj * spikeHeight;
            // Curve (forward bend)
            deformedObj += curveOffset;
            // Wind lean
            deformedObj += wDir * tear;
            deformedObj += upA * (abs(tear) * 0.4);

            // Apply snowpack displacement after tuft shaping
            deformedObj += snowDispDir * snowDisp;

            // Edge draping: push snow outward/down near boundaries so it reads as a thick mass,
            // rather than a "floating panel" on top of the voxel cap.
            if (snowDisp > 1e-6){
              float e = clamp(edgeW, 0.0, 1.0);
              if (e > 1e-6){
                float sharp = max(0.35, snowLayerSharpness * 0.45);
                float lip = pow(e, sharp);
                float bulge = clamp(snowLayerBulge, 0.0, 1.0);
                float spread = snowDisp * (0.22 + 0.60 * bulge);
                float drop   = snowDisp * (0.14 + 0.46 * bulge);
                deformedObj.x += outDirXZ.x * spread * lip;
                deformedObj.z += outDirXZ.y * spread * lip;
                deformedObj.y -= drop * lip;
              }
            }


            // Edge no-penetration: allow outward overhang but prevent inward push-through into vertical walls.
            float eNP = clamp(edgeW, 0.0, 1.0);
            if (eNP > 1e-6){
              vec2 oD = normalize(outDirXZ + vec2(1e-6));
              vec2 moveXZ = deformedObj.xz - baseXZ;
              float dotM = dot(moveXZ, oD);
              float strength = pow(eNP, 1.35);
              if (dotM < 0.0){
                // Remove only the inward component (dotM < 0), leaving outward "leak" intact.
                deformedObj.xz -= oD * dotM * strength;
              }
              // Tiny outward clearance helps avoid seam z-fighting (mobile-friendly).
              deformedObj.xz += oD * (0.002 * strength);
            }

            vPosObj = deformedObj;

            #ifdef USE_INSTANCING
              vec4 worldPos = modelMatrix * instanceMatrix * vec4(deformedObj, 1.0);
              mat3 m3 = mat3(modelMatrix) * mat3(instanceMatrix);
              vNormalWorld = normalize(m3 * nObj);
            #else
              vec4 worldPos = modelMatrix * vec4(deformedObj, 1.0);
              vNormalWorld = normalize(normalMatrix * nObj);
            #endif

            vPosWorld = worldPos.xyz;
            gl_Position = projectionMatrix * viewMatrix * worldPos;
          }
        `;

        const fragToon = `
          uniform vec3 baseColor, lightDirWorld;
          uniform vec3 skyColor, groundColor;
          uniform float hemiIntensity;
          uniform float shadeDarken;
          uniform float shadeWarpAmp, shadeThreshold;
          uniform float wobbleTurns, wobbleAmp;
          uniform float edgeAttach, edgeBand;

          uniform float rimLit, rimShadow;
          uniform float rimWidthLit, rimWidthShadow;
          uniform float termInk, termWidth;
          
          // Shape light & real light system
          uniform float shapeLightTrack;
          uniform float realLightBrightness;
          
          // Proximity lights
          uniform vec3 pointLightPositions[4];
          uniform float pointLightRadii[4];
          uniform float pointLightIntensities[4];
          uniform vec3 pointLightColors[4];
          
          // Seasonal system
          uniform float seasonValue;
          uniform float grassCoverage;
          uniform vec3 dryGrassColor;
          uniform vec3 wetGrassColor;
          uniform vec3 currentGrassColor;
          uniform float terrainTileSize;

          varying vec3 vPosObj;
          varying vec3 vNormalWorld;
          varying vec3 vPosWorld;
          varying vec3 vColor; // NEW: Receive vertex color

          // Snow (optional; only used for rock/cliff when enabled)
          uniform float snowHeight;
          uniform vec3  snowTintColor;
          uniform float snowTintStrength;
          uniform float snowOverlayCutoff;

          varying float vSnowAmt;
          ${GLSL_COMMON}
          
          // Tile-based coverage for clean patches (no thin transparency lines)
          float tileNoise(vec2 tileCoord){
            // Hash function for tile coordinates
            return fract(sin(dot(tileCoord, vec2(127.1, 311.7))) * 43758.5453);
          }

          void main(){
            // SEASONAL GRASS COVERAGE (only for grass materials)
            ${isGrass ? `
            // Determine which tile this fragment is in
            vec2 tileCoord = floor(vPosWorld.xz / terrainTileSize);
            
            // Get noise value for this specific tile
            float tileValue = tileNoise(tileCoord);
            
            // Add some variation with neighboring tiles for organic clustering
            float neighbor1 = tileNoise(tileCoord + vec2(0.0, 1.0));
            float neighbor2 = tileNoise(tileCoord + vec2(1.0, 0.0));
            float clusterValue = (tileValue * 0.6 + neighbor1 * 0.2 + neighbor2 * 0.2);
            
            // Hard cutoff based on coverage (entire tiles are either grass or dirt)
            if (clusterValue < (1.0 - grassCoverage)) {
              // Keep snowy tiles even when grassCoverage is low (snow replaces bare dirt)
              if (vSnowAmt < 0.12) discard;
            }
            ` : ''}
          
            vec3 nW = normalize(vNormalWorld);
            vec3 vW = normalize(cameraPosition - vPosWorld);

            vec3 nGeom = normalize(cross(dFdx(vPosWorld), dFdy(vPosWorld)));
            if(dot(nGeom, nW) < 0.0) nGeom = -nGeom;

            float ndv = abs(dot(nW, vW));
            float ndvAA = max(1e-5, fwidth(ndv));

            // ============================================================
            // SHAPE LIGHT: Camera-perpendicular light for 2-tone boundary
            // ============================================================
            
            // Camera forward direction (opposite of view direction)
            vec3 camForward = -vW;
            
            // Camera right vector (perpendicular to forward and world up)
            vec3 worldUp = vec3(0.0, 1.0, 0.0);
            vec3 camRight = normalize(cross(worldUp, camForward));
            vec3 camUp = normalize(cross(camForward, camRight));
            
            // Default shape light: 45-degree angle in the perpendicular plane (upper right)
            // This creates good form-defining shadows when not tracking sun
            vec3 defaultShapeDir = normalize(camRight * 0.7071 + camUp * 0.7071);
            
            // Sun direction (actual light)
            vec3 sunDir = normalize(lightDirWorld);
            
            // Project sun onto plane perpendicular to camera forward
            // This gives us the lateral component (left/right, up/down from camera POV)
            vec3 sunPerpComponent = sunDir - dot(sunDir, camForward) * camForward;
            float sunPerpLength = length(sunPerpComponent);
            vec3 sunLateralDir = sunPerpLength > 0.001 
              ? normalize(sunPerpComponent) 
              : defaultShapeDir;
            
            // Shape light direction: blend between default angle and sun lateral position
            // At track=0: consistent 45¬∞ side/top light for form readability
            // At track=1: follows sun's lateral position while staying perpendicular to view
            vec3 shapeLightDir = normalize(mix(defaultShapeDir, sunLateralDir, shapeLightTrack));
            
            // Use shape light for 2-tone boundary decision
            float ndlShapeSmooth = dot(nW, shapeLightDir);
            float ndlShapeFace = dot(nGeom, shapeLightDir);
            
            float darkSide = smoothstep(0.15, -0.10, ndlShapeFace);
            float ndlShape = mix(ndlShapeSmooth, min(ndlShapeSmooth, ndlShapeFace), darkSide);
            
            float litShape = ndlShape * 0.5 + 0.5;
            float darkAmtShape = clamp(1.0 - litShape, 0.0, 1.0);

            // Rim lighting (based on shape light for consistency)
            float rimK = mix(0.85 + rimWidthLit * 6.0, 0.85 + rimWidthShadow * 8.0, darkAmtShape);
            float rim = 1.0 - smoothstep(ndvAA * rimK, ndvAA * rimK * 2.0, ndv);

            // Wobble and threshold
            float wBig = deformScalarBig(vPosObj, wobbleTurns, wobbleAmp);
            float baseT = shadeThreshold + wBig * shadeWarpAmp;

            float rimBoost = rim * edgeAttach * mix(0.06, 0.55, darkAmtShape) * edgeBand;
            float warpedT = baseT + rimBoost;

            // 2-tone boundary decision (ONLY based on shape light)
            float isShadow = step(litShape, warpedT);
            
            // ============================================================
            // REAL LIGHTING: Actual light sources for brightness layer
            // ============================================================
            
            // Sun lighting (using actual sun direction)
            float ndlSunSmooth = dot(nW, sunDir);
            float ndlSunFace = dot(nGeom, sunDir);
            float ndlSun = max(0.0, mix(ndlSunSmooth, min(ndlSunSmooth, ndlSunFace), darkSide));
            float sunBrightness = ndlSun;
            
            // Point light contributions (proximity lights)
            float proximityBrightness = 0.0;
            vec3 proximityColor = vec3(0.0);
            for(int i = 0; i < 4; i++){
              float radius = pointLightRadii[i];
              if(radius > 0.001){
                float dist = length(vPosWorld - pointLightPositions[i]);
                // Steeper falloff for more localized light pool
                float falloff = 1.0 - smoothstep(radius * 0.1, radius * 0.9, dist);
                falloff = falloff * falloff * falloff; // cubic falloff for tight, focused light
                float contribution = falloff * pointLightIntensities[i];
                proximityBrightness += contribution;
                proximityColor += pointLightColors[i] * contribution;
              }
            }
            proximityBrightness = clamp(proximityBrightness, 0.0, 2.0);
            
            // Total real lighting (sun + proximity)
            float realLighting = sunBrightness + proximityBrightness;
            
            // ============================================================
            // COMBINE: 2-tone base + real lighting brightness layer
            // ============================================================
            
            // Use seasonal grass color for grass materials, baseColor for everything else
            vec3 materialColor = ${isGrass ? 'currentGrassColor' : 'baseColor'};
            
            // NEW: Apply vertex color (rivers, roads, etc. get their type color)
            materialColor *= vColor;

            // Optional accumulation tint (snow / moss)
            // snowOverlayCutoff > 0 turns this material into a "snow overlay" layer that only renders
            // where snow is present (lets the base terrain show through elsewhere).
            if (snowOverlayCutoff > 0.0){
              if (vSnowAmt < snowOverlayCutoff) discard;
            }

            if (snowHeight > 1e-5){
              float sLayer = smoothstep(0.06, 0.22, clamp(vSnowAmt, 0.0, 1.0));
              float s = clamp(sLayer * clamp(snowTintStrength, 0.0, 1.0), 0.0, 1.0);
              materialColor = mix(materialColor, snowTintColor, s);
            }
            
            // Base 2-tone colors (strict boundary from shape light)
            vec3 shadowCol = mix(materialColor, vec3(0.0), clamp(shadeDarken, 0.0, 1.0));
            vec3 baseTone = mix(materialColor, shadowCol, isShadow);
            
            // Apply real lighting as spray-painted brightness layer
            // This brightens BOTH lit and unlit areas based on actual light
            vec3 litColor = baseTone * (1.0 + realLighting * realLightBrightness);
            
            // Mix in proximity light color tint
            if(proximityBrightness > 0.001){
              vec3 tintedColor = litColor * proximityColor / proximityBrightness;
              litColor = mix(litColor, tintedColor, 0.35 * realLightBrightness);
            }
            
            vec3 col = litColor;

            // Rim darkening (based on shape light dark side)
            float rimDark = mix(rimLit, rimShadow, darkAmtShape) * edgeAttach;
            col = mix(col, vec3(0.0), rim * rimDark * 0.55);

            // Terminator line (based on shape light)
            float diff = litShape - warpedT;
            float aa = max(1e-5, fwidth(diff));
            float line = 1.0 - smoothstep(aa * termWidth, aa * (termWidth + 1.0), abs(diff));
            col = mix(col, vec3(0.0), line * clamp(termInk, 0.0, 1.0));

            // Hemisphere (sky) light term: lifted shadows, helps readability
            float hemiT = clamp(nW.y * 0.5 + 0.5, 0.0, 1.0);
            vec3 hemiCol = mix(groundColor, skyColor, hemiT) * hemiIntensity;
            col = clamp(col + hemiCol, 0.0, 1.0);

            gl_FragColor = vec4(col, 1.0);
          }
        `;

        const mat = new THREE.ShaderMaterial({
          extensions: { derivatives: true }, // enables dFdx/dFdy on WebGL1

          uniforms: uniformsForMesh,
          vertexShader: isGrass ? vertexGrass : vertexToon,
          fragmentShader: fragToon,
          transparent: isGrass, // grass needs transparency for seasonal coverage discard
          depthWrite: true,
          depthTest: true,
          side: THREE.DoubleSide,
          vertexColors: true, // NEW: Enable vertex colors for river/road types
        });

        return mat;
      }

      // Outline widened in CLIP SPACE (pixel width).
      // NOTE: separate uniforms per outline material, so grass outlines can differ.
      function setSharedFromRendererSize(w,h){
        shared.resolution.value.set(Math.max(1,w), Math.max(1,h));
      }
      function setTime(t){ shared.time.value = t; }
      function setLightDirWorld(v){ shared.lightDirWorld.value.copy(v).normalize(); }
      
      // Point light management (proximity-based brightness)
      function setPointLight(index, position, radius, intensity, color){
        if(index < 0 || index > 3) return;
        shared.pointLightPositions.value[index].copy(position);
        shared.pointLightRadii.value[index] = radius;
        shared.pointLightIntensities.value[index] = intensity;
        if(color) shared.pointLightColors.value[index].copy(color);
      }
      
      function disablePointLight(index){
        if(index < 0 || index > 3) return;
        shared.pointLightRadii.value[index] = 0.0;
      }
      
      function disableAllPointLights(){
        for(let i = 0; i < 4; i++){
          shared.pointLightRadii.value[i] = 0.0;
        }
      }
      
            const __lerp = (a,b,t)=>a + (b - a) * t;

      // Biome profiles: bundle seasonal palette + wind + (optional) snow behavior
      const BIOME_PROFILES = {
        andes_highlands: {
          label: "Andes Highlands",
          desc: "Andean highlands wet/dry seasonal palette & wind.",
          seasonDesc0: "0.0 = Dry (golden grass, crystal sky)",
          seasonDesc1: "1.0 = Wet (green grass, morning fog)",
          grassCoverage: { dry: 0.40, wet: 0.95 },
          windMultiplier: { dry: 1.80, wet: 0.80 },
          dryGrassColor: { r: 0.70, g: 0.55, b: 0.25 },
          wetGrassColor: { r: 0.15, g: 0.55, b: 0.20 },
          snow: null
        },

        // Below the year-round snowline, but avalanche-fed: snow is constantly melting & replenishing
        orographic_snowbelt: {
          label: "Orographic Snowbelt",
          desc: "Below snowline but avalanche-fed: patchy snow layers, melt/replenish cycle.",
          seasonDesc0: "0.0 = Drier/colder (more lingering snow, stronger gap winds)",
          seasonDesc1: "1.0 = Wetter/warmer (more melt, stormier gusts)",
          grassCoverage: { dry: 0.25, wet: 0.75 },
          windMultiplier: { dry: 1.20, wet: 2.20 },
          dryGrassColor: { r: 0.62, g: 0.60, b: 0.50 },
          wetGrassColor: { r: 0.20, g: 0.58, b: 0.28 },
          snow: {
            heightDry: 0.55,
            heightWet: 0.30,
            noiseScale: 1.10,
            layers: 5.0,
            layerBulge: 0.65,
            layerSharpness: 2.5,
            slopeStart: 0.20,
            slopeEnd: 0.70,
            tintColorHex: 0xebf6ff,
            tintStrength: 1.0
          }
        },
      };

      let _activeBiomeKey = "andes_highlands";

      function getBiomeProfile(){
        return BIOME_PROFILES[_activeBiomeKey] || BIOME_PROFILES.andes_highlands;
      }

      function setBiomeMode(key){
        if (!key || !BIOME_PROFILES[key]) return false;
        _activeBiomeKey = key;

        const b = getBiomeProfile();

        // Apply biome grass palette
        if (b.dryGrassColor) shared.dryGrassColor.value.setRGB(b.dryGrassColor.r, b.dryGrassColor.g, b.dryGrassColor.b);
        if (b.wetGrassColor) shared.wetGrassColor.value.setRGB(b.wetGrassColor.r, b.wetGrassColor.g, b.wetGrassColor.b);

        // Apply biome snow defaults (rock/cliff only)
        if (b.snow){
          styleRock.snowNoiseScale.value = b.snow.noiseScale;
          styleRock.snowLayers.value = b.snow.layers;
          styleRock.snowLayerBulge.value = b.snow.layerBulge;
          styleRock.snowLayerSharpness.value = b.snow.layerSharpness;
          styleRock.snowSlopeStart.value = b.snow.slopeStart;
          styleRock.snowSlopeEnd.value = b.snow.slopeEnd;

          styleRock.snowTintColor.value.setHex(b.snow.tintColorHex);
          styleRock.snowTintStrength.value = clamp01(b.snow.tintStrength);
        } else {
          styleRock.snowHeight.value = 0.0;
          styleRock.snowTintStrength.value = 0.0;
        }

        // Re-apply season (coverage, wind, and snow height mapping)
        setSeasonValue(shared.seasonValue.value);

        return true;
      }

      function getBiomeMode(){
        return _activeBiomeKey;
      }

      // Seasonal system management (biome-aware wet/dry slider)
      function setSeasonValue(value){
        // value: 0 = dry, 1 = wet
        const v = clamp01(value);
        shared.seasonValue.value = v;

        const b = getBiomeProfile();

        // Coverage: biome-specific
        const covDry = b.grassCoverage ? b.grassCoverage.dry : 0.40;
        const covWet = b.grassCoverage ? b.grassCoverage.wet : 0.95;
        shared.grassCoverage.value = __lerp(covDry, covWet, v);

        // Interpolate grass color (biome palette)
        shared.currentGrassColor.value.lerpColors(
          shared.dryGrassColor.value,
          shared.wetGrassColor.value,
          v
        );

        // Wind strength multiplier: biome-specific
        const wDry = b.windMultiplier ? b.windMultiplier.dry : 1.80;
        const wWet = b.windMultiplier ? b.windMultiplier.wet : 0.80;
        const windMultiplier = __lerp(wDry, wWet, v);
        if (styleGrass.windStrength) styleGrass.windStrength.value = windMultiplier * 0.12;

        // Snow height: biome-specific (rock/cliff only)
        if (b.snow){
          styleRock.snowHeight.value = __lerp(b.snow.heightDry, b.snow.heightWet, v);
          // Ensure tint is active when snow is present
          styleRock.snowTintStrength.value = clamp01(b.snow.tintStrength);
        }

        return {
          biomeKey: _activeBiomeKey,
          biomeName: b.label || _activeBiomeKey,
          coverage: shared.grassCoverage.value,
          grassColor: shared.currentGrassColor.value.clone(),
          windMultiplier,
          lightIntensity: 1.4 - (0.4 * v),
          seasonName: v < 0.3 ? "Dry Season" : (v > 0.7 ? "Wet Season" : "Transitioning")
        };
      }

      function getSeasonValue(){
        return shared.seasonValue.value;
      }


      return {
        shared, style, styleRock, styleGrass,
        // preset API
        presets: SHADER_PRESET_LIBRARY,
        getActivePreset: ()=>_activeShaderPresetRock,
        getActivePresets: ()=>({ rock: _activeShaderPresetRock, grass: _activeShaderPresetGrass }),
        applyPreset: (name, target)=>applyShaderPreset(name, target || "rock"),
        __debugMaterials: ()=>__materialDebug.dump(),
        __clearMaterialDebug: ()=>__materialDebug.clear(),

                __addMaterialDebug: (role, material, extra)=>{
                  // Always-on: record a stable role->material mapping for the HUD.
                  __materialDebug.add(role, material, {
                    preset: (extra && extra.preset)
                      ? extra.preset
                      : (String(role).includes('grass') ? _activeShaderPresetGrass : _activeShaderPresetRock),
                    ...(extra||{})
                  });
                },

        makeUniformsForMesh,
        makeToonSurfaceMaterial,
        setSharedFromRendererSize,
        setTime,
        setLightDirWorld,
        setPointLight,
        disablePointLight,
        disableAllPointLights,
        
        // Biome + seasonal system
        setBiomeMode,
        getBiomeMode,
        getBiomeProfile,
        setSeasonValue,
        getSeasonValue,
      };
    })();
    /* ============================= IGNORE_SEARCH_END ============================= */


    
    // StylizedTerrainShader-backed materials (used conditionally by mode)
    const __cRock  = new THREE.Color(0x6a707c);
    const __cGrass = new THREE.Color(0x2d6f35);

    const _uRock  = globalThis.StylizedTerrainShader.makeUniformsForMesh(new THREE.Vector3(__cRock.r, __cRock.g, __cRock.b), 0.0, globalThis.StylizedTerrainShader.styleRock);
    const _uGrass = globalThis.StylizedTerrainShader.makeUniformsForMesh(new THREE.Vector3(__cGrass.r, __cGrass.g, __cGrass.b), 1.0, globalThis.StylizedTerrainShader.styleGrass);

    // Dirt material (dry earth base layer for seasonal system)
    const __cDirt = new THREE.Color(0.42, 0.32, 0.20); // brown earth
    const _uDirt = globalThis.StylizedTerrainShader.makeUniformsForMesh(new THREE.Vector3(__cDirt.r, __cDirt.g, __cDirt.b), 0.0, globalThis.StylizedTerrainShader.styleRock);


    // Bark material (tree trunks): based on dirt but slightly darker (two-tone toon)
    const __cBark = __cDirt.clone().multiplyScalar(0.85); // slightly darker than dirt
    const _uBark = globalThis.StylizedTerrainShader.makeUniformsForMesh(new THREE.Vector3(__cBark.r, __cBark.g, __cBark.b), 0.0, globalThis.StylizedTerrainShader.styleRock);

    const matCliffShaderGray   = globalThis.StylizedTerrainShader.makeToonSurfaceMaterial(_uRock,  false);
    globalThis.StylizedTerrainShader.__addMaterialDebug("rock/cliff", matCliffShaderGray, {grass:false});
    const matGroundShaderGreen = globalThis.StylizedTerrainShader.makeToonSurfaceMaterial(_uGrass, true);
    globalThis.StylizedTerrainShader.__addMaterialDebug("grass/top", matGroundShaderGreen, {grass:true});
    // Vertical walls: stone shading, but color-matched to the seasonal top color.
    // This keeps "dry vs wet season" color shifts consistent between top + vertical surfaces.
    const _uVertical = globalThis.StylizedTerrainShader.makeUniformsForMesh(__cRock, 0.0, globalThis.StylizedTerrainShader.styleRock);
    _uVertical.baseColor = _uVertical.currentGrassColor; // share the same color object (updated by season system)
    _uVertical.stoneIsotropic = { value: 1.0 };          // all-direction crumbly stone
    _uVertical.stoneMinFacingDot = { value: -1.0 };      // don't gate by facing direction
    const matVerticalStone = globalThis.StylizedTerrainShader.makeToonSurfaceMaterial(_uVertical, false);
    globalThis.StylizedTerrainShader.__addMaterialDebug("stone/vertical", matVerticalStone, {grass:false});
    // Depth-only occluder for cliff backfaces: hides sky holes between instanced rocks
    // without drawing a flat "housing" wall.
    const matCliffOccluder = new THREE.MeshBasicMaterial({ color: 0x000000 });
    matCliffOccluder.colorWrite = false;     // do not render color
    matCliffOccluder.depthWrite = true;      // but do write depth so it occludes gaps
    matCliffOccluder.depthTest = true;
    matCliffOccluder.polygonOffset = true;   // push slightly back to avoid z-fighting with rocks
    matCliffOccluder.polygonOffsetFactor = 1;
    matCliffOccluder.polygonOffsetUnits = 1;
    matCliffOccluder.userData = matCliffOccluder.userData || {};
    matCliffOccluder.userData.__noDispose = true;


    const matDirtShaderBrown = globalThis.StylizedTerrainShader.makeToonSurfaceMaterial(_uDirt, false);
    globalThis.StylizedTerrainShader.__addMaterialDebug("dirt/ground", matDirtShaderBrown, {grass:false});

    const matBarkShaderBrown = globalThis.StylizedTerrainShader.makeToonSurfaceMaterial(_uBark, false);
    matBarkShaderBrown.side = THREE.DoubleSide;
    globalThis.StylizedTerrainShader.__addMaterialDebug("bark/tree", matBarkShaderBrown, {grass:false});
    globalThis.__matBarkShaderBrown = matBarkShaderBrown; // used by Generators.tree

    for (const m of [matCliffShaderGray, matGroundShaderGreen, matDirtShaderBrown, matBarkShaderBrown]){
      m.userData = m.userData || {};
      m.userData.__noDispose = true;
    }

    /**
     * Add a mesh to a parent.
     * @param {THREE.Object3D} parent
     * @param {THREE.BufferGeometry} geo
     * @param {THREE.Material} baseMat
     */
    function addStylizedMesh(parent, geo, baseMat){
      const base = new THREE.Mesh(geo, baseMat);
      base.renderOrder = 1;
      parent.add(base);
      return base; // returned for optional transforms
    }

    let debugMode = "lit";
    let cliffDebugMode = "runs";
    let levels = null; // Global terrain levels array for vox export/import
    let useImportedLevels = false; // Flag to skip generation and use imported levels
    let importedVoxelGrid = null; // 3D grid storing which voxels exist (for arches/tunnels)
    let importedVoxelGridDims = { w: 0, h: 0, depth: 0 }; // Dimensions of voxel grid
    const currentDebugMat = ()=>{
      if (debugMode==="wire") return matWire;
      if (debugMode==="normal") return matNormal;
      return null;
    };

    function frameCameraToObject(object3d){
      const box = new THREE.Box3().setFromObject(object3d);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI/180);
      const dist = (maxDim/2) / Math.tan(fov/2);

      camera.position.copy(center.clone().add(new THREE.Vector3(dist*0.9, dist*0.75, dist*0.9)));
      camera.near = Math.max(0.1, dist/200);
      camera.far = Math.max(2000, dist*20);
      camera.updateProjectionMatrix();

      controls.target.copy(center);
      controls.update();
    }

    function readParams(){
      const w = Math.max(16, parseInt($val("w")||"64",10));
      const h = Math.max(16, parseInt($val("h")||"64",10));
      const p = {
        seed: String($val("seed") || "seed"),
        w, h,
        tileSize: Math.max(0.25, parseFloat($val("tile")||"1")),
        levelHeight: Math.max(0.25, parseFloat($val("stepH")||"1")),
        maxLevel: Math.max(1, parseInt($val("maxLvl")||"6",10)),
        rectCount: Math.max(1, parseInt($val("rects")||"18",10)),
        rampCount: Math.max(0, parseInt($val("ramps")||"28",10)),
        vertMode: String($val("vertMode") || "mixed"),
        vertRampFrac: clamp(parseFloat(($("rampFrac")?.value ?? "0.6")), 0, 1),
        groundAmp: Math.max(0, parseFloat($val("gAmp")||"0.12")),
        groundScale: Math.max(0.01, parseFloat($val("gScale")||"0.11")),
        groundShellOn: $chk("groundShellOn"),
        groundShellVox: Math.max(0, parseFloat($val("groundShellVox")||"1.0")),
        topMat: String($val("topMat") || "grass"),
        grassThk: Math.max(0, parseFloat($val("grassThk")||"0.14")),
        cliffFacing: String($val("cliffFacing") || "ANY"),
        lumpAmp: Math.max(0, parseFloat($val("lumpAmp")||"0.10")),
        lumpScale: Math.max(0.01, parseFloat($val("lumpScale")||"0.55")),
        muffinLift: Math.max(0, parseFloat($val("muffLift")||"0.18")),
        muffinOver: Math.max(0, parseFloat($val("muffOver")||"0.14")),
        muffinRad01: clamp(parseFloat($val("muffRad")||"0.35"), 0.05, 0.49),
        round: Math.max(0, parseFloat($val("round")||"0.18")),
        wallRough: Math.max(0, parseFloat($val("wallRough")||"1.0")),
        grassOn: $chk("grassOn"),
        grassDen: Math.max(0, parseFloat($val("grassDen")||"0")),
        grassH: Math.max(0.0, parseFloat($val("grassHeight")||"0.27")),
        grassR: Math.max(0.01, parseFloat($val("grassR")||"0.07")),
        grassLeanDeg: Math.max(0, parseFloat($val("grassLean")||"22")),
        grassSubdiv: Math.max(0, Math.min(16, parseInt($val("grassSubdiv")||"1",10))),
      
        cliffVar: Math.max(0, parseFloat($val("cliffVar")||"0")),
        cliffVarScale: Math.max(0.01, parseFloat($val("cliffVarScale")||"0.18")),
        cliffVarBoost: Math.max(0, parseFloat($val("cliffVarBoost")||"1.0")), // used by cliffDeltaAt()

        // Wind direction from the 2D pad (XZ only; ignores up/down). Stored on the pad so it survives regen.
        windX: parseFloat($("windPad")?.dataset?.wx || "0"),
        windY: 0,
        windZ: parseFloat($("windPad")?.dataset?.wz || "0"),
        windStrength: parseFloat($val("windStrength")||"0.12"),
        grassUpAxis: String($("grassUpAxis")?.value || "Y"),
      
        // Tree spawn mapping (uses voxel types FOREST / TREE_BARRIER)
        treeUnitScale: Math.max(0.01, parseFloat($val("treeUnitScale") || "1")),
        treeForestDensity: Math.max(0, parseFloat($val("treeForestDensity") || "0.10")),
        treeBarrierDensity: Math.max(0, parseFloat($val("treeBarrierDensity") || "0.35")),
        treeSpawnOffsetFrac: clamp(parseFloat(($("treeSpawnOffsetFrac")?.value ?? "0.45")), 0, 0.5),
        treeRotJitterDeg: clamp(parseFloat(($("treeRotJitterDeg")?.value ?? "360")), 0, 360),
        treeScaleJitterFrac: clamp(parseFloat(($("treeScaleJitterFrac")?.value ?? "0.25")), 0, 1),
        // Road bricks (instanced cobbles on road voxels)
        roadBricksDensity: Math.max(0, parseFloat($val("roadBricksDensity") || "2.0")),
        roadBricksSizeFrac: clamp(parseFloat(($("roadBricksSizeFrac")?.value ?? "0.26")), 0.05, 1.0),
};
      return p;
    }
    
    // Simple string hash for seeding (kept for potential future use)
    function hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return Math.abs(hash);
    }

    let root = null;
    let cliffRocksGeom = null;
    let grassGeom = null;
    let waterMesh = null;
    const WATER_LAYER = 2; // Used for water mask rendering (shoreline/intersection outlines)
    globalThis.__WATER_LAYER = WATER_LAYER;

    function disposeObject(obj){
      if (!obj) return;
      obj.traverse((n)=>{
        if (n.isMesh){
          if (n.geometry && !(n.geometry.userData && n.geometry.userData.__noDispose)) {
            n.geometry.dispose?.();
          }
          if (n.material){
            const disposeOne = (m)=>{
              if (!m) return;
              if (m.userData && m.userData.__noDispose) return; // global/reused materials
              m.dispose?.();
            };
            if (Array.isArray(n.material)) n.material.forEach(disposeOne);
            else disposeOne(n.material);
          }
        }
      });
    }

        // ============================================================================
    // TREE PRESET (preview + persistence)
    // ============================================================================
    const __TREE_PRESET_STORAGE_KEY = "HHIM_treePreset_v1";
    globalThis.__treePresetOverride = null; // user-loaded preset overrides; persisted to localStorage
    globalThis.__treePreset = null;         // merged preset used by Tree Preview

    function __cloneJson(obj){
      // Tree presets are flat objects; JSON clone keeps them serializable for export.
      try{ return JSON.parse(JSON.stringify(obj)); }catch(_e){ return obj; }
    }

    function __getTreeDefaults(){
      try{
        const g = globalThis.Generators?.get?.("tree");
        return g?.defaults ? __cloneJson(g.defaults) : {};
      }catch(_e){
        return {};
      }
    }

    function __mergeTreePreset(defaults, override){
      const out = { ...(defaults || {}) };
      if (override && typeof override === "object"){
        for (const [k, v] of Object.entries(override)){
          out[k] = v;
        }
      }
      return out;
    }

    function __loadTreePresetOverride(){
      try{
        const raw = localStorage.getItem(__TREE_PRESET_STORAGE_KEY);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return null;
        return obj;
      }catch(_e){
        return null;
      }
    }

    function __saveTreePresetOverride(obj){
      try{
        if (!obj){
          localStorage.removeItem(__TREE_PRESET_STORAGE_KEY);
          return;
        }
        localStorage.setItem(__TREE_PRESET_STORAGE_KEY, JSON.stringify(obj));
      }catch(_e){}
    }

    function __refreshTreePreset(){
      const defaults = __getTreeDefaults();
      globalThis.__treePreset = __mergeTreePreset(defaults, globalThis.__treePresetOverride);
    }

    // Init now (tree generator is already registered above this point).
    globalThis.__treePresetOverride = __loadTreePresetOverride();
    __refreshTreePreset();

    // ============================================================================
    // TREE PREVIEW (standalone generator; toggled from Actions tab)
    // ============================================================================
    let treePreviewEnabled = true; // used by #treeToggle and regenerate()
    let treePreviewObj = null;      // current preview group (disposed/rebuilt)

    function removeTreePreview(){
      if (!treePreviewObj) return;
      try{ treePreviewObj.parent?.remove(treePreviewObj); }catch(_e){}
      disposeObject(treePreviewObj);
      treePreviewObj = null;
    
      // Also clear any road bricks preview attached to the old root.
      if (roadBricksObj){
        try{ roadBricksObj.parent?.remove(roadBricksObj); }catch(_e){}
        disposeObject(roadBricksObj);
        roadBricksObj = null;
      }
}

    function rebuildTreePreview(p){
  removeTreePreview();

  if (!globalThis.Generators?.get?.("tree")){
    hudPush("Tree preview: generator not registered");
    return;
  }

  const tile = Math.max(0.01, p.tileSize);
  const unitScale = Math.max(0.01, Number.isFinite(p.treeUnitScale) ? p.treeUnitScale : 1.0);

  // Build one base tree (shared geometry/material); instances are clones with transforms.
  const baseScale = tile * 1.25 * unitScale;
  const baseTree = globalThis.Generators.make("tree", globalThis.__treePreset || null, p.seed + "::treeBase", baseScale);

  const out = new THREE.Group();
  out.name = "treeSpawnPreview";

  // Collect spawn columns from voxel mask types (areas, not literal placement).
  let spawnColumns = null;
  try{
    spawnColumns = [];
    if (typeof ensureVoxelGrid === "function" && ensureVoxelGrid()){
      const { w, h, depth } = importedVoxelGridDims;
      const WH = w * h;

      for (let z = 0; z < h; z++){
        for (let x = 0; x < w; x++){
          const idx2d = z * w + x;

          // Prefer the terrain surface height if available (cheaper than scanning full depth)
          let topY = depth - 1;
          if (levels && levels.length === WH){
            topY = Math.min(depth - 1, Math.max(0, levels[idx2d] - 1));
          }

          let t = 0;
          for (let y = topY; y >= 0; y--){
            const idx3d = y * WH + z * w + x;
            t = importedVoxelGrid[idx3d] || 0;
            if (t !== 0 && t !== VOXEL_TYPES.EMPTY) break;
          }

          if (t === VOXEL_TYPES.FOREST || t === VOXEL_TYPES.TREE_BARRIER){
            spawnColumns.push({ x, z, t });
          }
        }
      }
    }
  }catch(_e){
    spawnColumns = null;
  }

  const rng = makeRng(p.seed + "::treeSpawnRng");
  const offsetFrac = clamp(Number.isFinite(p.treeSpawnOffsetFrac) ? p.treeSpawnOffsetFrac : 0.45, 0, 0.5);
  const rotJDeg = clamp(Number.isFinite(p.treeRotJitterDeg) ? p.treeRotJitterDeg : 360, 0, 360);
  const rotJRad = THREE.MathUtils.degToRad(rotJDeg);
  const scaleJ = clamp(Number.isFinite(p.treeScaleJitterFrac) ? p.treeScaleJitterFrac : 0.25, 0, 1);

  // Safety cap so we don't accidentally freeze on mobile.
  const MAX_TREES = 900;

  let treesPlaced = 0;
  let maskedCols = 0;

  const placeOneTreeAtWorld = (wx, wz, kindTag)=>{
    if (treesPlaced >= MAX_TREES) return false;

    const inst = baseTree.clone(true);

    // Random yaw and size offsets (requested).
    let yaw = 0;
    if (rotJDeg >= 360 - 1e-6) yaw = rng() * Math.PI * 2;
    else yaw = (rng() * 2 - 1) * rotJRad;

    const sMul = 1 + (rng() * 2 - 1) * scaleJ;

    // Snap to terrain height (grid sample)
    let wy = 0;
    if (levels && levels.length === p.w * p.h){
      const ix = clamp(Math.floor(wx / tile), 0, p.w - 1);
      const iz = clamp(Math.floor(wz / tile), 0, p.h - 1);
      wy = levels[iz * p.w + ix] * p.levelHeight;
    }

    inst.position.set(wx, wy + 0.02, wz);
    inst.rotation.y = yaw;
    inst.scale.multiplyScalar(Math.max(0.01, sMul));

    inst.userData.__treeKind = kindTag;

    out.add(inst);
    treesPlaced++;
    return true;
  };

  if (spawnColumns && spawnColumns.length > 0){
    maskedCols = spawnColumns.length;

    for (let i = 0; i < spawnColumns.length; i++){
      const col = spawnColumns[i];
      const isBarrier = col.t === VOXEL_TYPES.TREE_BARRIER;

      const density = isBarrier
        ? (Number.isFinite(p.treeBarrierDensity) ? p.treeBarrierDensity : 0.35)
        : (Number.isFinite(p.treeForestDensity) ? p.treeForestDensity : 0.10);

      // Treat density as expected trees per tile.
      const baseCount = Math.floor(density);
      const frac = density - baseCount;
      let count = baseCount + (rng() < frac ? 1 : 0);

      // Allow slightly more "clumped" feel for barriers
      if (isBarrier && rng() < 0.25) count += 1;

      if (count <= 0) continue;

      const cx = (col.x + 0.5) * tile;
      const cz = (col.z + 0.5) * tile;

      for (let k = 0; k < count; k++){
        const wx = cx + (rng() * 2 - 1) * offsetFrac * tile;
        const wz = cz + (rng() * 2 - 1) * offsetFrac * tile;

        if (!placeOneTreeAtWorld(wx, wz, isBarrier ? "treebarrier" : "forest")){
          hudPush(`Tree preview: capped at ${MAX_TREES} trees (mask cols=${maskedCols})`);
          break;
        }
      }

      if (treesPlaced >= MAX_TREES) break;
    }
  } else {
    // Fallback: single tree at center (old behavior).
    const cx = p.w * tile * 0.5;
    const cz = p.h * tile * 0.5;
    placeOneTreeAtWorld(cx, cz, "single");
  }

  treePreviewObj = out;
  (root || scene).add(treePreviewObj);

  if (maskedCols > 0){
    hudPush(`Tree preview: maskCols=${maskedCols} trees=${treesPlaced} (forest=${p.treeForestDensity}, barrier=${p.treeBarrierDensity})`);
  }

  const w = baseTree.children?.[0]?.userData?.__winding;
  if (w && typeof w.confidence === "number"){
    hudPush(`Tree preview base: winding=${w.flipped ? "flipped" : "ok"} conf=${Math.round(w.confidence*100)}%`);
  }
}

    function syncTreePreview(p){
      if (!treePreviewEnabled){
        removeTreePreview();
        return;
      }
      rebuildTreePreview(p);
    }
    // ============================================================================
    // ROAD BRICKS (instanced cobbles spawned on road voxels)
    // ============================================================================
    let roadBricksEnabled = true; // used by #roadBricksToggle and regenerate()
    let roadBricksObj = null;      // current instanced mesh group (disposed/rebuilt)

    let roadDebugEnabled = false; // used by #roadDebugToggle and regenerate()
    let roadDebugObj = null;      // instanced overlay planes (disposed/rebuilt)
    let lastRoadTileCount = 0;    // used by HUD/debug


    // Road recipe (controls cobble placement pattern on road voxels)
    // Default comes from uploaded roadrecipe1.json.
    const DEFAULT_ROAD_BRICKS_RECIPE = {"version":1,"algoVersion":1,"seed":"seed-001","axisUp":"Y","model":{"uri":"rock_rock-1 (2).glb","nodeName":"rock"},"preTransform":{"kind":"trs","translate":[0,0,0],"rotateDegXYZ":[0,180,0],"scale":[1,1,1]},"density":{"value01":0.75,"overlapFrac":0.1,"note":"effectiveGap = baseGap + (0.5-density)*2*overlapFrac*unit"},"settings":{"kind":"road","length":14.5,"width":8,"unitSize":{"x":1,"y":1,"z":1},"gapBase":{"x":0.05,"y":0.05,"z":0.05},"gapEffective":{"x":0,"y":0,"z":0},"packing":{"mode":"grid","stepMultiplier":1},"planarJitter":{"x":0.311,"z":0.63},"random":{"rotationDeg":{"x":{"min":-6,"max":6},"y":{"min":0,"max":0},"z":{"min":-6,"max":6}},"scale":{"x":{"min":0.9,"max":1.1},"y":{"min":0.9,"max":1.1},"z":{"min":0.9,"max":1.1}},"translate":{"x":{"min":0.052,"max":0.088},"y":{"min":-0.01,"max":0.01},"z":{"min":-0.02,"max":0.02}}},"crown":{"enabled":true,"height":0.08}}};

    let roadBricksRecipe = DEFAULT_ROAD_BRICKS_RECIPE; // used by rebuildRoadBricks()
    let roadBricksRecipeLabel = "built-in"; // shown in UI (roadBricksRecipeStatus)

    function setRoadBricksRecipeStatus(){
      const btn = $("roadBricksRecipeBtn");
      const pill = $("roadBricksRecipeStatus");
      const seed = roadBricksRecipe?.seed ? String(roadBricksRecipe.seed) : "(none)";
      if (btn) btn.textContent = "Road Recipe: " + (roadBricksRecipe ? roadBricksRecipeLabel : "none");
      if (pill) pill.textContent = roadBricksRecipe ? seed : "none";
    }

    function removeRoadBricks(){
      if (!roadBricksObj) return;
      try{ roadBricksObj.parent?.remove(roadBricksObj); }catch(_e){}
      disposeObject(roadBricksObj);
      roadBricksObj = null;
    }
    
    function getRoadBricksYLift(){
      // used by rebuildRoadBricks() and rebuildRoadDebug()
      const v = Number($("roadBricksYLift")?.value);
      return isFinite(v) ? v : 0.03;
    }

    function gatherRoadTiles(p){
      // Returns top-surface road tiles derived from imported voxel grid.
      // Each tile has world center (wx, wy, wz) and voxel type id (type).
      const tiles = [];
      if (!importedVoxelGrid || !importedVoxelGridDims?.w) return tiles;

      const w = importedVoxelGridDims.w|0;
      const h = importedVoxelGridDims.h|0;
      const depth = importedVoxelGridDims.depth|0;
      const tileSize = Number(p?.tileSize) || 1;
      const levelH = Number(p?.levelHeight) || 1;

      const isRoadVoxel = (t)=> (t >= 20 && t <= 30); // ROAD_* ids

      for (let z=0; z<h; z++){
        for (let x=0; x<w; x++){
          let topY = -1;
          let topT = 0;
          for (let y=depth-1; y>=0; y--){
            const idx3d = y*(w*h) + z*w + x;
            const t = importedVoxelGrid[idx3d];
            if (isVoxelSolid(t)){
              topY = y;
              topT = t;
              break;
            }
          }
          if (topY < 0) continue;
          if (!isRoadVoxel(topT)) continue;

          tiles.push({
            x, z,
            y: topY,
            t: topT,
            wx: (x + 0.5) * tileSize,
            wy: (topY + 1) * levelH,
            wz: (z + 0.5) * tileSize,
            type: topT
          });
        }
      }
      return tiles;
    }

    function removeRoadDebug(){
      if (!roadDebugObj) return;
      try{ (rootScene || scene || window.scene)?.remove?.(roadDebugObj); }catch(_e){}
      disposeObject(roadDebugObj);
      roadDebugObj = null;
    }

    function rebuildRoadDebug(p){
      removeRoadDebug();
      if (!roadDebugEnabled) return;

      const tiles = gatherRoadTiles(p);
      lastRoadTileCount = tiles.length;

      if (!tiles.length){
        hudPush("Road Debug: 0 tiles (no ROAD_* voxels detected).");
        return;
      }

      const tileSize = Number(p?.tileSize) || 1;
      const yLift = getRoadBricksYLift();

      const geo = new THREE.PlaneGeometry(tileSize, tileSize);
      const mat = new THREE.MeshBasicMaterial({
        color: 0xff00ff,
        transparent: true,
        opacity: 0.25,
        depthWrite: false
      });

      const inst = new THREE.InstancedMesh(geo, mat, tiles.length);
      inst.frustumCulled = false;
      inst.renderOrder = 999;

      const rot = new THREE.Matrix4().makeRotationX(-Math.PI/2);
      const tmp = new THREE.Matrix4();
      for (let i=0; i<tiles.length; i++){
        const t = tiles[i];
        tmp.makeTranslation(t.wx, t.wy + yLift + 0.01, t.wz);
        tmp.multiply(rot);
        inst.setMatrixAt(i, tmp);
      }
      inst.instanceMatrix.needsUpdate = true;

      const out = new THREE.Group();
      out.name = "roadDebugGroup";
      out.add(inst);

      roadDebugObj = out;
      (rootScene || scene || window.scene)?.add?.(out);

      hudPush(`Road Debug: tiles=${tiles.length}`);
    }

    function syncRoadDebug(p){
      if (!roadDebugEnabled){
        removeRoadDebug();
        return;
      }
      rebuildRoadDebug(p);
    }

function rebuildRoadBricks(p){
      removeRoadBricks();

      if (!roadBricksEnabled) return;

      // Requires voxel grid. Roads are voxel types 20-30 (ROAD_* and ROAD_RAMP_*).
      if (typeof ensureVoxelGrid !== "function" || !ensureVoxelGrid()){
        hudPush("Road bricks: need voxel grid (import .vox or generate terrain first).");
        return;
      }

      const { w, h, depth } = importedVoxelGridDims;
      if (!w || !h || !depth){
        hudPush("Road bricks: voxel grid dims missing.");
        return;
      }

      const voxelData = importedVoxelGrid; // used by roadAxisForTile() and neighbor checks
      const WH = w * h;

      // Helper: road voxel types range (ROAD_* and ROAD_RAMP_* are 20-30)
      const isRoadType = (t)=> (t >= VOXEL_TYPES.ROAD_NS && t <= VOXEL_TYPES.ROAD_RAMP_W);

      const roadTiles = gatherRoadTiles(p);
      lastRoadTileCount = roadTiles.length;
      if (roadTiles.length === 0){
        hudPush("Road bricks: 0 road tiles (need ROAD_* voxel IDs 20-30 on the top surface).");
        return;
      }

      const tile = Math.max(0.01, p.tileSize);
      const stepH = Math.max(0.01, p.levelHeight);
      const yLift = getRoadBricksYLift(); // prevents z-fighting with road top faces

      // Pattern settings from road recipe (preferred) with fallback to old random scatter.
      const recipe = roadBricksRecipe && roadBricksRecipe.settings?.kind === "road" ? roadBricksRecipe : null;

      // UI density is treated as a multiplier over the recipe grid:
      //  - 0..1 thins (keep probability)
      //  - 1..N does N passes (with different seeds) + fractional final pass
      const densityMult = Math.max(0, Number.isFinite(p.roadBricksDensity) ? p.roadBricksDensity : 1.0);
      if (densityMult <= 0){
        hudPush("Road bricks: density is 0 (nothing to spawn).");
        return;
      }

      const sizeFrac = clamp(Number.isFinite(p.roadBricksSizeFrac) ? p.roadBricksSizeFrac : 0.26, 0.05, 1.0);
      const baseSize = Math.max(0.03, tile * sizeFrac);

      // Build one shared cobble geometry (from the rock generator) so instancing is cheap.
      let cobbleGeo = null;
      try{
        const rockGen = (typeof Generators !== "undefined" && Generators?.get) ? Generators.get("rock") : null;
        if (!rockGen) throw new Error("rock generator missing");
        cobbleGeo = rockGen.make({ preset: WALL_ROAD_PRESETS.ROUGH_BRICK_ROCK, baseSize }, p.seed + "::roadCobbleGeo", 1.0);
      }catch(e){
        hudPush("Road bricks: failed to build cobble geo: " + (e?.message || String(e)));
        return;
      }

      // Material: simple lit stone (kept separate from terrain shader for instancing safety).
      const cobbleMat = new THREE.MeshStandardMaterial({
        color: 0x6f6f6f,
        roughness: 0.95,
        metalness: 0.0
      });
      cobbleMat.userData = cobbleMat.userData || {};
      cobbleMat.userData.__isRoadBrickMaterial = true;

      const maxInstances = 20000; // mobile safety
      const inst = new THREE.InstancedMesh(cobbleGeo, cobbleMat, maxInstances);
      inst.frustumCulled = false;

      // Local helpers (kept inside to avoid name collisions with generator islands)
      const degToRad = (d)=>d * Math.PI / 180;
      function preTRSToMatrix(preT, preRdeg, preS){
        const t = new THREE.Vector3(preT[0], preT[1], preT[2]);
        const r = new THREE.Euler(degToRad(preRdeg[0]), degToRad(preRdeg[1]), degToRad(preRdeg[2]), "XYZ");
        const s = new THREE.Vector3(preS[0], preS[1], preS[2]);
        const m = new THREE.Matrix4();
        m.compose(t, new THREE.Quaternion().setFromEuler(r), s);
        return m;
      }
      function rr(rng, min, max){ return min + rng() * (max - min); }

      function safeRangeObj(obj, dmin, dmax){
        const mn = Number.isFinite(obj?.min) ? obj.min : dmin;
        const mx = Number.isFinite(obj?.max) ? obj.max : dmax;
        return mn <= mx ? {min:mn, max:mx} : {min:mx, max:mn};
      }

      function applyRandomTRS_fn(rng, random){
        const rotX = safeRangeObj(random?.rotationDeg?.x, 0, 0);
        const rotY = safeRangeObj(random?.rotationDeg?.y, 0, 0);
        const rotZ = safeRangeObj(random?.rotationDeg?.z, 0, 0);
        const scX = safeRangeObj(random?.scale?.x, 1, 1);
        const scY = safeRangeObj(random?.scale?.y, 1, 1);
        const scZ = safeRangeObj(random?.scale?.z, 1, 1);
        const trX = safeRangeObj(random?.translate?.x, 0, 0);
        const trY = safeRangeObj(random?.translate?.y, 0, 0);
        const trZ = safeRangeObj(random?.translate?.z, 0, 0);

        return {
          t: [ rr(rng, trX.min, trX.max), rr(rng, trY.min, trY.max), rr(rng, trZ.min, trZ.max) ],
          r: [ degToRad(rr(rng, rotX.min, rotX.max)), degToRad(rr(rng, rotY.min, rotY.max)), degToRad(rr(rng, rotZ.min, rotZ.max)) ],
          s: [ rr(rng, scX.min, scX.max), rr(rng, scY.min, scY.max), rr(rng, scZ.min, scZ.max) ],
        };
      }

      // Determine a reasonable axis (X or Z) for a road tile, based on neighbors.
      function roadAxisForTile(x, z){
        const isRoadTop = (xx, zz)=>{
          if (xx < 0 || xx >= w || zz < 0 || zz >= h) return false;
          const idx2d = zz * w + xx;
          let ty = depth - 1;
          if (levels && levels.length === WH){
            ty = Math.min(depth - 1, Math.max(0, levels[idx2d] - 1));
          }
          while (ty >= 0){
            const t = voxelData[idx2d + ty * WH];
            if (t !== VOXEL_TYPES.AIR) return isRoadType(t);
            ty--;
          }
          return false;
        };

        const hasE = isRoadTop(x + 1, z);
        const hasW = isRoadTop(x - 1, z);
        const hasN = isRoadTop(x, z - 1);
        const hasS = isRoadTop(x, z + 1);

        const ew = (hasE || hasW);
        const ns = (hasN || hasS);

        if (ew && !ns) return "X";
        if (ns && !ew) return "Z";
        // intersections/corners: default to X but we‚Äôll do a light 2nd pass on Z
        return "X";
      }

      const tmpM = new THREE.Matrix4();
      const tmpPos = new THREE.Vector3();
      const tmpQuat = new THREE.Quaternion();
      const tmpScl = new THREE.Vector3();
      const tmpQYaw = new THREE.Quaternion();
      const tmpQrt = new THREE.Quaternion();

      const preM = recipe
        ? preTRSToMatrix(
            recipe?.preTransform?.translate ?? [0,0,0],
            recipe?.preTransform?.rotateDegXYZ ?? [0,0,0],
            recipe?.preTransform?.scale ?? [1,1,1]
          )
        : new THREE.Matrix4().identity();

      let wi = 0;

      if (recipe){
        const s = recipe.settings || {};
        const unit = s.unitSize || {};
        const gap = (s.gapEffective || s.gapBase || {});
        const planar = s.planarJitter || {};
        const crown = s.crown || {};
        const packing = s.packing || {};
        const randCfg = s.random || {};

        const stepMult = Number.isFinite(packing.stepMultiplier) ? packing.stepMultiplier : 1.0;

        const stepU = Math.max(0.02, ((Number.isFinite(unit.x) ? unit.x : 1.0) + (Number.isFinite(gap.x) ? gap.x : 0.0))) * stepMult;
        const stepV = Math.max(0.02, ((Number.isFinite(unit.z) ? unit.z : 1.0) + (Number.isFinite(gap.z) ? gap.z : 0.0))) * stepMult;

        const jitterU = Math.max(0, Number.isFinite(planar.x) ? planar.x : 0.0);
        const jitterV = Math.max(0, Number.isFinite(planar.z) ? planar.z : 0.0);

        const crownOn = !!crown.enabled && Number.isFinite(crown.height) && Number(crown.height) !== 0;
        const crownH = crownOn ? Number(crown.height) : 0;
        const crownFalloff = Math.max(1e-6, Number.isFinite(crown.falloff) ? crown.falloff : 1.0);

        // UI density is treated as a multiplier over this per-tile grid:
        //  - 0..1 thins (keep probability)
        //  - 1..N does N passes + fractional final pass
        const fullPasses = Math.floor(densityMult);
        const fracPass = densityMult - fullPasses;
        const totalPasses = fullPasses + (fracPass > 0 ? 1 : 0);

        const preM = (recipe.preTransform && recipe.preTransform.kind === "trs")
          ? preTRSToMatrix(
              recipe.preTransform.translate || [0,0,0],
              recipe.preTransform.rotateDeg || [0,0,0],
              recipe.preTransform.scale || [1,1,1]
            )
          : new THREE.Matrix4();

        const tmpRot = new THREE.Matrix4();
        const tmpScl = new THREE.Matrix4();

        for (const col of roadTiles){
          const tileMinX = col.x * tile;
          const tileMinZ = col.z * tile;

          // Pack a small grid INSIDE the tile so narrow roads always get cobbles.
          const nU = Math.max(1, Math.floor(tile / stepU));
          const nV = Math.max(1, Math.floor(tile / stepV));
          const totalU = nU * stepU;
          const totalV = nV * stepV;
          const startU = tileMinX + (tile - totalU) * 0.5 + stepU * 0.5;
          const startV = tileMinZ + (tile - totalV) * 0.5 + stepV * 0.5;

          for (let pass = 0; pass < totalPasses && wi < maxInstances; pass++){
            const isFrac = (pass >= fullPasses);
            const keepProb = (densityMult < 1) ? densityMult : (isFrac ? fracPass : 1.0);

            // deterministic per-tile+pass RNG
            const rng = makeRng(p.seed + `::roadRecipe:${recipe.seed}:${col.x},${col.z}:${pass}`);

            for (let iv = 0; iv < nV && wi < maxInstances; iv++){
              for (let iu = 0; iu < nU && wi < maxInstances; iu++){
                if (keepProb < 1.0 && rng() > keepProb) continue;

                const rt = applyRandomTRS_fn(rng, randCfg);

                const u = startU + iu * stepU + rr(rng, -jitterU, jitterU) + (rt.t?.[0] || 0);
                const v = startV + iv * stepV + rr(rng, -jitterV, jitterV) + (rt.t?.[2] || 0);

                const dx = (u - (tileMinX + tile * 0.5));
                const dz = (v - (tileMinZ + tile * 0.5));
                const r01 = Math.min(1, Math.sqrt(dx*dx + dz*dz) / Math.max(1e-6, tile * 0.5));
                const crownY = crownOn ? (crownH * Math.pow(Math.max(0, 1.0 - r01), crownFalloff)) : 0;

                const y = (col.y + 1) * stepH + yLift + crownY + (rt.t?.[1] || 0);

                tmpM.makeTranslation(u, y, v);

                // Keep rotations small and mostly yaw-based in recipe. Still honor full XYZ if provided.
                const eul = new THREE.Euler(rt.r?.[0] || 0, rt.r?.[1] || 0, rt.r?.[2] || 0, "XYZ");
                tmpRot.makeRotationFromEuler(eul);

                tmpScl.makeScale(
                  baseSize * (rt.s?.[0] || 1),
                  Math.max(0.02, baseSize * 0.7 * (rt.s?.[1] || 1)),
                  baseSize * (rt.s?.[2] || 1)
                );

                tmpM.multiply(tmpRot);
                tmpM.multiply(tmpScl);
                tmpM.multiply(preM);

                inst.setMatrixAt(wi++, tmpM);
              }
            }
          }
        }

      } else {
        // Fallback: old scatter (kept so the tool still works if recipe is removed)
        const offsetFrac = 0.42; // tile offset jitter range
        const maxTiltDeg = 10; // subtle tilt for organic feel
        const maxTiltRad = THREE.MathUtils.degToRad(maxTiltDeg);

        // Approximate instances based on density multiplier: 2 stones/tile baseline
        const baseline = 2;
        const total = Math.min(maxInstances, Math.ceil(roadTiles.length * baseline * densityMult));

        for (let i = 0; i < roadTiles.length && wi < total; i++){
          const col = roadTiles[i];

          // deterministic per-tile RNG so the pattern is stable even if iteration order changes
          const rng = makeRng(p.seed + `::roadBricks:${col.x},${col.z},${col.y}`);

          // count per tile based on density multiplier
          let count = Math.max(1, Math.floor(baseline * densityMult + (rng() < (baseline * densityMult % 1) ? 1 : 0)));
          if (rng() < 0.20) count += 1;

          const cx = (col.x + 0.5) * tile;
          const cz = (col.z + 0.5) * tile;
          const cy = (col.y + 1) * stepH + yLift;

          for (let k = 0; k < count && wi < total; k++){
            const ox = (rng() * 2 - 1) * tile * offsetFrac;
            const oz = (rng() * 2 - 1) * tile * offsetFrac;

            const rx = (rng() * 2 - 1) * maxTiltRad;
            const rz = (rng() * 2 - 1) * maxTiltRad;
            const ry = rng() * Math.PI * 2;

            const sc = 0.9 + rng() * 0.3;
            tmpPos.set(cx + ox, cy + rr(rng,-0.01,0.01), cz + oz);
            tmpQuat.setFromEuler(new THREE.Euler(rx, ry, rz, "XYZ"));
            tmpScl.set(sc, sc, sc);

            tmpM.compose(tmpPos, tmpQuat, tmpScl);
            inst.setMatrixAt(wi++, tmpM);
          }
        }

        inst.count = wi;
        inst.instanceMatrix.needsUpdate = true;
        hudPush(`Road bricks: fallback scatter | instances=${wi}${wi>=maxInstances?" (capped)":""}`);
      }

      const out = new THREE.Group();
      out.name = "roadBricksGroup";
      out.add(inst);

      roadBricksObj = out;
      (rootScene || scene || window.scene)?.add?.(out);
    }



    function syncRoadBricks(p){
      if (!roadBricksEnabled){
        removeRoadBricks();
        return;
      }
      rebuildRoadBricks(p);
    }

    // ============================================================================
    // GRASS TUFT GENERATION SYSTEM (Sonic/Goku Style Spiky Tufts)
    // ============================================================================
    
    /**
     * Create a chunky grass spike/tuft (like Sonic/Goku hair)
     * Returns a BufferGeometry for a single tuft (will be instanced)
     */
    function createGrassTuftMesh(params) {
      const {
        width = 0.15,        // Chunky width (3x thicker than blade)
        height = 0.8,
        curve = 0.4,
        segments = 4,
        taper = 0.6          // How much it tapers to a point
      } = params;
      
      const positions = [];
      const normals = [];
      const uvs = [];
      const indices = [];
      
      // Create spike vertices (chunky base, tapered tip, curved)
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const y = t * height;
        
        // Aggressive taper: wide at bottom, sharp point at top
        const widthScale = 1.0 - Math.pow(t, 1.5) * taper;
        const w = width * widthScale;
        
        // Strong curve: spike bends forward dramatically
        const curvePower = t * t * t; // Cubic for dramatic bend
        const xOffset = curvePower * curve * height;
        
        // Create triangular cross-section for spiky look
        // Three vertices per layer: left, tip (front), right
        const frontX = xOffset;
        const leftX = -w/2 + xOffset * 0.8;
        const rightX = w/2 + xOffset * 0.8;
        
        // Front vertex (pointy tip direction)
        positions.push(frontX, y, w * 0.3);
        normals.push(0, 0.5, 0.5);
        uvs.push(0.5, t);
        
        // Left vertex
        positions.push(leftX, y, -w * 0.2);
        normals.push(-0.5, 0.3, -0.3);
        uvs.push(0, t);
        
        // Right vertex
        positions.push(rightX, y, -w * 0.2);
        normals.push(0.5, 0.3, -0.3);
        uvs.push(1, t);
      }
      
      // Create triangles (connecting the three sides)
      for (let i = 0; i < segments; i++) {
        const base = i * 3;
        const nextBase = (i + 1) * 3;
        
        // Front-left face
        indices.push(base, nextBase, base + 1);
        indices.push(base + 1, nextBase, nextBase + 1);
        
        // Front-right face
        indices.push(base, base + 2, nextBase);
        indices.push(base + 2, nextBase + 2, nextBase);
        
        // Back face (left to right)
        indices.push(base + 1, nextBase + 1, base + 2);
        indices.push(base + 2, nextBase + 1, nextBase + 2);
      }
      
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geo.setIndex(indices);
      geo.computeVertexNormals(); // Recalculate for proper lighting
      
      return geo;
    }
    
    /**
     * Simple seeded random number generator
     */
    function seededRandom(seed) {
      let state = seed;
      return function() {
        state = (state * 1664525 + 1013904223) % 4294967296;
        return state / 4294967296;
      };
    }
    
    /**
     * Generate grass tuft instances for a tile surface
     * Returns an InstancedMesh with randomized tuft positions/rotations
     */
    function createGrassInstancesForSurface(surfaceGeo, params) {
      const {
        bladesPerTile = 40,       // Fewer tufts (they're bigger)
        bladeWidth = 0.15,        // Chunky width
        bladeHeight = 0.8,        // Taller spikes
        bladeHeightVar = 0.5,
        bladeCurve = 0.4,
        seed = 0
      } = params;
      
      // Create single tuft geometry
      const tuftGeo = createGrassTuftMesh({
        width: bladeWidth,
        height: bladeHeight,
        curve: bladeCurve,
        segments: 4,
        taper: 0.7
      });
      
      // Create grass material
      const grassMaterial = new THREE.MeshStandardMaterial({
        color: 0x2d6f35,
        side: THREE.DoubleSide,
        flatShading: false,
        roughness: 0.9,
        metalness: 0.0
      });
      
      // Get surface bounds to place tufts
      surfaceGeo.computeBoundingBox();
      const box = surfaceGeo.boundingBox;
      
      // Create instanced mesh
      const instancedMesh = new THREE.InstancedMesh(
        tuftGeo,
        grassMaterial,
        bladesPerTile
      );
      
      // Generate random tuft transforms
      const rng = seededRandom(seed);
      const matrix = new THREE.Matrix4();
      const position3 = new THREE.Vector3();
      const rotation = new THREE.Euler();
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3();
      
      for (let i = 0; i < bladesPerTile; i++) {
        // Random position on surface
        const x = box.min.x + rng() * (box.max.x - box.min.x);
        const z = box.min.z + rng() * (box.max.z - box.min.z);
        const y = box.min.y;
        
        position3.set(x, y, z);
        
        // Random rotation with lean (anime hair doesn't grow straight up!)
        const yaw = rng() * Math.PI * 2;
        const tilt = (rng() - 0.5) * 0.3; // Slight lean in various directions
        const roll = (rng() - 0.5) * 0.2;
        rotation.set(tilt, yaw, roll);
        quaternion.setFromEuler(rotation);
        
        // Random height and width variation
        const heightScale = 1.0 + (rng() - 0.5) * 2 * bladeHeightVar;
        const widthScale = 0.8 + rng() * 0.4; // Some tufts thicker than others
        scale.set(widthScale, heightScale, widthScale);
        
        // Build matrix
        matrix.compose(position3, quaternion, scale);
        instancedMesh.setMatrixAt(i, matrix);
      }
      
      instancedMesh.instanceMatrix.needsUpdate = true;
      return instancedMesh;
    }

    function regenerate(){
      const p = readParams();
      // Terrain center in world space (used by sun target + gizmos)
      globalThis.__terrainCenter = new THREE.Vector3(p.w * p.tileSize * 0.5, 0, p.h * p.tileSize * 0.5);
      if (globalThis.__sunLight){
        globalThis.__sunLight.target.position.copy(globalThis.__terrainCenter);
        globalThis.__sunLight.target.updateMatrixWorld();
      }
      
      // Sync terrain tile size with seasonal shader system
      if (globalThis.StylizedTerrainShader && globalThis.StylizedTerrainShader.shared){
        globalThis.StylizedTerrainShader.shared.terrainTileSize.value = p.tileSize;
      }

      // Materials are created once and reused; keep the debug list persistent.

      const preset = structuredClone(DEFAULT_CLIFFSIDE_PRESET_V2);
      preset.cliffSelection.facing = p.cliffFacing;

      const simplexGround = new Simplex2D(makeRng(p.seed + "::ground"));
      const simplexLump   = new Simplex2D(makeRng(p.seed + "::lump"));
      const simplexWalls  = new Simplex2D(makeRng(p.seed + "::walls")); // NEW
      const simplexCliffVar = new Simplex2D(makeRng(p.seed + "::cliffVar")); // NEW
      p._simplexCliffVar = simplexCliffVar; // used by computeTileCornerHeights()
      const rngGrass      = makeRng(p.seed + "::grass");

      let vertDir, vertType, vertPlaced, spanTotal, spanSelected, spanRamp, spanRock, spanEdgesStamped;
      
      // Check if we have imported voxel data (either from fresh import or persistent)
      const hasImportedData = (useImportedLevels && levels) || (importedVoxelGrid && levels);
      
      // Check generation mode
      const genMode = $("genMode").value;
      const forceHeightmapRender = (genMode === "reimport");
      
      // If we're rendering from a voxel grid, keep grass surface ramps up-to-date.
      // (This is cheap: we only scan the surface, not the full 3D grid.)
      if (importedVoxelGrid && importedVoxelGridDims?.depth && levels){
        autoConvertGrassStepsToRamps();
      }

      if (hasImportedData) {
        // Imported voxel data exists. Normally we render directly from voxels (respects hollows),
        // but "Reimport (apply layout)" rebuilds a 2.5D heightmap and applies the ramp/rockwall layout.
        if (genMode === "reimport" && importedVoxelGrid && importedVoxelGridDims?.depth){
          const derived = deriveLevelsFromImportedVoxels(p.w, p.h);
          if (derived){
            levels = derived;
            // Ensure maxLevel matches the imported surface height so cliff classification and HUD are correct.
            let maxL = 0;
            for (let i=0;i<levels.length;i++) maxL = Math.max(maxL, levels[i]);
            p.maxLevel = Math.max(1, maxL);

            const layout = computeVerticalLayoutOnLevels({
              seed: p.seed + "::reimportLayout",
              w: p.w,
              h: p.h,
              levels,
              rampCount: p.rampCount,
              vertMode: p.vertMode,
              vertRampFrac: p.vertRampFrac
            });

            vertDir = layout.vertDir;
            vertType = layout.vertType;
            vertPlaced = layout.vertPlaced;
            spanTotal = layout.spanTotal;
            spanSelected = layout.spanSelected;
            spanRamp = layout.spanRamp;
            spanRock = layout.spanRock;
            spanEdgesStamped = layout.spanEdgesStamped;

            log(`Reimport layout: derivedMaxLevel=${p.maxLevel} placed=${vertPlaced} spans sel=${spanSelected}/${spanTotal} ramp=${spanRamp} rock=${spanRock}`);
          } else {
            // Fallback: no derived levels, treat as plain voxel render.
            vertDir = new Int8Array(p.w * p.h);
            vertType = new Int8Array(p.w * p.h);
            vertPlaced = 0; spanTotal = 0; spanSelected = 0; spanRamp = 0; spanRock = 0; spanEdgesStamped = 0;
          }

          // Reset import flag (but keep voxel grid)
          useImportedLevels = false;
        } else {
          // Using imported voxel data - create simple vertical arrays (no ramps/walls)
          vertDir = new Int8Array(p.w * p.h); // All zeros (no ramps/walls)
          vertType = new Int8Array(p.w * p.h); // All zeros (no ramps/walls)
          vertPlaced = 0;
          spanTotal = 0;
          spanSelected = 0;
          spanRamp = 0;
          spanRock = 0;
          spanEdgesStamped = 0;

          // Reset import flag (but keep voxel grid)
          useImportedLevels = false;
        }
      } else if (genMode.startsWith("sculpt")) {
        // Sculpting mode - layer-by-layer erosion
        const isGentle = genMode === "sculpt-gentle";
        const minOps = parseInt($("sculptOpsMin").value);
        const maxOps = parseInt($("sculptOpsMax").value);
        const groundLayer = parseInt($("groundLayer").value);
        const intensity = isGentle ? 0.7 : 1.3; // gentle = softer, dramatic = stronger
        
        const result = generateSculptedTerrain({
          seed: p.seed + "::sculpt",
          w: p.w,
          h: p.h,
          maxLevel: p.maxLevel,
          minOps,
          maxOps,
          intensity,
          isGentle,
          groundLayer
        });
        
        levels = result.levels;
        vertDir = result.vertDir;
        vertType = result.vertType;
        vertPlaced = result.vertPlaced;
        spanTotal = result.spanTotal;
        spanSelected = result.spanSelected;
        spanRamp = result.spanRamp;
        spanRock = result.spanRock;
        spanEdgesStamped = result.spanEdgesStamped;
        
        // Show sculpting log
        if (result.opLog && result.opLog.length > 0) {
          let logText = `Sculpted terrain (${isGentle ? 'gentle' : 'dramatic'} mode)\n`;
          logText += `Operations: ${result.opLog.length}\n\n`;
          
          const recent = result.opLog.slice(-10);
          recent.forEach(op => {
            const {layer, name, carved, ...params} = op;
            logText += `L${layer} ${name}: `;
            logText += Object.entries(params).map(([k,v]) => `${k}=${v}`).join(' ');
            logText += `\n`;
          });
          
          if (result.opLog.length > 10) {
            logText += `\n... ${result.opLog.length - 10} earlier ops`;
          }
          
          setHud(logText);
        }
      } else {
        // Normal procedural generation (no voxel grid exists)
        const result = generateRectTierMap({
          seed: p.seed + "::map",
          w: p.w, h: p.h,
          maxLevel: p.maxLevel,
          rectCount: p.rectCount,
          rampCount: p.rampCount,
          vertMode: p.vertMode,
          vertRampFrac: p.vertRampFrac,
        });
        
        // Assign to global for vox export/import
        levels = result.levels;
        vertDir = result.vertDir;
        vertType = result.vertType;
        vertPlaced = result.vertPlaced;
        spanTotal = result.spanTotal;
        spanSelected = result.spanSelected;
        spanRamp = result.spanRamp;
        spanRock = result.spanRock;
        spanEdgesStamped = result.spanEdgesStamped;
      }

      const tops = buildTopGeometriesByTierSegments(p, levels, vertDir, vertType);

      // Generate surfaces from voxels (overrides heightmap-based tops for hollow space support)
      const voxelSurfaces = forceHeightmapRender
        ? { grassSurfaces: [], nonGrassSurfaces: [], riverSurfaces: [] }
        : buildTopSurfacesFromVoxels(p);
      const voxelGrassSurfaces = voxelSurfaces.grassSurfaces || [];
      const voxelNonGrassSurfaces = voxelSurfaces.nonGrassSurfaces || [];
      const voxelRiverSurfaces = voxelSurfaces.riverSurfaces || [];
      const bottomSurfaces = forceHeightmapRender ? [] : buildBottomSurfacesFromVoxels(p);

      // Generate walls from voxel data (respects hollow spaces)
      // Voxel-based vertical walls (respects hollow spaces) ‚Äì split into solid vs water.
      const voxelWalls = forceHeightmapRender ? null : buildWallsFromVoxels(p);
      const hasVoxelWalls = (!forceHeightmapRender) && !!(voxelWalls && (voxelWalls.solid || voxelWalls.water));
const solidDepth = Math.max(0.25, p.levelHeight * 3.25);
      const balloonOut = p.tileSize * 0.085;
      const balloonDown = p.levelHeight * 0.12;

      const grassCapDepth = Math.max(0.0, p.grassThk * p.levelHeight);
      const muffinSteps = Math.max(1, Math.round(p.muffinRad01 * 18));

      const rockSolidsTop = [];
      const rockSolidsSide = [];
      const grassSolidsTop = [];
      const grassSolidsSide = [];

      for (const gTop of tops.geometries){
        const gRock = solidifyFromTop(gTop, solidDepth, balloonOut, balloonDown);
        if (gRock){
          if (p.muffinLift > 0 || p.muffinOver > 0 || p.round > 0) spreadBoundaryWeight(gRock, muffinSteps);
          warpSolidGeometry(gRock, p, simplexGround, simplexLump);

          const split = splitByIsTop(gRock);
          if (split.top) rockSolidsTop.push(split.top);
          if (split.side) rockSolidsSide.push(split.side);
          gRock.dispose();
        }

        if (p.topMat === "grass" && grassCapDepth > 0){
          const gGrass = solidifyFromTop(gTop, grassCapDepth, balloonOut * 0.25, balloonDown * 0.25);
          if (gGrass){
            if (p.muffinLift > 0 || p.muffinOver > 0 || p.round > 0) spreadBoundaryWeight(gGrass, Math.max(1, Math.round(muffinSteps * 0.75)));
            warpSolidGeometry(gGrass, p, simplexGround, simplexLump);

            const split = splitByIsTop(gGrass);
            if (split.top) grassSolidsTop.push(split.top);
            if (split.side) grassSolidsSide.push(split.side);
            gGrass.dispose();
          }
        }

        gTop.dispose();
      }

      const walls = buildWallsGeometry(p, levels, vertDir, vertType, preset, p.cliffFacing);

      // NEW: roughen walls so cliffs actually respond to lump/round settings
      warpWallGeometry(walls.geoOther, p, simplexWalls, p.wallRough);
      warpWallGeometry(walls.geoCliffBack, p, simplexWalls, p.wallRough);
      // keep back walls mostly clean, but still allow a tiny bit for coherence
      warpWallGeometry(walls.geoBack, p, simplexWalls, p.wallRough * 0.25);
      // walls backing ramps should read like grass/soil, keep them fairly smooth
      warpWallGeometry(walls.geoRampBack, p, simplexWalls, p.wallRough * 0.10);

      if (root){
        scene.remove(root);
        disposeObject(root);
        // treePreviewObj (if any) was inside root and got disposed with it
        treePreviewObj = null;
        if (cliffRocksGeom) cliffRocksGeom.dispose();
        if (grassGeom) grassGeom.dispose();
      }

      root = new THREE.Group();
      scene.add(root);


      const dbg = currentDebugMat();

      // Base materials (respect debug overrides)
      // In lit mode, we always use the stylized shader stack (unless debug overrides it).

      const useGrassMode = (p.topMat === "grass");
      const useAccumMode = (p.topMat === "accumulation");

      // Stylized material routing:
      // - If grass mode is ON: any surface that would otherwise be "green" becomes green + grass=true.
      // - If grass mode is OFF: everything is gray + grass=false.
      const matRock = dbg ? dbg : matCliffShaderGray;   // gray shader (grass=false)
      const matCliff = dbg ? dbg : matCliffShaderGray;  // gray shader (grass=false)

      // "Green surfaces" are defined as anything that used the green materials in the legacy system
      // (tops/grass caps/ramp backs). If grass mode is off, we force these to gray for consistency.
      const matGrassCap = useGrassMode
        ? (dbg ? dbg : matGroundShaderGreen)            // green shader (grass=true)
        : matRock;                                     // gray shader (grass=false)

      // Top surfaces: green only in grass mode, otherwise gray.
      const matTop = useGrassMode ? matGrassCap : matRock;

      // Ramp-backed walls: green only in grass mode, otherwise gray.
      // Ramp-backed / ramp-hole fill walls: match the top surface material.
// Render double-sided so looking into a ramp cut never reveals "sky holes" from backface culling.
      const matRampBack = (() => {
        const m = matTop.clone();
        // Share uniforms so biome/season controls affect both top + ramp fill.
        if (matTop.uniforms) m.uniforms = matTop.uniforms;
        m.side = THREE.DoubleSide;
        // Tiny offset helps avoid z-fighting where it kisses the ground shell.
        m.polygonOffset = true;
        m.polygonOffsetFactor = 1;
        m.polygonOffsetUnits = 1;
        return m;
      })();

      {
        const g = new THREE.Group();
        // Skip regular solidified walls if we have voxel-based walls (they respect hollow spaces)
        if (!hasVoxelWalls) {
          for (const geo of rockSolidsSide){
            if (dbg) g.add(new THREE.Mesh(geo, matRock));
            else addStylizedMesh(g, geo, matRock);
          }
        }
        root.add(g);
      }
      {
        // SEASONAL SYSTEM: Two-layer terrain (dirt base + grass on top)
        // Determine which surfaces to render
        const hasVoxelSurfaces = (voxelGrassSurfaces.length > 0) || (voxelNonGrassSurfaces.length > 0);
        const grassTopsToRender = hasVoxelSurfaces ? voxelGrassSurfaces : tops.geometries;
        
        
        // Optional: build a thin "solid" skirt under the ground so warp/accumulation reads as real mass
        // and doesn't intersect the vertical wall material. This is intentionally shallow (in voxels).
        const wantsGroundShell = !!(p.groundShellOn && (p.groundShellVox || 0) > 0);
        const groundShellDepth = wantsGroundShell ? (p.levelHeight * (p.groundShellVox || 0)) : 0;

        if (wantsGroundShell && groundShellDepth > 0){
          const shellGroup = new THREE.Group();
          shellGroup.name = "groundShellSkirt";

          // Soil-looking skirt under grass, otherwise use rock.
          // Use polygonOffset to reduce z-fighting where it overlaps the voxel walls.
          const baseShellMat = useGrassMode ? matDirtShaderBrown : matRock;
          const shellMat = baseShellMat.clone();
          shellMat.polygonOffset = true;
          shellMat.polygonOffsetFactor = 1;
          shellMat.polygonOffsetUnits = 1;
          shellMat.side = THREE.DoubleSide;

          const balloonOutShell = p.tileSize * 0.05;
          const balloonDownShell = p.levelHeight * 0.04;

          const shellSources = [];
          // Grass surfaces (top of terrain)
          for (const geo of grassTopsToRender) shellSources.push(geo);
          // Non-grass hard surfaces also benefit from a skirt (roads/stone tops).
          for (const geo of voxelNonGrassSurfaces) shellSources.push(geo);

          for (const geoTop of shellSources){
            const gSolid = solidifyFromTop(geoTop, groundShellDepth, balloonOutShell, balloonDownShell);
            if (!gSolid) continue;

            // Keep the skirt coherent with the rest of the terrain breakup.
            if (p.muffinLift > 0 || p.muffinOver > 0 || p.round > 0) {
              spreadBoundaryWeight(gSolid, Math.max(1, Math.round(muffinSteps * 0.75)));
            }
            warpSolidGeometry(gSolid, p, simplexGround, simplexLump);

            const split = splitByIsTop(gSolid);
            if (split.side){
              if (dbg) shellGroup.add(new THREE.Mesh(split.side, shellMat));
              else addStylizedMesh(shellGroup, split.side, shellMat);
            }
            gSolid.dispose();
          }

          root.add(shellGroup);
        }
// Dirt layer (always visible - dry earth base) - ONLY for grass surfaces
        const gDirt = new THREE.Group();
        for (const geo of grassTopsToRender){
          // Dirt doesn't need subdivision
          if (dbg) gDirt.add(new THREE.Mesh(geo, matRock));
          else addStylizedMesh(gDirt, geo, matDirtShaderBrown);
        }
        root.add(gDirt);
        
        // Accumulation overlay (snow/moss) - sits on top of the base dirt layer.
        // IMPORTANT: this layer is rendered WITHOUT stylized outlines/wireframes.
        // Outlines on a fragment-discarded overlay will reveal the underlying triangle grid.
        if (useAccumMode){
          const gAccum = new THREE.Group();
          gAccum.name = "AccumulationOverlay";

          const snowOverlayMat = matDirtShaderBrown.clone();

          // IMPORTANT:
          // - We want Accumulation UI changes (snowHeight/noise/layers/etc.) to update both base + overlay.
          // - But we do NOT want to share baseColor, because the overlay should look like snow (bright),
          //   while the base remains dirt/rock.
          if (matDirtShaderBrown.uniforms){
            const u = matDirtShaderBrown.uniforms;

            let snowCol = null;
            try{
              if (u.snowTintColor && u.snowTintColor.value && typeof u.snowTintColor.value.clone === "function"){
                snowCol = u.snowTintColor.value.clone();
              }
            }catch(_e){}
            if (!snowCol) snowCol = new THREE.Color("#ebf6ff");

            snowOverlayMat.uniforms = {
              ...u,
              baseColor: { value: snowCol },       // overlay albedo (snow)
              grassModeMix: { value: 0.0 },        // ensures overlay doesn't inherit grass shading
              snowOverlayCutoff: { value: 0.08 },  // only render where snow amount is meaningful
            };
          }

          // Render as an alpha-tested/discarded overlay. Keep depthTest on, but do NOT write depth,
          // otherwise holes can create harsh edges and sorting artifacts on mobile.
          snowOverlayMat.transparent = false;
          snowOverlayMat.depthTest = true;
          snowOverlayMat.depthWrite = false;
          snowOverlayMat.side = THREE.FrontSide;

          // Push slightly toward the camera in depth to avoid z-fighting (better than y-lifting).
          snowOverlayMat.polygonOffset = true;
          snowOverlayMat.polygonOffsetFactor = -1;
          snowOverlayMat.polygonOffsetUnits = -1;

          if (snowOverlayMat.uniforms?.snowOverlayCutoff?.value !== undefined) {
            // Only render where snow has meaningful coverage.
            snowOverlayMat.uniforms.snowOverlayCutoff.value = 0.08;
          }

          // We overlay snow on BOTH grass-eligible surfaces and non-grass hard surfaces
          // so roads/stone can also collect snow if desired.
          const overlaySources = [];
          for (const geo of grassTopsToRender) overlaySources.push(geo);
          for (const geo of voxelNonGrassSurfaces) overlaySources.push(geo);

          for (const geo of overlaySources){
            // Accumulation displacement relies on edgeW + isTop attributes.
            // The base terrain surfaces are lightweight and may not carry these, so compute them here.
            const geoAccum = (globalThis.ensureTopSurfaceAttrs ? globalThis.ensureTopSurfaceAttrs(geo) : (globalThis.ensureEdgeAttrs ? globalThis.ensureEdgeAttrs(geo) : geo));

            const m = new THREE.Mesh(geoAccum, snowOverlayMat);
            m.renderOrder = 10; // ensure it draws after the base terrain
            gAccum.add(m);
          }

          root.add(gAccum);
        }

        // Grass layer (on top, with transparency for seasonal coverage) - ONLY for grass surfaces
        if (useGrassMode){
          const gGrass = new THREE.Group();
          gGrass.position.y = 0.05; // Slightly above dirt to prevent z-fighting
          
          for (const geo of grassTopsToRender){
            const geoTop = (p.grassSubdiv>0) ? globalThis.subdivideGeometryTriangles(geo, p.grassSubdiv) : geo;
            if (dbg) gGrass.add(new THREE.Mesh(geoTop, matTop));
            else addStylizedMesh(gGrass, geoTop, matGroundShaderGreen);
          }
          root.add(gGrass);
        }
        
        // Non-grass surfaces (roads, stone) - render as DIRT (brown), NO grass shader
        // This makes it easy to see grass exclusion is working
        if (voxelNonGrassSurfaces.length > 0) {
          const gNonGrass = new THREE.Group();
          for (const geo of voxelNonGrassSurfaces){
            if (dbg) gNonGrass.add(new THREE.Mesh(geo, matRock));
            else addStylizedMesh(gNonGrass, geo, matDirtShaderBrown);
          }
          root.add(gNonGrass);
        }

        // River surfaces - water shader (flow + silhouette trouble)
        if (voxelRiverSurfaces.length > 0) {
          const gRivers = new THREE.Group();
          gRivers.name = "Rivers";
          const riverMat = createWaterMaterial();
          riverMat.transparent = true;
          riverMat.depthWrite = false; // avoid sorting artifacts with outlines

          for (const geo of voxelRiverSurfaces){
            const m = new THREE.Mesh(geo, riverMat);
            // NOTE: River water must render in the main pass (layer 0) and ALSO in WATER_LAYER
            // for the water-mask pass (shoreline/intersection outlines).
            m.layers.set(0);
            m.layers.enable(WATER_LAYER);
            m.renderOrder = 2;
            gRivers.add(m);
          }
          root.add(gRivers);
        }
      }

      if (p.topMat === "grass" && grassSolidsTop.length && !voxelGrassSurfaces.length){
        // SEASONAL SYSTEM: Two-layer for grass solids too
        // Dirt base layer
        const gDirtSolids = new THREE.Group();
        for (const geo of grassSolidsSide) gDirtSolids.add(new THREE.Mesh(geo, matRock));
        for (const geo of grassSolidsTop){
          const m = new THREE.Mesh(geo, matDirtShaderBrown);
          gDirtSolids.add(m);
        }
        root.add(gDirtSolids);
        
        // Grass layer on top
        const gGrassSolids = new THREE.Group();
        gGrassSolids.position.y = 0.05; // Offset to prevent z-fighting
        for (const geo of grassSolidsTop){
          const geoGrassTop = (p.grassSubdiv>0) ? globalThis.subdivideGeometryTriangles(geo, p.grassSubdiv) : geo;
          if (dbg){
            const m = new THREE.Mesh(geoGrassTop, matGrassCap);
            m.position.y += 0.01;
            gGrassSolids.add(m);
          } else {
            const gg = new THREE.Group();
            addStylizedMesh(gg, geoGrassTop, matGrassCap);
            gg.position.y += 0.01;
            gGrassSolids.add(gg);
          }
        }
        root.add(gGrassSolids);
      }

      // Render bottom surfaces (cave ceilings, bridge undersides) - use cliff material
      if (bottomSurfaces.length > 0) {
        const g = new THREE.Group();
        for (const geo of bottomSurfaces) {
          // Don't subdivide undersides (they don't need grass detail)
          if (dbg) {
            g.add(new THREE.Mesh(geo, matCliff));
          } else {
            addStylizedMesh(g, geo, matCliff);
          }
        }
        root.add(g);
      }

      // Render voxel walls (respects hollow spaces in imported voxel data)
      if (hasVoxelWalls) {
        // Solid walls (most voxels)
        if (voxelWalls.solid) {
          if (dbg) {
            root.add(new THREE.Mesh(voxelWalls.solid, matRock));
          } else {
            addStylizedMesh(root, voxelWalls.solid, matRock);
          }
        }

        // Water walls (river voxel vertical faces)
        if (voxelWalls.water) {
          if (dbg) {
            // In debug material mode, treat these as regular geometry so you can inspect them.
            root.add(new THREE.Mesh(voxelWalls.water, matRock));
          } else {
            const gWaterWalls = new THREE.Group();
            gWaterWalls.name = "WaterWalls";

            const waterMat = createWaterMaterial();
            waterMat.transparent = true;
            waterMat.depthWrite = false;

            const m = new THREE.Mesh(voxelWalls.water, waterMat);
            // Render in main view AND in water-mask pass.
            m.layers.set(0);
            m.layers.enable(WATER_LAYER);
            m.renderOrder = 2;
            gWaterWalls.add(m);

            root.add(gWaterWalls);
          }
        }
      }

      // Skip heightmap-based walls when voxel walls exist (they don't respect hollows)
      if (!hasVoxelWalls) {
        // When using rockwall/cliff instancing, the old "stone housing" walls read too boxy.
        // In those modes we keep only the cliff/ramp backing and let the instanced rocks own the silhouette.
        const wantsCliffyWalls = (p.vertMode === "rockwalls" || p.vertMode === "mixed");

        if (!wantsCliffyWalls){
          if (dbg) root.add(new THREE.Mesh(walls.geoOther, matVerticalStone));
          else addStylizedMesh(root, walls.geoOther, matVerticalStone);

          const backWire = !!preset.renderHint?.backsideWireframe;
          if (dbg) root.add(new THREE.Mesh(walls.geoBack, backWire ? matBackWire : matVerticalStone));
          else {
            // keep the optional backside wireframe as-is; outline only on the solid layer
            if (backWire) root.add(new THREE.Mesh(walls.geoBack, matBackWire));
            addStylizedMesh(root, walls.geoBack, matVerticalStone);
          }

          if (dbg) root.add(new THREE.Mesh(walls.geoCliffBack, matVerticalStone));
          else {
            const m = new THREE.Mesh(walls.geoCliffBack, matCliffOccluder);
            m.name = "CliffBackOccluder";
            m.renderOrder = 0;
            root.add(m);
          }
        } else {
          // Keep a backing surface only where cliffs/ramp-cuts exist, so any gaps between rocks don't show "sky holes".
          // Note: we avoid outlines here to keep it from reading like a rigid casing.
          if (walls.geoCliffBack){
            const m = new THREE.Mesh(walls.geoCliffBack, matCliffOccluder);
            m.name = "CliffBackOccluder";
            m.renderOrder = 0;
            root.add(m);
          }
        }

        // Ramp-backed walls: grass-colored so the "cut" behind ramps reads as soil/grass rather than rock
        if (dbg) root.add(new THREE.Mesh(walls.geoRampBack, matRampBack));
        else addStylizedMesh(root, walls.geoRampBack, matRampBack);
      }

      // cliffs: one rock per run (mesh stays the same; walls behind now roughen)
      // Skip when voxel data exists - voxel walls already handle geometry correctly
      let cliffSpawned = 0;
      if (cliffDebugMode === "runs" && walls.cliffRuns.length > 0 && !hasVoxelWalls){
        cliffRocksGeom = makeRockGeometryFromPreset(preset, p.seed + "::cliffRock", 1.0);

        // In lit mode we render base instanced mesh
        const cliffRocks = new THREE.InstancedMesh(cliffRocksGeom, matCliff, walls.cliffRuns.length);
        cliffRocks.frustumCulled = false;

        const tmpMat = new THREE.Matrix4();
        const rotMat = new THREE.Matrix4();
        const sclMat = new THREE.Matrix4();
        const posMat = new THREE.Matrix4();

        const up = new THREE.Vector3(0,1,0);
        const cliffDepth = Math.max(0.25, p.tileSize * 0.75);
        const overhang = 1.10;

        for (let i=0;i<walls.cliffRuns.length;i++){
          const r = walls.cliffRuns[i];
          const runLen = Math.max(0.001, r.end - r.start);
          const height = Math.max(0.001, r.high - r.low);

          const runDir = (r.axis === "X") ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,0,1);
          const normal = r.normal.clone().normalize();

          rotMat.makeBasis(runDir, up, normal);

          let cx, cz;
          if (r.axis === "Z"){ cx = r.fixed; cz = (r.start + r.end) * 0.5; }
          else { cx = (r.start + r.end) * 0.5; cz = r.fixed; }
          const cy = (r.low + r.high) * 0.5;

          const inset = cliffDepth * 0.15;
          posMat.makeTranslation(cx + normal.x*inset, cy, cz + normal.z*inset);

          // tiny extra thickness if Round is up (helps blending visually)
          const roundBoost = 1.0 + clamp(p.round, 0, 1.5) * 0.06;
          sclMat.makeScale(runLen * overhang, height * overhang, cliffDepth * roundBoost);

          tmpMat.identity().multiply(posMat).multiply(rotMat).multiply(sclMat);
          cliffRocks.setMatrixAt(i, tmpMat);
          cliffSpawned++;
        }
        cliffRocks.instanceMatrix.needsUpdate = true;
        root.add(cliffRocks);
      }


// Vertical-tile feature: rockwalls (mutually exclusive with ramps)
// One rock mesh per vertical tile; scales with tileSize/levelHeight like cliffs do.
// Skip when voxel data exists - voxel walls handle geometry correctly
let vertRockSpawned = 0;
if ((p.vertMode === "rockwalls" || p.vertMode === "mixed") && !hasVoxelWalls){
  const rockGeom = makeRockGeometryFromPreset(preset, p.seed + "::vertRock", 1.0);
  let count = 0;
  for (let i=0;i<vertType.length;i++){ if (vertType[i] === 2) count++; }
  if (count > 0){
    const vertRocks = new THREE.InstancedMesh(rockGeom, matCliff, count);
    vertRocks.frustumCulled = false;

    const tmpMat = new THREE.Matrix4();
    const rotMat = new THREE.Matrix4();
    const sclMat = new THREE.Matrix4();
    const posMat = new THREE.Matrix4();

    const up = new THREE.Vector3(0,1,0);
    let wi = 0;

    for (let z=0; z<p.h; z++){
      for (let x=0; x<p.w; x++){
        const i = z*p.w + x;
        if (vertType[i] !== 2) continue;

        const dir = vertDir[i];
        const cx = (x + 0.5) * p.tileSize;
        const cz = (z + 0.5) * p.tileSize;
        const baseY = levels[i] * p.levelHeight;

        // face toward higher neighbor
        let normal = new THREE.Vector3(1,0,0);
        if (dir === DIR.N) normal.set(0,0,1);
        else if (dir === DIR.S) normal.set(0,0,-1);
        else if (dir === DIR.E) normal.set(1,0,0);
        else if (dir === DIR.W) normal.set(-1,0,0);
        normal.normalize();

        const right = new THREE.Vector3().crossVectors(up, normal).normalize();
        rotMat.makeBasis(right, up, normal);

        const sx = Math.max(0.25, p.tileSize * 0.95);
        const sy = Math.max(0.25, p.levelHeight * 1.15);
        const sz = Math.max(0.25, p.tileSize * 0.75);
        sclMat.makeScale(sx, sy, sz);

        posMat.makeTranslation(cx, baseY + p.levelHeight * 0.5, cz);

        tmpMat.multiplyMatrices(posMat, rotMat);
        tmpMat.multiply(sclMat);

        vertRocks.setMatrixAt(wi++, tmpMat);
      }
    }

    vertRocks.instanceMatrix.needsUpdate = true;
    root.add(vertRocks);
    vertRockSpawned = count;
  }
}


      // Standalone tree preview (optional; driven by Actions ‚Üí Tree)
      try{ syncTreePreview(p); }catch(e){ hudPush("Tree preview error: " + (e?.message || String(e))); }

      // Standalone road bricks (optional; driven by Actions ‚Üí Road Bricks)
      try{ syncRoadBricks(p); }catch(e){ hudPush("Road bricks error: " + (e?.message || String(e))); }

      // Road debug overlay (optional)
      try{ syncRoadDebug(p); }catch(e){ hudPush("Road debug error: " + (e?.message || String(e))); }



      // Old instanced grass system removed - now using shader grass
      // stats
      let minL=9999, maxL=-9999, rampTiles=0, rockWallTiles=0;
      for (let i=0;i<levels.length;i++){
        minL = Math.min(minL, levels[i]);
        maxL = Math.max(maxL, levels[i]);
        if (vertType[i] === 1 && vertDir[i] !== 0) rampTiles++;
        if (vertType[i] === 2 && vertDir[i] !== 0) rockWallTiles++;
      }

      frameCameraToObject(root);

      setHud(
`Boot OK ‚úÖ
ShaderPreset: ${globalThis.StylizedTerrainShader?.getActivePresets ? (`rock=${globalThis.StylizedTerrainShader.getActivePresets().rock} grass=${globalThis.StylizedTerrainShader.getActivePresets().grass}`) : (globalThis.StylizedTerrainShader?.getActivePreset ? globalThis.StylizedTerrainShader.getActivePreset() : "(none)")}
Hemi: slider=${(globalThis.__debugHemi?.value ?? +($('hemiI')?.value||0)).toFixed(2)} three=${globalThis.__debugHemi?.hasThree ? 'yes' : 'no'} shader=${globalThis.__debugHemi?.hasShader ? 'yes' : 'no'} sky=${globalThis.__debugHemi?.sky||'?' } ground=${globalThis.__debugHemi?.ground||'?'} boost=${globalThis.__debugHemi?.boost ? 'on':'off'}
Sun: rot=${globalThis.__debugSun?.rotate ? 'on':'off'} spd=${(globalThis.__debugSun?.speed ?? +($('sunSpeed')?.value||0)).toFixed(1)} az=${Math.round(globalThis.__debugSun?.az ?? +($('sunAz')?.value||0))} el=${Math.round(globalThis.__debugSun?.elev ?? +($('sunElev')?.value||0))} gizmo=${globalThis.__debugSun?.gizmo ? 'on':'off'} three=${globalThis.__debugSun?.hasThree ? 'yes':'no'} dir=${globalThis.__debugSun?.dirRays ? (globalThis.__debugSun.dirRays.x.toFixed(2)+','+globalThis.__debugSun.dirRays.y.toFixed(2)+','+globalThis.__debugSun.dirRays.z.toFixed(2)) : '?'}
Walls now roughen with Lump+Round (normal-displace) via CliffWallRough=${p.wallRough}

Top segments: ${(voxelGrassSurfaces.length + voxelNonGrassSurfaces.length) > 0 ? `${voxelGrassSurfaces.length} grass + ${voxelNonGrassSurfaces.length} non-grass (voxel)` : (tops.componentCount + ' (heightmap)')}  totalTopVerts=${tops.totalTopVerts}
Bottom surfaces (ceilings): ${bottomSurfaces.length} geometries
Voxel walls: ${hasVoxelWalls ? (`solid=${(voxelWalls.stats && voxelWalls.stats.solidQuads) ? voxelWalls.stats.solidQuads : 0} water=${(voxelWalls.stats && voxelWalls.stats.waterQuads) ? voxelWalls.stats.waterQuads : 0} quads`) : 'none'}
Muffin: lift=${p.muffinLift} over=${p.muffinOver} rad=${p.muffinRad01}
Round=${p.round}  Lump: amp=${p.lumpAmp} scale=${p.lumpScale}

CliffVar: frac=${p.cliffVar} scale=${p.cliffVarScale} boost=${p.cliffVarBoost}
         active=${!!p._simplexCliffVar} edges=${p._cliffVarEdgesAll||0} maxAbsY=${(p._cliffVarMaxAbsAll||0).toFixed(3)}

Seed: ${p.seed}
Grid: ${p.w}x${p.h} tile=${p.tileSize} stepH=${p.levelHeight}
Tiers: min ${minL} / max ${maxL} (cap ${p.maxLevel})
Vertical: placed ${vertPlaced} ramps ${rampTiles} rockwalls ${rockWallTiles}
Spans: total ${spanTotal||0} selected ${spanSelected||0} rampSpans ${spanRamp||0} rockSpans ${spanRock||0} stampedEdges ${spanEdgesStamped||0}

Grass: shader-based anime tufts H=${p.grassH.toFixed(2)} Detail=${Math.round(p.grassFreq)} Subdiv=${p.grassSubdiv}
Cliffs: mode=${cliffDebugMode} runs=${walls.cliffRuns.length} rocks=${cliffSpawned}
Debug: ${debugMode}`
      );

      // --- Always-on material debug dump (mobile-friendly; no devtools needed) ---
      try{
        const mats = globalThis.StylizedTerrainShader?.__debugMaterials?.() || [];
        if (mats.length){
          hudPush("Materials:");
          for (const m of mats){
            hudPush(
              `  ${m.role}  ${m.type}` +
              (m.grass !== undefined ? ` grass=${m.grass}` : ``) +
              (m.preset ? ` preset=${m.preset}` : ``) +
              (m.outline ? ` outline=true` : ``) + (m.grassHeight !== undefined ? ` grassH=${Number(m.grassHeight).toFixed(2)}` : ``) + (m.grassFreq !== undefined ? ` gFreq=${Math.round(Number(m.grassFreq))}` : ``) + (m.grassModeMix !== undefined ? ` gMix=${Number(m.grassModeMix).toFixed(2)}` : ``) + (m.windLen !== undefined ? ` wind=${Number(m.windLen).toFixed(2)}` : ``)
            );
          }
        } else {
          hudPush("Materials: (none tracked)");
        }
      }catch(e){
        hudPush("Materials debug error: " + (e?.message || String(e)));
      }

      // Update water after terrain generation
      updateWater();

    }

    $("regen").addEventListener("click", ()=>{
      // Clear imported voxel data to return to procedural generation
      importedVoxelGrid = null;
      importedVoxelGridDims = { w: 0, h: 0, depth: 0 };
      levels = null;
      useImportedLevels = false;
      regenerate();
    });
    $("debug").addEventListener("click", ()=>{
      debugMode = (debugMode==="lit") ? "wire" : (debugMode==="wire") ? "normal" : "lit";
      $("debug").textContent = "Debug: " + debugMode;
      regenerate();
    });
    $("cliffDbg").addEventListener("click", ()=>{
      cliffDebugMode = (cliffDebugMode==="runs") ? "none" : "runs";
      $("cliffDbg").textContent = "Cliffs: " + cliffDebugMode;
      regenerate();
    });


    // Tree preview controls (standalone generator)
    $("treeToggle")?.addEventListener("click", ()=>{
      treePreviewEnabled = !treePreviewEnabled;
      const btn = $("treeToggle");
      if (btn) btn.textContent = "Tree: " + (treePreviewEnabled ? "on" : "off");
      if (treePreviewEnabled) rebuildTreePreview(readParams());
      else removeTreePreview();
    });

    $("treeRegen")?.addEventListener("click", ()=>{
      if (!treePreviewEnabled){
        treePreviewEnabled = true;
        const btn = $("treeToggle");
        if (btn) btn.textContent = "Tree: on";
      }
      rebuildTreePreview(readParams());
    });

    // Road bricks controls (procedural cobbles on road voxels)
    $("roadBricksToggle")?.addEventListener("click", ()=>{
      roadBricksEnabled = !roadBricksEnabled;
      const btn = $("roadBricksToggle");
      if (btn) btn.textContent = "Road Bricks: " + (roadBricksEnabled ? "on" : "off");
      if (roadBricksEnabled) rebuildRoadBricks(readParams());
      else removeRoadBricks();
    });

    $("roadBricksRegen")?.addEventListener("click", ()=>{
      if (!roadBricksEnabled){
        roadBricksEnabled = true;
        const btn = $("roadBricksToggle");
        if (btn) btn.textContent = "Road Bricks: on";
      }
      rebuildRoadBricks(readParams());
    });

    // Road tile debug overlay (shows which tiles the app thinks are roads)
    $("roadDebugToggle")?.addEventListener("click", ()=>{
      roadDebugEnabled = !roadDebugEnabled;
      const btn = $("roadDebugToggle");
      if (btn) btn.textContent = "Road Debug: " + (roadDebugEnabled ? "on" : "off");
      if (roadDebugEnabled) rebuildRoadDebug(readParams());
      else removeRoadDebug();
    });


    // Road recipe import (JSON from Wall/Road Builder)
    $("roadBricksRecipeBtn")?.addEventListener("click", ()=>{
      const inp = $("roadBricksRecipeInput");
      if (inp) inp.click();
    });

    $("roadBricksRecipeInput")?.addEventListener("change", async (e)=>{
      const f = e?.target?.files?.[0];
      if (!f) return;
      try{
        const txt = await f.text();
        const obj = JSON.parse(txt);
        if (!obj || obj.settings?.kind !== "road"){
          throw new Error("Recipe must be a road recipe (settings.kind === \"road\").");
        }
        roadBricksRecipe = obj;
        roadBricksRecipeLabel = (f.name || "imported").replace(/\.[^.]+$/, "");
        setRoadBricksRecipeStatus();
        if (roadBricksEnabled) rebuildRoadBricks(readParams());
        hudPush(`Road recipe loaded: ${roadBricksRecipeLabel} (seed=${String(obj.seed||"")})`);
      }catch(err){
        hudPush("Road recipe import failed: " + (err?.message || String(err)));
      }finally{
        // allow re-import of the same file on mobile
        try{ e.target.value = ""; }catch(_e){}
      }
    });

    // Tree preset load/save/reset (kept lightweight so the generator island stays extractable)
    $("treePresetLoad")?.addEventListener("click", ()=>{
      const inp = $("treePresetInput");
      if (inp) inp.click();
    });

    $("treePresetInput")?.addEventListener("change", (ev)=>{
      const input = ev.target;
      const file = input?.files?.[0];
      if (!file){
        input.value = "";
        return;
      }
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const raw = String(reader.result || "");
          const obj = JSON.parse(raw);
          if (!obj || typeof obj !== "object") throw new Error("JSON root must be an object");
          globalThis.__treePresetOverride = obj;
          __saveTreePresetOverride(obj);
          __refreshTreePreset();
          hudPush(`Tree preset loaded: ${file.name}`);
          if (treePreviewEnabled) rebuildTreePreview(readParams());
        }catch(e){
          hudPush("Tree preset load failed: " + (e?.message || String(e)));
        }finally{
          input.value = ""; // allow re-loading same file
        }
      };
      reader.onerror = ()=>{
        hudPush("Tree preset read failed.");
        input.value = "";
      };
      reader.readAsText(file);
    });

    $("treePresetReset")?.addEventListener("click", ()=>{
      globalThis.__treePresetOverride = null;
      __saveTreePresetOverride(null);
      __refreshTreePreset();
      hudPush("Tree preset reset to default.");
      if (treePreviewEnabled) rebuildTreePreview(readParams());
    });

    $("treePresetSave")?.addEventListener("click", ()=>{
      try{
        const preset = __cloneJson(globalThis.__treePreset || {});
        // Add metadata if missing (helps round-trip between tools)
        if (!preset.kind) preset.kind = "tree_preset";
        if (!preset.version) preset.version = 2;

        const blob = new Blob([JSON.stringify(preset, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `tree_preset_${$("seed")?.value || "seed"}.json`;
        a.click();
        URL.revokeObjectURL(url);
        hudPush("Tree preset saved as JSON.");
      }catch(e){
        hudPush("Tree preset save failed: " + (e?.message || String(e)));
      }
    });


    // ============= .VOX IMPORT/EXPORT =============
    
    // Export current terrain as .vox file
    function exportAsVox() {
      if (!levels || levels.length === 0) {
        alert("No terrain to export! Generate terrain first.");
        return;
      }

      const w = parseInt($("w").value);
      const h = parseInt($("h").value);
      
      // Collect all voxels
      const voxels = [];
      let maxZ = 0;
      
      for (let z = 0; z < h; z++) {
        for (let x = 0; x < w; x++) {
          const idx = z * w + x;
          const level = levels[idx];
          
          if (level > 0) {
            maxZ = Math.max(maxZ, level);
            // Add a voxel for each tier level
            for (let y = 0; y < level; y++) {
              // Get voxel type from importedVoxelGrid if available
              let voxelType = VOXEL_TYPES.GRASS_FLAT; // default
              if (importedVoxelGrid && importedVoxelGridDims.depth > y) {
                const idx3d = y * (w * h) + z * w + x;
                const gridType = importedVoxelGrid[idx3d];
                if (gridType !== VOXEL_TYPES.EMPTY) {
                  voxelType = gridType;
                }
              }
              
              voxels.push({
                x: x,
                y: z, // MagicaVoxel uses Y as depth
                z: y, // MagicaVoxel uses Z as height
                colorIndex: voxelType // Preserve voxel type as color index!
              });
            }
          }
        }
      }
      
      if (voxels.length === 0) {
        alert("No voxels to export - terrain is empty!");
        return;
      }

      // Helper to write a chunk
      function writeChunk(id, contentBytes, childBytes) {
        const chunk = new Uint8Array(12 + contentBytes.length + childBytes.length);
        const view = new DataView(chunk.buffer);
        
        // Chunk ID (4 bytes)
        for (let i = 0; i < 4; i++) {
          chunk[i] = id.charCodeAt(i);
        }
        
        // Content size (4 bytes, little endian)
        view.setUint32(4, contentBytes.length, true);
        
        // Children size (4 bytes, little endian)
        view.setUint32(8, childBytes.length, true);
        
        // Content data
        chunk.set(contentBytes, 12);
        
        // Child data
        if (childBytes.length > 0) {
          chunk.set(childBytes, 12 + contentBytes.length);
        }
        
        return chunk;
      }
      
      // Build SIZE chunk content (no children)
      const sizeContent = new Uint8Array(12);
      const sizeView = new DataView(sizeContent.buffer);
      sizeView.setUint32(0, w, true);  // X
      sizeView.setUint32(4, h, true);  // Y
      sizeView.setUint32(8, maxZ, true);  // Z
      const sizeChunk = writeChunk('SIZE', sizeContent, new Uint8Array(0));
      
      // Build XYZI chunk content (no children)
      const xyziContent = new Uint8Array(4 + voxels.length * 4);
      const xyziView = new DataView(xyziContent.buffer);
      xyziView.setUint32(0, voxels.length, true);
      
      for (let i = 0; i < voxels.length; i++) {
        const v = voxels[i];
        xyziContent[4 + i * 4 + 0] = v.x;
        xyziContent[4 + i * 4 + 1] = v.y;
        xyziContent[4 + i * 4 + 2] = v.z;
        xyziContent[4 + i * 4 + 3] = v.colorIndex;
      }
      const xyziChunk = writeChunk('XYZI', xyziContent, new Uint8Array(0));
      
      // Build RGBA palette chunk - preserves voxel type colors!
      const rgbaContent = new Uint8Array(256 * 4);
      for (let i = 0; i < 256; i++) {
        const color = getVoxelColor(i);
        rgbaContent[i * 4 + 0] = (color >> 16) & 0xff; // R
        rgbaContent[i * 4 + 1] = (color >> 8) & 0xff;  // G
        rgbaContent[i * 4 + 2] = color & 0xff;         // B
        rgbaContent[i * 4 + 3] = 255;                  // A
      }
      const rgbaChunk = writeChunk('RGBA', rgbaContent, new Uint8Array(0));
      
      // Combine SIZE, XYZI, and RGBA as children of MAIN
      const childData = new Uint8Array(sizeChunk.length + xyziChunk.length + rgbaChunk.length);
      childData.set(sizeChunk, 0);
      childData.set(xyziChunk, sizeChunk.length);
      childData.set(rgbaChunk, sizeChunk.length + xyziChunk.length);
      
      // Build MAIN chunk (no content, only children)
      const mainChunk = writeChunk('MAIN', new Uint8Array(0), childData);
      
      // Build file header
      const header = new Uint8Array(8);
      header[0] = 'V'.charCodeAt(0);
      header[1] = 'O'.charCodeAt(0);
      header[2] = 'X'.charCodeAt(0);
      header[3] = ' '.charCodeAt(0);
      const headerView = new DataView(header.buffer);
      headerView.setUint32(4, 150, true); // version 150
      
      // Combine header + main chunk
      const result = new Uint8Array(header.length + mainChunk.length);
      result.set(header, 0);
      result.set(mainChunk, header.length);
      
      // Download
      const blob = new Blob([result], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `terrain_${$("seed").value}.vox`;
      a.click();
      URL.revokeObjectURL(url);
      
      setHud(`Exported ${voxels.length} voxels to .vox file!\nSize: ${w}√ó${h}√ó${maxZ}\n‚úì Terrain types preserved (roads, rivers, grass types)`);
    }
    
    // Import .vox file and set terrain levels
    function importVoxFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const buffer = e.target.result;
          const view = new DataView(buffer);
          let offset = 0;
          
          // Read header
          const magic = String.fromCharCode(
            view.getUint8(offset++),
            view.getUint8(offset++),
            view.getUint8(offset++),
            view.getUint8(offset++)
          );
          
          if (magic !== 'VOX ') {
            throw new Error('Not a valid .vox file (missing VOX header)');
          }
          
          const version = view.getUint32(offset, true);
          offset += 4;
          
          (globalThis.__uiLog ? globalThis.__uiLog(String('VOX version:', version)) : console.log('VOX version:', version));
          
          let sizeX = 0, sizeY = 0, sizeZ = 0;
          const voxelData = [];
          let foundSize = false;
          
          // Parse chunks recursively
          function parseChunk(maxOffset) {
            while (offset < maxOffset && offset < buffer.byteLength - 12) {
              const chunkId = String.fromCharCode(
                view.getUint8(offset),
                view.getUint8(offset + 1),
                view.getUint8(offset + 2),
                view.getUint8(offset + 3)
              );
              offset += 4;
              
              const chunkSize = view.getUint32(offset, true);
              offset += 4;
              const childSize = view.getUint32(offset, true);
              offset += 4;
              
              (globalThis.__uiLog ? globalThis.__uiLog(String(`Chunk: ${chunkId}, content: ${chunkSize}, children: ${childSize}`)) : console.log(`Chunk: ${chunkId}, content: ${chunkSize}, children: ${childSize}`));
              
              const chunkDataStart = offset;
              const chunkDataEnd = offset + chunkSize;
              const childDataEnd = chunkDataEnd + childSize;
              
              if (chunkId === 'SIZE') {
                sizeX = view.getUint32(offset, true);
                sizeY = view.getUint32(offset + 4, true);
                sizeZ = view.getUint32(offset + 8, true);
                foundSize = true;
                (globalThis.__uiLog ? globalThis.__uiLog(String(`SIZE: ${sizeX} √ó ${sizeY} √ó ${sizeZ}`)) : console.log(`SIZE: ${sizeX} √ó ${sizeY} √ó ${sizeZ}`));
              } else if (chunkId === 'XYZI') {
                const numVoxels = view.getUint32(offset, true);
                let voxOffset = offset + 4;
                
                for (let i = 0; i < numVoxels; i++) {
                  const x = view.getUint8(voxOffset++);
                  const y = view.getUint8(voxOffset++);
                  const z = view.getUint8(voxOffset++);
                  const colorIndex = view.getUint8(voxOffset++);
                  voxelData.push({ x, y, z, colorIndex });
                }
                (globalThis.__uiLog ? globalThis.__uiLog(String(`XYZI: ${numVoxels} voxels`)) : console.log(`XYZI: ${numVoxels} voxels`));
              } else if (chunkId === 'MAIN') {
                (globalThis.__uiLog ? globalThis.__uiLog(String('MAIN chunk - parsing children')) : console.log('MAIN chunk - parsing children'));
              } else if (chunkId === 'PACK') {
                console.log('PACK chunk (multi-model) - using first model');
              } else {
                (globalThis.__uiLog ? globalThis.__uiLog(String(`Skipping unknown chunk: ${chunkId}`)) : console.log(`Skipping unknown chunk: ${chunkId}`));
              }
              
              // Move to chunk data end
              offset = chunkDataEnd;
              
              // Parse children if present
              if (childSize > 0) {
                parseChunk(childDataEnd);
                offset = childDataEnd;
              }
            }
          }
          
          // Start parsing from root
          parseChunk(buffer.byteLength);
          
          if (!foundSize) {
            throw new Error('Invalid .vox file: missing SIZE chunk');
          }
          
          if (voxelData.length === 0) {
            throw new Error('Invalid .vox file: no voxel data found');
          }
          
          // Update grid size
          $("w").value = sizeX;
          $("h").value = sizeY;
          
          const w = sizeX;
          const h = sizeY;
          
          // Find max height for 3D grid
          let maxHeight = 0;
          for (const voxel of voxelData) {
            maxHeight = Math.max(maxHeight, voxel.z + 1);
          }
          
          // Create 3D voxel grid (for checking wall voxel existence)
          // Now stores voxel TYPES (0-255) instead of just binary 0/1
          const voxelGrid = new Uint8Array(w * h * maxHeight);
          for (const voxel of voxelData) {
            const gridX = voxel.x;
            const gridZ = voxel.y;
            const level = voxel.z; // 0-indexed
            if (gridX < w && gridZ < h && level < maxHeight) {
              const idx3d = level * (w * h) + gridZ * w + gridX;
              // Store the voxel type (colorIndex from .vox file)
              voxelGrid[idx3d] = voxel.colorIndex || VOXEL_TYPES.GRASS_FLAT;
            }
          }
          
          // Create heightmap from voxel data
          // Find the highest voxel at each (x, y) position
          const heightMap = new Int16Array(w * h);
          
          for (const voxel of voxelData) {
            // MagicaVoxel: x=x, y=depth, z=height
            // Our system: x=x, z=depth, level=height
            const gridX = voxel.x;
            const gridZ = voxel.y;
            const height = voxel.z + 1; // +1 because z is 0-indexed
            
            if (gridX < w && gridZ < h) {
              const idx = gridZ * w + gridX;
              heightMap[idx] = Math.max(heightMap[idx], height);
            }
          }
          
          // Store both heightmap and 3D voxel grid
          levels = heightMap;
          importedVoxelGrid = voxelGrid;
          importedVoxelGridDims = { w, h, depth: maxHeight };

            // Auto-mark grass surface steps as ramps (type-only; does not change mesh slope).
            const grassRampConversions = autoConvertGrassStepsToRamps();
            (globalThis.__uiLog ? globalThis.__uiLog(String(`Grass ramps auto-marked: ${grassRampConversions}`)) : console.log(`Grass ramps auto-marked: ${grassRampConversions}`));

            // Summarize imported voxel types for quick sanity-checking on mobile.
            const typeCounts = countImportedVoxelTypes();
            if (typeCounts){
              (globalThis.__uiLog ? globalThis.__uiLog(String(`Imported types: road(flat)=${typeCounts.roadFlats} road(ramp)=${typeCounts.roadRamps} grass(flat)=${typeCounts.grassFlats} grass(ramp)=${typeCounts.grassRamps} river=${typeCounts.river}`)) 
                                 : console.log(`Imported types: road(flat)=${typeCounts.roadFlats} road(ramp)=${typeCounts.roadRamps} grass(flat)=${typeCounts.grassFlats} grass(ramp)=${typeCounts.grassRamps} river=${typeCounts.river}`));
            }

          
          // Set flag so regenerate() uses imported levels instead of generating new ones
          useImportedLevels = true;
          
          // Update maxLevel to accommodate imported data
          const maxImportedLevel = Math.max(...heightMap);
          if (maxImportedLevel > parseInt($("maxLvl").value)) {
            $("maxLvl").value = maxImportedLevel;
          }
          
          regenerate();
          
          // Automatically convert any vertical road transitions to ramps
          const conversions = autoConvertRoadStepsToRamps();
          if (conversions > 0) {
            regenerate(); // Rebuild with ramps
          }


          // Auto-suggest grass ramps on height steps (direction preference: N > E/W > S)
          const grassConversions = autoConvertGrassStepsToRamps();
          if (grassConversions > 0) {
            regenerate();
          }
          
          setHud(`Imported .vox file with arch/tunnel support!
Size: ${sizeX}√ó${sizeY}√ó${sizeZ}
Voxels: ${voxelData.length}
Max height: ${maxImportedLevel}
File: ${file.name}${conversions > 0 ? "\nAuto-converted " + conversions + " road steps to ramps" : ""}${grassConversions > 0 ? "\nAuto-marked " + grassConversions + " grass steps as ramps" : ""}
          
Tip: Click "Regenerate" to return to procedural generation`);
          
        } catch (err) {
          alert('Error importing .vox file: ' + err.message);
          console.error('VOX import error:', err);
          console.error('Error at offset:', err.offset || 'unknown');
        }
      };
      
      reader.readAsArrayBuffer(file);
    }
    
    // Wire up event handlers
    $("exportVox").addEventListener("click", exportAsVox);
    
    $("importVox").addEventListener("click", () => {
      $("voxFileInput").click();
    });
    
    $("voxFileInput").addEventListener("change", (e) => {
      if (e.target.files.length > 0) {
        importVoxFile(e.target.files[0]);
      }
    });

    // ============================================================================
    // TERRAIN TYPES - ROAD GENERATION
    // ============================================================================
    
    // Helper: Ensure voxelGrid exists (create from levels if needed)
    function ensureVoxelGrid() {
      if (importedVoxelGrid && importedVoxelGridDims.depth > 0) {
        return true; // Already have voxel grid
      }
      
      if (!levels || levels.length === 0) {
        return false; // No terrain at all
      }
      
      // Create voxel grid from procedural terrain (levels heightmap)
      const w = parseInt($("w").value);
      const h = parseInt($("h").value);
      const maxLvl = parseInt($("maxLvl").value);
      
      importedVoxelGrid = new Uint8Array(w * h * maxLvl);
      importedVoxelGridDims = { w, h, depth: maxLvl };
      
      // Fill voxel grid based on heightmap
      for (let z = 0; z < h; z++) {
        for (let x = 0; x < w; x++) {
          const idx2d = z * w + x;
          const height = levels[idx2d];
          
          // Fill from bottom up to height
          for (let y = 0; y < height && y < maxLvl; y++) {
            const idx3d = y * (w * h) + z * w + x;
            importedVoxelGrid[idx3d] = VOXEL_TYPES.GRASS_FLAT;
          }
        }
      }
      
      setHud(`Created voxel grid from procedural terrain (${w}√ó${h}√ó${maxLvl})`);
      return true;
    }
    
    // Simple test: Create a straight road across the middle
    function generateTestRoad() {
      if (!ensureVoxelGrid()) {
        alert('Please generate terrain first! Go to Layout tab and click Regenerate.');
        return;
      }
      
      const { w, h, depth } = importedVoxelGridDims;
      const roadWidth = parseInt($("roadWidth").value) || 2;
      
      let roadVoxelsPlaced = 0;
      const midZ = Math.floor(h / 2);
      
      // Create a straight road from west to east
      for (let x = 0; x < w; x++) {
        const idx2d = midZ * w + x;
        const terrainHeight = levels[idx2d];
        
        if (terrainHeight > 0) {
          const roadLevel = terrainHeight - 1;
          
          // Place road voxels
          for (let widthOffset = 0; widthOffset < roadWidth; widthOffset++) {
            const z = midZ - Math.floor(roadWidth / 2) + widthOffset;
            if (z >= 0 && z < h && roadLevel >= 0 && roadLevel < depth) {
              const idx3d = roadLevel * (w * h) + z * w + x;
              importedVoxelGrid[idx3d] = VOXEL_TYPES.ROAD_EW;
              roadVoxelsPlaced++;
            }
          }
        }
      }
      
      regenerate();
      
      // Automatically convert vertical road transitions to ramps
      const conversions = autoConvertRoadStepsToRamps();
      if (conversions > 0) {
        regenerate(); // Rebuild with ramps
        setHud(`Generated test road: ${roadVoxelsPlaced} voxels placed\nAuto-converted ${conversions} vertical steps to ramps\nShould see BROWN DIRT path (no grass)`);
      } else {
        setHud(`Generated test road: ${roadVoxelsPlaced} voxels placed\nShould see BROWN DIRT path (no grass)`);
      }
    }
    
    function generateRoads() {
      if (!ensureVoxelGrid()) {
        alert('Please generate terrain first! Go to Layout tab and click Regenerate.');
        return;
      }
      
      const { w, h, depth } = importedVoxelGridDims;
      const roadWidth = parseInt($("roadWidth").value) || 2;
      
      // Find peaks (high elevation areas)
      const peaks = [];
      const minPeakHeight = Math.max(1, depth - 3);
      
      for (let z = 0; z < h; z++) {
        for (let x = 0; x < w; x++) {
          const idx2d = z * w + x;
          const height = levels[idx2d];
          if (height >= minPeakHeight) {
            peaks.push({ x, z, height });
          }
        }
      }
      
      if (peaks.length < 2) {
        setHud('Need at least 2 peaks to generate roads. Try lower terrain or import different .vox file.');
        return;
      }
      
      // Connect peaks with Bresenham line algorithm
      let roadVoxelsPlaced = 0;
      
      for (let i = 0; i < peaks.length - 1; i++) {
        const p1 = peaks[i];
        const p2 = peaks[i + 1];
        
        // Bresenham line
        const dx = Math.abs(p2.x - p1.x);
        const dz = Math.abs(p2.z - p1.z);
        const sx = p1.x < p2.x ? 1 : -1;
        const sz = p1.z < p2.z ? 1 : -1;
        let err = dx - dz;
        
        let x = p1.x;
        let z = p1.z;
        
        while (true) {
          // Get height at current position
          const idx2d = z * w + x;
          const terrainHeight = levels[idx2d];
          
          // Place road at top of terrain (one level down from surface)
          if (terrainHeight > 0) {
            const roadLevel = terrainHeight - 1;
            
            // Determine road direction based on path
            let roadType = VOXEL_TYPES.ROAD_NS;
            if (Math.abs(sx) > Math.abs(sz)) {
              roadType = VOXEL_TYPES.ROAD_EW;
            }
            
            // Place center road voxel
            const idx3d = roadLevel * (w * h) + z * w + x;
            if (roadLevel >= 0 && roadLevel < depth) {
              importedVoxelGrid[idx3d] = roadType;
              roadVoxelsPlaced++;
              
              // Add width
              for (let wd = 1; wd < roadWidth; wd++) {
                if (roadType === VOXEL_TYPES.ROAD_NS || roadType === VOXEL_TYPES.ROAD_EW) {
                  // Perpendicular expansion
                  if (roadType === VOXEL_TYPES.ROAD_NS) {
                    // Expand in X direction
                    if (x + wd < w) {
                      const idxWide = roadLevel * (w * h) + z * w + (x + wd);
                      importedVoxelGrid[idxWide] = roadType;
                      roadVoxelsPlaced++;
                    }
                    if (x - wd >= 0) {
                      const idxWide = roadLevel * (w * h) + z * w + (x - wd);
                      importedVoxelGrid[idxWide] = roadType;
                      roadVoxelsPlaced++;
                    }
                  } else {
                    // Expand in Z direction
                    if (z + wd < h) {
                      const idxWide = roadLevel * (w * h) + (z + wd) * w + x;
                      importedVoxelGrid[idxWide] = roadType;
                      roadVoxelsPlaced++;
                    }
                    if (z - wd >= 0) {
                      const idxWide = roadLevel * (w * h) + (z - wd) * w + x;
                      importedVoxelGrid[idxWide] = roadType;
                      roadVoxelsPlaced++;
                    }
                  }
                }
              }
            }
          }
          
          if (x === p2.x && z === p2.z) break;
          
          const e2 = 2 * err;
          if (e2 > -dz) {
            err -= dz;
            x += sx;
          }
          if (e2 < dx) {
            err += dx;
            z += sz;
          }
        }
      }
      
      // Trigger regeneration to rebuild meshes with new road voxels
      regenerate();
      
      // Automatically convert vertical road transitions to ramps
      const conversions = autoConvertRoadStepsToRamps();
      if (conversions > 0) {
        regenerate(); // Rebuild again with ramps
        setHud(`Generated roads connecting ${peaks.length} peaks (${roadVoxelsPlaced} road voxels)\nAuto-converted ${conversions} vertical steps to ramps`);
      } else {
        setHud(`Generated roads connecting ${peaks.length} peaks (${roadVoxelsPlaced} road voxels placed)`);
      }
    }
    
    // Generate road ramps connecting different elevation levels
    function generateRoadRamps() {
      if (!ensureVoxelGrid()) {
        alert('Please generate terrain first! Go to Layout tab and click Regenerate.');
        return;
      }
      
      const { w, h, depth } = importedVoxelGridDims;
      const count = parseInt($("roadRampCount")?.value) || 12;
      
      // Find all potential ramp locations (where terrain goes up by 1)
      const rampSpots = [];
      
      for (let z = 0; z < h; z++) {
        for (let x = 0; x < w; x++) {
          const idx2d = z * w + x;
          const height = levels[idx2d];
          
          // Check all 4 cardinal directions
          const neighbors = [
            { x: x, z: z - 1, dir: 'N', rampType: VOXEL_TYPES.ROAD_RAMP_N, roadType: VOXEL_TYPES.ROAD_NS },
            { x: x, z: z + 1, dir: 'S', rampType: VOXEL_TYPES.ROAD_RAMP_S, roadType: VOXEL_TYPES.ROAD_NS },
            { x: x + 1, z: z, dir: 'E', rampType: VOXEL_TYPES.ROAD_RAMP_E, roadType: VOXEL_TYPES.ROAD_EW },
            { x: x - 1, z: z, dir: 'W', rampType: VOXEL_TYPES.ROAD_RAMP_W, roadType: VOXEL_TYPES.ROAD_EW }
          ];
          
          for (const n of neighbors) {
            if (n.x >= 0 && n.x < w && n.z >= 0 && n.z < h) {
              const nIdx = n.z * w + n.x;
              const nHeight = levels[nIdx];
              
              // Found a spot where neighbor is 1 level higher
              if (nHeight === height + 1) {
                rampSpots.push({
                  lowX: x,
                  lowZ: z,
                  lowHeight: height,
                  highX: n.x,
                  highZ: n.z,
                  highHeight: nHeight,
                  direction: n.dir,
                  rampType: n.rampType,
                  roadType: n.roadType
                });
              }
            }
          }
        }
      }
      
      if (rampSpots.length === 0) {
        setHud('No suitable locations for road ramps found');
        return;
      }
      
      // Shuffle and select random ramp spots
      for (let i = rampSpots.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [rampSpots[i], rampSpots[j]] = [rampSpots[j], rampSpots[i]];
      }
      
      const selectedRamps = rampSpots.slice(0, Math.min(count, rampSpots.length));
      let rampVoxelsPlaced = 0;
      
      // Place road ramp voxels for each selected ramp
      for (const ramp of selectedRamps) {
        // Place the ramp voxel at the LOW level (the ramp itself)
        if (ramp.lowHeight > 0 && ramp.lowHeight <= depth) {
          const rampIdx = (ramp.lowHeight - 1) * (w * h) + ramp.lowZ * w + ramp.lowX;
          importedVoxelGrid[rampIdx] = ramp.rampType;
          rampVoxelsPlaced++;
        }
        
        // Place flat road at the HIGH level (destination)
        if (ramp.highHeight > 0 && ramp.highHeight <= depth) {
          const highIdx = (ramp.highHeight - 1) * (w * h) + ramp.highZ * w + ramp.highX;
          importedVoxelGrid[highIdx] = ramp.roadType;
          rampVoxelsPlaced++;
        }
        
        // Extend road a bit from the high point for better visibility
        const extendLength = 2;
        const dirMap = {
          'N': { dx: 0, dz: -1 },
          'S': { dx: 0, dz: 1 },
          'E': { dx: 1, dz: 0 },
          'W': { dx: -1, dz: 0 }
        };
        
        const dir = dirMap[ramp.direction];
        for (let i = 1; i <= extendLength; i++) {
          const extX = ramp.highX + (dir.dx * i);
          const extZ = ramp.highZ + (dir.dz * i);
          
          if (extX >= 0 && extX < w && extZ >= 0 && extZ < h && ramp.highHeight > 0) {
            const extIdx2d = extZ * w + extX;
            if (levels[extIdx2d] === ramp.highHeight) {
              const extIdx = (ramp.highHeight - 1) * (w * h) + extZ * w + extX;
              importedVoxelGrid[extIdx] = ramp.roadType;
              rampVoxelsPlaced++;
            }
          }
        }
      }
      
      regenerate();
      
      // Automatically convert any vertical road transitions to ramps
      const extraConversions = autoConvertRoadStepsToRamps();
      if (extraConversions > 0) {
        regenerate(); // Rebuild with additional ramps
        setHud(`Generated ${selectedRamps.length} road ramps (${rampVoxelsPlaced} voxels placed)\nAuto-converted ${extraConversions} additional vertical steps to ramps`);
      } else {
        setHud(`Generated ${selectedRamps.length} road ramps (${rampVoxelsPlaced} voxels placed)`);
      }
    }
    
    // Automatically convert vertical road transitions to ramps
    // When a road block is placed directly above/below another road block,
    // the lower one becomes a ramp in the direction of the upper one
    function autoConvertRoadStepsToRamps() {
      if (!importedVoxelGrid) return 0;
      
      const { w, h, depth } = importedVoxelGridDims;
      let conversions = 0;
      
      // Helper to check if a voxel is a road type (not already a ramp)
      const isRoad = (type) => {
        return type >= VOXEL_TYPES.ROAD_NS && type <= VOXEL_TYPES.ROAD_CROSS;
      };
      
      // Helper to check if a voxel is any road (including ramps)
      const isAnyRoad = (type) => {
        return type >= VOXEL_TYPES.ROAD_NS && type <= VOXEL_TYPES.ROAD_RAMP_W;
      };
      
      // Scan all voxels
      for (let y = 0; y < depth - 1; y++) {  // -1 because we check y+1
        for (let z = 0; z < h; z++) {
          for (let x = 0; x < w; x++) {
            const currentIdx = y * (w * h) + z * w + x;
            const currentType = importedVoxelGrid[currentIdx];
            
            // Only process if current voxel is a flat road (not already a ramp)
            if (!isRoad(currentType)) continue;
            
            // Check voxel directly above
            const aboveIdx = (y + 1) * (w * h) + z * w + x;
            const aboveType = importedVoxelGrid[aboveIdx];
            
            // If there's a road directly above, we need to create a ramp
            if (isAnyRoad(aboveType)) {
              // Determine ramp direction by checking which neighbor the upper road came from
              let rampType = null;
              
              // Check all 4 horizontal neighbors at the UPPER level
              const neighbors = [
                { x: x, z: z - 1, dir: 'N', rampType: VOXEL_TYPES.ROAD_RAMP_N },  // North
                { x: x, z: z + 1, dir: 'S', rampType: VOXEL_TYPES.ROAD_RAMP_S },  // South
                { x: x + 1, z: z, dir: 'E', rampType: VOXEL_TYPES.ROAD_RAMP_E },  // East
                { x: x - 1, z: z, dir: 'W', rampType: VOXEL_TYPES.ROAD_RAMP_W }   // West
              ];
              
              // Find which neighbor at the CURRENT level has a road that could connect
              for (const n of neighbors) {
                if (n.x >= 0 && n.x < w && n.z >= 0 && n.z < h) {
                  const neighborIdx = y * (w * h) + n.z * w + n.x;
                  const neighborType = importedVoxelGrid[neighborIdx];
                  
                  // If there's a road at this neighbor position at the same level,
                  // the ramp goes UP in that direction
                  if (isAnyRoad(neighborType)) {
                    rampType = n.rampType;
                    break;
                  }
                }
              }
              
              // If we couldn't determine direction from horizontal neighbors,
              // use the road type to infer direction
              if (!rampType) {
                // Default based on current road orientation
                if (currentType === VOXEL_TYPES.ROAD_NS) {
                  // For N-S roads, default to North ramp
                  rampType = VOXEL_TYPES.ROAD_RAMP_N;
                } else if (currentType === VOXEL_TYPES.ROAD_EW) {
                  // For E-W roads, default to East ramp
                  rampType = VOXEL_TYPES.ROAD_RAMP_E;
                } else {
                  // For corners and crosses, pick first available
                  rampType = VOXEL_TYPES.ROAD_RAMP_N;
                }
              }
              
              // Convert to ramp
              if (rampType) {
                importedVoxelGrid[currentIdx] = rampType;
                conversions++;
              }
            }
          }
        }
      }
      
      return conversions;
    }


    // Automatically convert grass surface steps (height +1 neighbor) into grass ramps.
    // This is a visual/material hint only (geometry is still generated from the voxel surface).
    // Direction preference (when multiple candidates): North > East/West > South.
    function autoConvertGrassStepsToRamps() {
      if (!importedVoxelGrid || !importedVoxelGridDims?.depth || !levels) return 0;

      const { w, h, depth } = importedVoxelGridDims;
      const WH = w * h;

      // Only convert these top surface types; avoid touching roads/rivers/stone.
      const isConvertibleGrassTop = (t) => (
        t === VOXEL_TYPES.GRASS_FLAT ||
        t === VOXEL_TYPES.GRASS_RAMP_N ||
        t === VOXEL_TYPES.GRASS_RAMP_S ||
        t === VOXEL_TYPES.GRASS_RAMP_E ||
        t === VOXEL_TYPES.GRASS_RAMP_W
      );

      const isBlockedTop = (t) => {
        if (t >= VOXEL_TYPES.ROAD_NS && t <= VOXEL_TYPES.ROAD_RAMP_W) return true;
        if (t >= VOXEL_TYPES.RIVER_N && t <= VOXEL_TYPES.RIVER_SW) return true;
        if (t === VOXEL_TYPES.STONE) return true;
        return false;
      };

      // Find the top solid voxel at a column (x,z). Returns { y, t } or null.
      const topSolidAt = (x, z) => {
        // Use heightmap as a fast starting point, but fall back to scan for arches/holes.
        const idx2d = z * w + x;
        let yStart = (levels && levels.length === WH) ? Math.min(depth - 1, Math.max(0, levels[idx2d] - 1)) : (depth - 1);

        for (let y = yStart; y >= 0; y--) {
          const idx3d = y * WH + z * w + x;
          const t = importedVoxelGrid[idx3d] || 0;
          if (isVoxelSolid(t)) return { y, t };
        }
        return null;
      };

      // NOTE: MagicaVoxel stores (x, y=depth, z=height). This app maps MagicaVoxel +Y to our +Z (gridZ).
      // If you consider +Y in the .vox file to be ‚ÄúNorth‚Äù, then ‚ÄúNorth‚Äù here is dz=+1.
      const DIRS = [
        { key: "N", dx: 0, dz: 1,  ramp: VOXEL_TYPES.GRASS_RAMP_N }, // preferred: North (+Y in .vox => +Z here)
        { key: "E", dx: 1, dz: 0,  ramp: VOXEL_TYPES.GRASS_RAMP_E },
        { key: "W", dx: -1, dz: 0, ramp: VOXEL_TYPES.GRASS_RAMP_W },
        { key: "S", dx: 0, dz: -1, ramp: VOXEL_TYPES.GRASS_RAMP_S }, // least preferred: South
      ];

      let conversions = 0;

      for (let z = 0; z < h; z++) {
        for (let x = 0; x < w; x++) {
          const top = topSolidAt(x, z);
          if (!top) continue;

          // Only operate on the visible surface voxel.
          if (!isConvertibleGrassTop(top.t) || isBlockedTop(top.t)) continue;

          // Find best neighbor that is exactly 1 higher.
          let targetRamp = null;
          for (const d of DIRS) {
            const nx = x + d.dx;
            const nz = z + d.dz;
            if (nx < 0 || nx >= w || nz < 0 || nz >= h) continue;

            const nTop = topSolidAt(nx, nz);
            if (!nTop) continue;

            // Only ramp when neighbor is exactly 1 higher and not a blocked surface.
            if (nTop.y === top.y + 1 && !isBlockedTop(nTop.t)) {
              targetRamp = d.ramp;
              break; // direction preference baked into DIRS order
            }
          }

          const idx3dTop = top.y * WH + z * w + x;
          const desired = targetRamp || VOXEL_TYPES.GRASS_FLAT;

          if (importedVoxelGrid[idx3dTop] !== desired) {
            importedVoxelGrid[idx3dTop] = desired;
            conversions++;
          }
        }
      }

      return conversions;
    }


    function clearRoads() {
      if (!ensureVoxelGrid()) {
        alert('No terrain loaded!');
        return;
      }
      
      const { w, h, depth } = importedVoxelGridDims;
      let cleared = 0;
      
      for (let y = 0; y < depth; y++) {
        for (let z = 0; z < h; z++) {
          for (let x = 0; x < w; x++) {
            const idx = y * (w * h) + z * w + x;
            const voxelType = importedVoxelGrid[idx];
            if (voxelType >= VOXEL_TYPES.ROAD_NS && voxelType <= VOXEL_TYPES.ROAD_RAMP_W) {
              importedVoxelGrid[idx] = VOXEL_TYPES.GRASS_FLAT;
              cleared++;
            }
          }
        }
      }
      
      regenerate();
      setHud(`Cleared ${cleared} road voxels`);
    }
    
    // ============================================================================
    // TERRAIN TYPES - RIVER GENERATION
    // ============================================================================
    
    function generateRiver() {
      if (!ensureVoxelGrid()) {
        alert('Please generate terrain first! Go to Layout tab and click Regenerate.');
        return;
      }
      
      const { w, h, depth } = importedVoxelGridDims;
      const riverWidth = parseInt($("riverWidth").value) || 2;
      
      // Find highest point
      let highestX = 0, highestZ = 0, highestY = 0;
      for (let z = 0; z < h; z++) {
        for (let x = 0; x < w; x++) {
          const idx2d = z * w + x;
          const height = levels[idx2d];
          if (height > highestY) {
            highestY = height;
            highestX = x;
            highestZ = z;
          }
        }
      }
      
      if (highestY <= 1) {
        setHud('Terrain too flat - no suitable starting point for river');
        return;
      }
      
      // Flow downhill
      let x = highestX;
      let z = highestZ;
      let steps = 0;
      const maxSteps = w * h;
      let riverVoxelsPlaced = 0;
      
      while (steps < maxSteps) {
        const idx2d = z * w + x;
        const currentHeight = levels[idx2d];
        
        if (currentHeight <= 0) break;
        
        // Place river at current terrain height (one level down)
        const riverLevel = currentHeight - 1;
        
        // Find lowest neighbor
        let lowestX = x, lowestZ = z, lowestHeight = currentHeight;
        let riverType = VOXEL_TYPES.RIVER_S; // default
        
        const neighbors = [
          { x: x, z: z - 1, dir: VOXEL_TYPES.RIVER_N },
          { x: x, z: z + 1, dir: VOXEL_TYPES.RIVER_S },
          { x: x + 1, z: z, dir: VOXEL_TYPES.RIVER_E },
          { x: x - 1, z: z, dir: VOXEL_TYPES.RIVER_W },
        ];
        
        for (const n of neighbors) {
          if (n.x < 0 || n.x >= w || n.z < 0 || n.z >= h) continue;
          const nIdx = n.z * w + n.x;
          const nHeight = levels[nIdx];
          if (nHeight < lowestHeight) {
            lowestHeight = nHeight;
            lowestX = n.x;
            lowestZ = n.z;
            riverType = n.dir;
          }
        }
        
        // Place river voxel
        if (riverLevel >= 0 && riverLevel < depth) {
          const idx3d = riverLevel * (w * h) + z * w + x;
          importedVoxelGrid[idx3d] = riverType;
          riverVoxelsPlaced++;
          
          // Add width
          for (let wd = 1; wd < riverWidth; wd++) {
            if (riverType === VOXEL_TYPES.RIVER_N || riverType === VOXEL_TYPES.RIVER_S) {
              // Expand in X direction
              if (x + wd < w) {
                const idxWide = riverLevel * (w * h) + z * w + (x + wd);
                importedVoxelGrid[idxWide] = riverType;
                riverVoxelsPlaced++;
              }
              if (x - wd >= 0) {
                const idxWide = riverLevel * (w * h) + z * w + (x - wd);
                importedVoxelGrid[idxWide] = riverType;
                riverVoxelsPlaced++;
              }
            } else {
              // Expand in Z direction
              if (z + wd < h) {
                const idxWide = riverLevel * (w * h) + (z + wd) * w + x;
                importedVoxelGrid[idxWide] = riverType;
                riverVoxelsPlaced++;
              }
              if (z - wd >= 0) {
                const idxWide = riverLevel * (w * h) + (z - wd) * w + x;
                importedVoxelGrid[idxWide] = riverType;
                riverVoxelsPlaced++;
              }
            }
          }
        }
        
        // Move to lowest neighbor
        if (lowestX === x && lowestZ === z) break; // No lower neighbor
        x = lowestX;
        z = lowestZ;
        steps++;
      }
      
      regenerate();
      setHud(`Generated river (${steps} steps, ${riverVoxelsPlaced} river voxels placed)`);
    }
    
    function clearRivers() {
      if (!ensureVoxelGrid()) {
        alert('No terrain loaded!');
        return;
      }
      
      const { w, h, depth } = importedVoxelGridDims;
      let cleared = 0;
      
      for (let y = 0; y < depth; y++) {
        for (let z = 0; z < h; z++) {
          for (let x = 0; x < w; x++) {
            const idx = y * (w * h) + z * w + x;
            const voxelType = importedVoxelGrid[idx];
            if (voxelType >= VOXEL_TYPES.RIVER_N && voxelType <= VOXEL_TYPES.RIVER_SW) {
              importedVoxelGrid[idx] = VOXEL_TYPES.GRASS_FLAT;
              cleared++;
            }
          }
        }
      }
      
      regenerate();
      setHud(`Cleared ${cleared} river voxels`);
    }
    
    // ============================================================================
    // TERRAIN TYPES - FOREST/TREE BARRIER GENERATION
    // ============================================================================
    
    // Test: Create a circular forest patch in the center
    function generateTestForest() {
      if (!ensureVoxelGrid()) {
        alert('Please generate terrain first! Go to Layout tab and click Regenerate.');
        return;
      }
      
      const { w, h, depth } = importedVoxelGridDims;
      let forestVoxelsPlaced = 0;
      
      const centerX = Math.floor(w / 2);
      const centerZ = Math.floor(h / 2);
      const radius = Math.min(w, h) / 6; // Patch is 1/6 of terrain size
      
      // Create a circular forest patch
      for (let z = 0; z < h; z++) {
        for (let x = 0; x < w; x++) {
          const dx = x - centerX;
          const dz = z - centerZ;
          const dist = Math.sqrt(dx * dx + dz * dz);
          
          if (dist < radius) {
            const idx2d = z * w + x;
            const terrainHeight = levels[idx2d];
            
            if (terrainHeight > 0) {
              const surfaceLevel = terrainHeight - 1;
              
              // Place forest mask at surface
              if (surfaceLevel >= 0 && surfaceLevel < depth) {
                const idx3d = surfaceLevel * (w * h) + z * w + x;
                
                // Inner circle = forest, outer ring = barrier (hedgerow)
                const innerRadius = radius * 0.7;
                if (dist < innerRadius) {
                  importedVoxelGrid[idx3d] = VOXEL_TYPES.FOREST;
                } else {
                  importedVoxelGrid[idx3d] = VOXEL_TYPES.TREE_BARRIER;
                }
                forestVoxelsPlaced++;
              }
            }
          }
        }
      }
      
      regenerate();
      setHud(`Generated test forest patch: ${forestVoxelsPlaced} voxels marked
Center forest (sparse trees) with outer barrier ring (dense hedgerow)
Go to Actions tab ‚Üí Toggle "Tree: on" to see trees spawn`);
    }
    
    // Auto: Scatter forest patches across terrain using noise
    function generateForests() {
      if (!ensureVoxelGrid()) {
        alert('Please generate terrain first! Go to Layout tab and click Regenerate.');
        return;
      }
      
      const { w, h, depth } = importedVoxelGridDims;
      const forestDensity = parseFloat($("forestDensity").value) || 0.3;
      const barrierDensity = parseFloat($("barrierDensity").value) || 0.2;
      
      // Create noise-based forest distribution
      const seed = readParams().seed + "::forests";
      const noiseForest = new Simplex2D(makeRng(seed));
      const noiseBarrier = new Simplex2D(makeRng(seed + "::barrier"));
      
      let forestVoxels = 0;
      let barrierVoxels = 0;
      
      for (let z = 0; z < h; z++) {
        for (let x = 0; x < w; x++) {
          const idx2d = z * w + x;
          const terrainHeight = levels[idx2d];
          
          if (terrainHeight > 0) {
            const surfaceLevel = terrainHeight - 1;
            
            if (surfaceLevel >= 0 && surfaceLevel < depth) {
              const idx3d = surfaceLevel * (w * h) + z * w + x;
              
              // Check if this voxel is already a road/river (don't place forests there)
              const currentType = importedVoxelGrid[idx3d];
              const isRoad = currentType >= VOXEL_TYPES.ROAD_NS && currentType <= VOXEL_TYPES.ROAD_RAMP_W;
              const isRiver = currentType >= VOXEL_TYPES.RIVER_N && currentType <= VOXEL_TYPES.RIVER_SW;
              
              if (isRoad || isRiver) continue;
              
              // Sample noise at this location (scale determines cluster size)
              const nx = x / w;
              const nz = z / h;
              const forestNoise = noiseForest.noise(nx * 3.5, nz * 3.5); // Lower scale = larger patches
              const barrierNoise = noiseBarrier.noise(nx * 5.0, nz * 5.0); // Higher scale = smaller patches
              
              // Use threshold to create patches
              if (forestNoise > (1.0 - forestDensity * 2)) {
                importedVoxelGrid[idx3d] = VOXEL_TYPES.FOREST;
                forestVoxels++;
              } else if (barrierNoise > (1.0 - barrierDensity * 2)) {
                importedVoxelGrid[idx3d] = VOXEL_TYPES.TREE_BARRIER;
                barrierVoxels++;
              }
            }
          }
        }
      }
      
      regenerate();
      setHud(`Generated forests: ${forestVoxels} forest voxels, ${barrierVoxels} barrier voxels
Forest density: ${forestDensity}, Barrier density: ${barrierDensity}
Go to Actions tab ‚Üí Toggle "Tree: on" to see trees spawn`);
    }
    
    // Clear all forest/barrier masks
    function clearForests() {
      if (!ensureVoxelGrid()) {
        alert('No terrain loaded!');
        return;
      }
      
      const { w, h, depth } = importedVoxelGridDims;
      let cleared = 0;
      
      for (let y = 0; y < depth; y++) {
        for (let z = 0; z < h; z++) {
          for (let x = 0; x < w; x++) {
            const idx = y * (w * h) + z * w + x;
            const voxelType = importedVoxelGrid[idx];
            if (voxelType === VOXEL_TYPES.FOREST || voxelType === VOXEL_TYPES.TREE_BARRIER) {
              importedVoxelGrid[idx] = VOXEL_TYPES.GRASS_FLAT;
              cleared++;
            }
          }
        }
      }
      
      regenerate();
      setHud(`Cleared ${cleared} forest/barrier voxels`);
    }
    
    // Wire up terrain types event handlers
    if ($("btnTestRoad")) {
      $("btnTestRoad").addEventListener("click", generateTestRoad);
    }
    if ($("btnGenerateRoads")) {
      $("btnGenerateRoads").addEventListener("click", generateRoads);
    }
    if ($("btnGenerateRoadRamps")) {
      $("btnGenerateRoadRamps").addEventListener("click", generateRoadRamps);
    }
    if ($("btnConvertRoadSteps")) {
      $("btnConvertRoadSteps").addEventListener("click", () => {
        const conversions = autoConvertRoadStepsToRamps();
        if (conversions > 0) {
          regenerate();
          setHud(`Converted ${conversions} vertical road steps to ramps`);
        } else {
          setHud('No vertical road steps found to convert');
        }
      });
    }
    if ($("btnClearRoads")) {
      $("btnClearRoads").addEventListener("click", clearRoads);
    }
    if ($("btnGenerateRiver")) {
      $("btnGenerateRiver").addEventListener("click", generateRiver);
    }
    if ($("btnClearRivers")) {
      $("btnClearRivers").addEventListener("click", clearRivers);
    }
    if ($("btnTestForest")) {
      $("btnTestForest").addEventListener("click", generateTestForest);
    }
    if ($("btnGenerateForests")) {
      $("btnGenerateForests").addEventListener("click", generateForests);
    }
    if ($("btnClearForests")) {
      $("btnClearForests").addEventListener("click", clearForests);
    }


    for (const id of ["grassDen","cliffFacing","grassThk","topMat","lumpAmp","lumpScale","muffLift","muffOver","muffRad","gAmp","gScale","round","wallRough","cliffVar","cliffVarScale","cliffVarBoost","groundShellOn","groundShellVox"]){
      $(id).addEventListener("change", regenerate);
    }

    regenerate();
    
    // Auto-scatter forests on initial load (trees are enabled by default)
    setTimeout(() => {
      if (ensureVoxelGrid()) {
        const { w, h, depth } = importedVoxelGridDims;
        const forestDensity = parseFloat($("forestDensity").value) || 0.3;
        const barrierDensity = parseFloat($("barrierDensity").value) || 0.2;
        
        const seed = readParams().seed + "::forests";
        const noiseForest = new Simplex2D(makeRng(seed));
        const noiseBarrier = new Simplex2D(makeRng(seed + "::barrier"));
        
        let forestVoxels = 0;
        let barrierVoxels = 0;
        
        for (let z = 0; z < h; z++) {
          for (let x = 0; x < w; x++) {
            const idx2d = z * w + x;
            const terrainHeight = levels[idx2d];
            
            if (terrainHeight > 0) {
              const surfaceLevel = terrainHeight - 1;
              
              if (surfaceLevel >= 0 && surfaceLevel < depth) {
                const idx3d = surfaceLevel * (w * h) + z * w + x;
                const currentType = importedVoxelGrid[idx3d];
                const isRoad = currentType >= VOXEL_TYPES.ROAD_NS && currentType <= VOXEL_TYPES.ROAD_RAMP_W;
                const isRiver = currentType >= VOXEL_TYPES.RIVER_N && currentType <= VOXEL_TYPES.RIVER_SW;
                
                if (isRoad || isRiver) continue;
                
                const nx = x / w;
                const nz = z / h;
                const forestNoise = noiseForest.noise(nx * 3.5, nz * 3.5);
                const barrierNoise = noiseBarrier.noise(nx * 5.0, nz * 5.0);
                
                if (forestNoise > (1.0 - forestDensity * 2)) {
                  importedVoxelGrid[idx3d] = VOXEL_TYPES.FOREST;
                  forestVoxels++;
                } else if (barrierNoise > (1.0 - barrierDensity * 2)) {
                  importedVoxelGrid[idx3d] = VOXEL_TYPES.TREE_BARRIER;
                  barrierVoxels++;
                }
              }
            }
          }
        }
        
        if (forestVoxels > 0 || barrierVoxels > 0) {
          regenerate();
          hudPush(`Auto-scattered forests: ${forestVoxels} forest + ${barrierVoxels} barrier voxels`);
        }
      }
    }, 100); // Small delay to ensure terrain is fully generated

    let __lastTickT = performance.now() * 0.001;

    function __applySunOrbit(dt){
      // Don't rotate if integrated time/season cycle is active
      if (globalThis.__integratedTimeSeasonState && globalThis.__integratedTimeSeasonState.auto) return;
      
      const st = globalThis.__sunState;
      const sunL = globalThis.__sunLight;
      if (!st || !sunL || !st.rotate) return;
      // Advance elevation (up and down like sunrise/sunset)
      st.elevDeg = ((st.elevDeg + st.speedDegPerSec * dt) % 360 + 360) % 360;

      // Determine orbit radius once from existing position.
      if (!st.radius) st.radius = Math.max(1e-3, sunL.position.length());
      const az = st.azDeg * Math.PI/180;
      const el = st.elevDeg * Math.PI/180; // Allow full 360 degree rotation
      const r = st.radius;
      const c = Math.cos(el);
      sunL.position.set(r*c*Math.cos(az), r*Math.sin(el), r*c*Math.sin(az));
      const __tc = globalThis.__terrainCenter || new THREE.Vector3(0,0,0);
      sunL.target.position.copy(__tc);
      sunL.target.updateMatrixWorld();
      // HUD/debug snapshot
      globalThis.__debugSun = {
        ...(globalThis.__debugSun||{}),
        hasThree: true,
        dir: { x: sunL.position.x, y: sunL.position.y, z: sunL.position.z }
      };
    }

    function tick(){
      const nowT = performance.now() * 0.001;
      const dt = Math.max(0, Math.min(0.1, nowT - __lastTickT));
      __lastTickT = nowT;


      // AutoWind (testing): rotate wind direction over time so you can verify grass animation even on mobile.
      // Uses the WindDir pad setter so UI + uniforms stay in sync.
      try{
        const wa = globalThis.__windAuto;
        if (wa?.enabled && typeof globalThis.__windPadSetNorm === "function"){
          const ang = nowT * (wa.speed ?? 1.0);
          const nx = Math.cos(ang) * 0.85;
          const nz = Math.sin(ang * 0.97) * 0.85;
          globalThis.__windPadSetNorm(nx, nz, {emit:false});
          // lightweight HUD status (throttled)
          if (wa.debug && (nowT - (wa._lastHudT||0)) > 1.0){
            wa._lastHudT = nowT;
            const st = globalThis.StylizedTerrainShader;
            const wv = st?.styleGrass?.windVel?.value;
            const ws = st?.styleGrass?.windStrength?.value;
            hudPush(`WIND t=${nowT.toFixed(2)} vel=${wv?`${wv.x.toFixed(2)},${wv.z.toFixed(2)}`:"?"} strength=${(ws??0).toFixed(2)}`);
          }
        }
      }catch(e){}
      
      // Update integrated time & season system (smooth transitions and auto-cycle)
      if (typeof globalThis.__updateIntegratedTimeSeasonCycle === "function"){
        globalThis.__updateIntegratedTimeSeasonCycle(dt);
      }
      
      // Update storm system (lightning, intensity, fog)
      if (typeof globalThis.__updateStormSystem === "function"){
        globalThis.__updateStormSystem(dt);
      }
      
      // Rotate sun if enabled (disabled during auto-cycle)
      __applySunOrbit(dt);

      // Update sun gizmo (if present)
      try{
        const sg = globalThis.__sunGizmo;
        const st = globalThis.__sunState;
        const sunL = globalThis.__sunLight;
        if (sg && st && typeof st.gizmo !== 'undefined'){
          sg.group.visible = !!st.gizmo;
        }
        if (sg && sunL){
          // Ball at sun position
          sg.ball.position.copy(sunL.position);
          // Arrow from origin showing light rays direction (incoming)
          const dirToLight = sunL.position.clone().normalize();
          const dirRays = dirToLight.clone().negate();
          const __tc2 = globalThis.__terrainCenter || new THREE.Vector3(0,0,0);
          sg.arrow.position.copy(__tc2);
          sg.arrow.setDirection(dirRays);
          sg.arrow.setLength(28, 6, 4);
          // Line from origin to sun
          const __tc3 = globalThis.__terrainCenter || new THREE.Vector3(0,0,0);
          const pts = [__tc3.clone(), sunL.position.clone()];
          sg.lineGeo.setFromPoints(pts);
          sg.lineGeo.attributes.position.needsUpdate = true;
          // Keep debug snapshot with direction
          globalThis.__debugSun = { ...(globalThis.__debugSun||{}), hasThree: true, dirToLight: { x: dirToLight.x, y: dirToLight.y, z: dirToLight.z }, dirRays: { x: dirRays.x, y: dirRays.y, z: dirRays.z } };
        }
      }catch(e){}


      // Keep stylized shader uniforms in sync.
      if (typeof globalThis.StylizedTerrainShader !== "undefined"){
        globalThis.StylizedTerrainShader.setTime(nowT);
        globalThis.StylizedTerrainShader.setLightDirWorld((globalThis.__sunLight||sun).position);
      }

      // Update water shader
      updateWaterUniforms(nowT);

      controls.update();
      
      // Use EffectComposer for depth-based outlines
      if (window.composer) {
        // Update camera uniforms for depth shader
        if (window.depthOutlinePass) {
          window.depthOutlinePass.uniforms['cameraNear'].value = camera.near;
          window.depthOutlinePass.uniforms['cameraFar'].value = camera.far;
        }

        // Render a water mask for shoreline/intersection outlines (screen-space).
        // IMPORTANT: This is generated live from the current camera view.
        // Pass 1 writes depth for the whole scene (black), Pass 2 draws water (white) respecting that depth,
        // so hidden water won't contribute to shoreline/intersection outlines.
        try{
          const waterOutlinesOn = ($("waterSurfaceOutlines") && $("waterSurfaceOutlines").checked);
          if (waterOutlinesOn && window.waterMaskTarget && window.waterMaskMaterial && window.waterMaskMaterialBlack) {
            const oldRT = renderer.getRenderTarget();
            const oldOverride = scene.overrideMaterial;
            const oldMask = camera.layers.mask;
            const oldClr = new THREE.Color();
            renderer.getClearColor(oldClr);
            const oldClrA = renderer.getClearAlpha ? renderer.getClearAlpha() : 1.0;

            renderer.setRenderTarget(window.waterMaskTarget);
            renderer.setClearColor(0x000000, 1.0);
            renderer.clear(true, true, true);

            // Pass 1: full-scene depth prepass (black)
            scene.overrideMaterial = window.waterMaskMaterialBlack;
            camera.layers.mask = oldMask; // all layers as currently configured
            renderer.render(scene, camera);

            // Pass 2: water only (white), occluded by the depth buffer from pass 1
            camera.layers.set(globalThis.__WATER_LAYER || 2);
            scene.overrideMaterial = window.waterMaskMaterial;
            renderer.render(scene, camera);

            scene.overrideMaterial = oldOverride;
            camera.layers.mask = oldMask;
            renderer.setClearColor(oldClr, oldClrA);
            renderer.setRenderTarget(oldRT);
          }
        }catch(err){
          (globalThis.__uiLog ? globalThis.__uiLog(String('water mask render failed: ' + (err && err.message ? err.message : err))) : console.warn(err));
        }

        // Render material ID buffer for material boundary outlines (screen-space, line-of-sight).
        // This is rendered live each frame from the current camera view, and uses a depth buffer so occluded
        // geometry cannot "bleed" into the ID buffer.
        try{
          const materialOutlinesOn = ($("materialOutlinesEnabled") && $("materialOutlinesEnabled").checked);
          if (materialOutlinesOn && window.materialIDTarget) {
            const oldRT = renderer.getRenderTarget();
            const oldOverride = scene.overrideMaterial;
            const oldMask = camera.layers.mask;
            const oldClr = new THREE.Color();
            renderer.getClearColor(oldClr);
            const oldClrA = renderer.getClearAlpha ? renderer.getClearAlpha() : 1.0;

            renderer.setRenderTarget(window.materialIDTarget);
            renderer.setClearColor(0x000000, 1.0);
            renderer.clear(true, true, true);

            const ORIG_KEY = window.__MAT_ID_ORIG_KEY || (window.__MAT_ID_ORIG_KEY = Symbol('matIDOrig'));
            const cache = window.materialIDOverrideCache || (window.materialIDOverrideCache = new Map());

            // Cutout (alpha-tested) ID material: preserves PNG transparency while writing a solid ID color.
const __makeCutoutIdMat = (tex, alphaTest, idColor, side) => {
  const mat = new THREE.ShaderMaterial({
    uniforms: {
      uMap: { value: tex },
      uColor: { value: new THREE.Color(idColor) },
      uAlphaTest: { value: (Number.isFinite(alphaTest) ? alphaTest : 0.5) }
    },
    vertexShader: `
      varying vec2 vUv;
      void main(){
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D uMap;
      uniform vec3 uColor;
      uniform float uAlphaTest;
      varying vec2 vUv;
      void main(){
        float a = texture2D(uMap, vUv).a;
        if (a < uAlphaTest) discard;
        gl_FragColor = vec4(uColor, 1.0);
      }
    `,
    depthTest: true,
    depthWrite: true,
    side: (side != null ? side : THREE.DoubleSide),
    transparent: false
  });
  mat.extensions = mat.extensions || {};
  mat.extensions.derivatives = true;
  mat.userData = mat.userData || {};
  mat.userData.__noDispose = true; // cached
  return mat;
};


// Shader-based ID material: keeps the ORIGINAL vertex shader (wind/grass/snow deformation)
// so the ID buffer depth matches what you actually see on screen.
const __makeShaderIdMat = (origMat, idColor) => {
  const uniforms = {};
  if (origMat.uniforms){
    for (const k in origMat.uniforms) uniforms[k] = origMat.uniforms[k];
  }
  uniforms.uMatIdColor = { value: new THREE.Color(idColor) };

  let frag = String(origMat.fragmentShader || "");

  // Ensure uniform exists in shader source.
  if (!/uniform\s+vec3\s+uMatIdColor\s*;/.test(frag)){
    if (/precision\s+(highp|mediump|lowp)\s+float\s*;/.test(frag)){
      frag = frag.replace(/precision\s+(highp|mediump|lowp)\s+float\s*;/, (m)=> m + "\nuniform vec3 uMatIdColor;");
    } else {
      frag = "uniform vec3 uMatIdColor;\n" + frag;
    }
  }

  // Replace any existing gl_FragColor writes with the flat ID color (keep discards/branches).
  if (/gl_FragColor\s*=/.test(frag)){
    frag = frag.replace(/gl_FragColor\s*=\s*[^;]+;/g, "gl_FragColor = vec4(uMatIdColor, 1.0);");
  } else {
    // Fallback: append at end of main (best-effort).
    frag = frag.replace(/}\s*$/, "\n  gl_FragColor = vec4(uMatIdColor, 1.0);\n}\n");
  }

  const mat = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: origMat.vertexShader,
    fragmentShader: frag,
    defines: origMat.defines ? { ...origMat.defines } : undefined,
    extensions: origMat.extensions ? { ...origMat.extensions } : undefined,
    lights: !!origMat.lights,
    fog: !!origMat.fog,
    transparent: false,
    depthTest: true,
    depthWrite: true,
    side: (origMat.side != null ? origMat.side : THREE.DoubleSide)
  });

  // Carry over a few toggles that can affect compilation.
  mat.alphaTest = (Number.isFinite(origMat.alphaTest) ? origMat.alphaTest : 0.0);
  mat.wireframe = !!origMat.wireframe;

  mat.userData = mat.userData || {};
  mat.userData.__noDispose = true; // cached
  return mat;
};

const getOverrideMat = (origMat) => {
  if (!origMat) return null;

  const cache = window.materialIDOverrideCache;
  let entry = cache.get(origMat);
  if (!entry) entry = {};

  // Determine ID color.
  const group = (origMat.userData && origMat.userData.__outlineGroup) ? origMat.userData.__outlineGroup : "";
  let idColor = null;
  if (group === "leaf") {
    idColor = (window.__OUTLINE_ID_LEAF_COLOR || new THREE.Color(0xff00ff));
  } else if (group === "wood") {
    idColor = (window.__OUTLINE_ID_WOOD_COLOR || new THREE.Color(0x00ffff));
  } else {
    window.assignMaterialID(origMat);
    const id = window.materialIDMap.get(origMat);
    idColor = window.materialIDColors[id];
  }

  // Preserve alpha cutouts (e.g., PNG/leaf cards) WITHOUT tinting the ID by the texture RGB.
  const wantsCutout = !!origMat.map && (Number.isFinite(origMat.alphaTest) ? (origMat.alphaTest > 0.0) : false);
  if (wantsCutout){
    const key = "cutout";
    if (!entry[key]){
      entry[key] = __makeCutoutIdMat(origMat.map, origMat.alphaTest, idColor, origMat.side);
    } else {
      // Keep color synced (in case ids are re-assigned).
      if (entry[key].uniforms && entry[key].uniforms.uColor) entry[key].uniforms.uColor.value.set(idColor);
      if (entry[key].uniforms && entry[key].uniforms.uMap) entry[key].uniforms.uMap.value = origMat.map;
      if (entry[key].uniforms && entry[key].uniforms.uAlphaTest) entry[key].uniforms.uAlphaTest.value = origMat.alphaTest;
      entry[key].side = (origMat.side != null ? origMat.side : THREE.DoubleSide);
    }
    cache.set(origMat, entry);
    return entry[key];
  }

  // Preserve vertex-deformed shader materials (grass/snow/etc) so outlines don't "see through" them.
  const wantsShaderId = !!origMat.isShaderMaterial && !!origMat.vertexShader && !!origMat.fragmentShader;
  if (wantsShaderId){
    const key = "shader";
    if (!entry[key]){
      entry[key] = __makeShaderIdMat(origMat, idColor);
    } else {
      if (entry[key].uniforms && entry[key].uniforms.uMatIdColor) entry[key].uniforms.uMatIdColor.value.set(idColor);
      entry[key].side = (origMat.side != null ? origMat.side : THREE.DoubleSide);
      entry[key].alphaTest = (Number.isFinite(origMat.alphaTest) ? origMat.alphaTest : 0.0);
    }
    cache.set(origMat, entry);
    return entry[key];
  }


  // Default solid ID material
  if (!entry.solid){
    entry.solid = new THREE.MeshBasicMaterial({ color: idColor, side: (origMat.side != null ? origMat.side : THREE.DoubleSide) });
    entry.solid.depthTest = true;
    entry.solid.depthWrite = true;
    entry.solid.userData = entry.solid.userData || {};
    entry.solid.userData.__noDispose = true; // cached
  } else {
    entry.solid.color.set(idColor);
    entry.solid.side = (origMat.side != null ? origMat.side : THREE.DoubleSide);
  }
  cache.set(origMat, entry);
  return entry.solid;
};

            // Swap materials to their ID overrides (supports multi-material meshes).
            scene.traverse((obj) => {
              if (!obj || !obj.isMesh || !obj.material) return;
              if (obj.visible === false) return;
              if (obj.layers && !obj.layers.test(camera.layers)) return;

              const orig = obj.material;
              obj.userData[ORIG_KEY] = orig;

              if (Array.isArray(orig)) {
                const fallback = getOverrideMat(orig[0]);
                const mapped = orig.map((m)=>getOverrideMat(m) || fallback);
                obj.material = mapped;
              } else {
                obj.material = getOverrideMat(orig);
              }
            });

            renderer.render(scene, camera);

            // Restore original materials.
            scene.traverse((obj) => {
              if (!obj || !obj.userData) return;
              if (obj.userData[ORIG_KEY]) {
                obj.material = obj.userData[ORIG_KEY];
                delete obj.userData[ORIG_KEY];
              }
            });

            renderer.setClearColor(oldClr, oldClrA);
            renderer.setRenderTarget(oldRT);
            scene.overrideMaterial = oldOverride;
            camera.layers.mask = oldMask;
          }
        }catch(err){
          (globalThis.__uiLog ? globalThis.__uiLog(String('material ID render failed: ' + (err && err.message ? err.message : err))) : console.warn(err));
        }

        // Sync water-outline uniforms from UI
        if (window.depthOutlinePass && window.depthOutlinePass.uniforms) {
          const u = window.depthOutlinePass.uniforms;
          if (u.waterEdgeEnabled) u.waterEdgeEnabled.value = ($("waterSurfaceOutlines") && $("waterSurfaceOutlines").checked) ? 1.0 : 0.0;
          if (u.waterEdgeThickness && $("waterOutlineThick")) u.waterEdgeThickness.value = parseFloat($("waterOutlineThick").value) || 0.0;
          if (u.waterEdgeStrength && $("waterOutlineStrength")) u.waterEdgeStrength.value = parseFloat($("waterOutlineStrength").value) || 0.0;
          
          // Sync material-outline uniforms from UI
          if (u.materialEdgeEnabled) u.materialEdgeEnabled.value = ($("materialOutlinesEnabled") && $("materialOutlinesEnabled").checked) ? 1.0 : 0.0;
          if (u.materialEdgeThickness && $("materialOutlineThick")) u.materialEdgeThickness.value = parseFloat($("materialOutlineThick").value) || 0.0;
          if (u.materialEdgeStrength && $("materialOutlineStrength")) u.materialEdgeStrength.value = parseFloat($("materialOutlineStrength").value) || 0.0;
        }

        // Keep tDepth in sync with the composer's current buffer.
        // (Without this, some drivers flicker when EffectComposer swaps buffers.)
        try{
          if (window.depthOutlinePass && window.depthOutlinePass.uniforms && window.depthOutlinePass.uniforms.tDepth && window.composer){
            const rb = window.composer.readBuffer;
            const wb = window.composer.writeBuffer;
            const dt = (rb && rb.depthTexture) ? rb.depthTexture
              : (wb && wb.depthTexture) ? wb.depthTexture
              : (window.depthRenderTarget && window.depthRenderTarget.depthTexture) ? window.depthRenderTarget.depthTexture
              : null;
            if (dt) window.depthOutlinePass.uniforms.tDepth.value = dt;
          }
        }catch(e){}

        window.composer.render();
        // Draw 3D compass overlay on top of postprocessing output
        __renderCompassOverlay();
      } else {
        renderer.render(scene, camera);
        __renderCompassOverlay();
      }
      
      requestAnimationFrame(tick);
    }
    __wireWaterDebugUI();
    tick();
    
    // Setup test point light (proximity-based brightness)
    // Uncomment and adjust to add more lights (supports up to 4)
    if (typeof globalThis.StylizedTerrainShader !== "undefined"){
      // Light 0: Warm campfire/lantern light - small localized pool
      globalThis.StylizedTerrainShader.setPointLight(
        0,                                              // index (0-3)
        new THREE.Vector3(32, 8, 32),                  // position
        5.0,                                            // radius (small - just a few tiles)
        1.2,                                            // intensity (brightness boost)
        new THREE.Color(1.0, 0.85, 0.6)                // warm orange-yellow tint
      );
      
      // You can add more lights like this:
      // globalThis.StylizedTerrainShader.setPointLight(1, new THREE.Vector3(10, 5, 10), 6, 0.8, new THREE.Color(0.8, 0.9, 1.0));
    }

    
    function __resizeAll(){
      const s = __updateViewSize();
      const w = s.w, h = s.h;

      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);

      if (typeof globalThis.StylizedTerrainShader !== "undefined"){
        globalThis.StylizedTerrainShader.setSharedFromRendererSize(w, h);
      }

      // Update composer and depth outline resolution
      if (window.composer) window.composer.setSize(w, h);

      if (window.depthRenderTarget) {
        window.depthRenderTarget.setSize(w, h);
        if (window.depthRenderTarget.depthTexture) {
          window.depthRenderTarget.depthTexture.image.width = w;
          window.depthRenderTarget.depthTexture.image.height = h;
        }
      }

      // If the composer has a second depth texture (used to prevent outline flicker), keep it sized too.
      if (window.__depthTexture2 && window.__depthTexture2.image){
        window.__depthTexture2.image.width = w;
        window.__depthTexture2.image.height = h;
      }

      if (window.waterMaskTarget) {
        window.waterMaskTarget.setSize(w, h);
      }



       if (window.materialIDTarget) {
         window.materialIDTarget.setSize(w, h);
       }

      if (window.depthOutlinePass) {
        window.depthOutlinePass.uniforms['resolution'].value.set(w, h);
      }
    }

    window.addEventListener("resize", __resizeAll);
    // Resize when the viewport container changes size (sidebar drag, orientation changes, etc.)
    if (typeof ResizeObserver !== "undefined"){
      const __ro = new ResizeObserver(__resizeAll);
      __ro.observe(app);
    }


    // =========================================================================
    // SCULPTING SYSTEM - Layer-by-layer erosion-based generation
    // =========================================================================

    // 2D noise for river paths and terrain variation
    class Noise2D {
      constructor(rng) {
        this.perm = [];
        for (let i = 0; i < 256; i++) this.perm[i] = i;
        for (let i = 255; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
        }
        this.perm = this.perm.concat(this.perm);
      }
      
      fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }
      
      lerp(t, a, b) {
        return a + t * (b - a);
      }
      
      grad(hash, x, y) {
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
      }
      
      noise(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        
        x -= Math.floor(x);
        y -= Math.floor(y);
        
        const u = this.fade(x);
        const v = this.fade(y);
        
        const A = this.perm[X] + Y;
        const B = this.perm[X + 1] + Y;
        
        return this.lerp(v,
          this.lerp(u, this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y)),
          this.lerp(u, this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1))
        );
      }
    }

    // Sculpting operations that carve away from a solid block
    class SculptOps {
      constructor(levels, w, h, rng, noise, intensity, isGentle) {
        this.levels = levels;
        this.w = w;
        this.h = h;
        this.rng = rng;
        this.noise = noise;
        this.intensity = intensity;
        this.isGentle = isGentle; // gentle mode = smaller, softer operations
      }
      
      getHeight(x, z) {
        if (x < 0 || x >= this.w || z < 0 || z >= this.h) return 0;
        return this.levels[z * this.w + x];
      }
      
      setHeight(x, z, h) {
        if (x < 0 || x >= this.w || z < 0 || z >= this.h) return;
        this.levels[z * this.w + x] = Math.max(0, Math.floor(h));
      }
      
      carve(x, z, depth) {
        const current = this.getHeight(x, z);
        if (current <= 0) return 0;
        const newHeight = Math.max(0, current - depth);
        this.setHeight(x, z, newHeight);
        return current - newHeight;
      }
      
      // Op 1: Lower entire surface uniformly
      surfaceLower() {
        const amount = this.isGentle 
          ? this.rng() < 0.5 ? 1 : 2  // gentle: mostly 1, sometimes 2
          : Math.floor(1 + this.rng() * 2 * this.intensity); // dramatic: 1-3
        
        let carved = 0;
        for (let z = 0; z < this.h; z++) {
          for (let x = 0; x < this.w; x++) {
            carved += this.carve(x, z, amount);
          }
        }
        return { name: 'SurfaceLower', amount, carved };
      }
      
      // Op 2: Cut a gentle meandering river valley
      riverValley() {
        const startX = Math.floor(this.rng() * this.w);
        const startZ = Math.floor(this.rng() * this.h);
        const angle = this.rng() * Math.PI * 2;
        const length = this.isGentle
          ? Math.floor(15 + this.rng() * 20) // gentle: 15-35 tiles
          : Math.floor(20 + this.rng() * 30 * this.intensity); // dramatic: 20-50 tiles
        
        const width = this.isGentle
          ? 2 + this.rng() * 2  // gentle: 2-4 tiles wide
          : 3 + this.rng() * 4 * this.intensity; // dramatic: 3-7 tiles wide
        
        const maxDepth = this.isGentle
          ? 1 + Math.floor(this.rng() * 2) // gentle: 1-3 levels deep
          : 2 + Math.floor(this.rng() * 3 * this.intensity); // dramatic: 2-5 levels deep
        
        let carved = 0;
        let cx = startX, cz = startZ;
        
        for (let i = 0; i <= length; i++) {
          const t = i / length;
          
          // Gradual depth profile - shallow at ends, deeper in middle
          const depthProfile = Math.sin(t * Math.PI);
          const depth = Math.max(1, Math.floor(maxDepth * depthProfile));
          
          // Meandering using noise
          const meander = this.noise.noise(i * 0.15, 0) * width * 0.8;
          const nx = Math.floor(cx + Math.cos(angle + meander * 0.5) * 1.2);
          const nz = Math.floor(cz + Math.sin(angle + meander * 0.5) * 1.2);
          
          cx = nx;
          cz = nz;
          
          // Carve in a radius with soft edges
          for (let dz = -Math.floor(width); dz <= Math.floor(width); dz++) {
            for (let dx = -Math.floor(width); dx <= Math.floor(width); dx++) {
              const dist = Math.sqrt(dx * dx + dz * dz);
              if (dist <= width) {
                const softEdge = 1 - (dist / width) * 0.5; // softer falloff
                const localDepth = Math.max(1, Math.floor(depth * softEdge));
                carved += this.carve(cx + dx, cz + dz, localDepth);
              }
            }
          }
        }
        
        return { name: 'RiverValley', width: width.toFixed(1), depth: maxDepth, length, carved };
      }
      
      // Op 2b: Terraced river valley - starts wide and gets narrower each layer down
      // This creates smooth hilly valleys by carving multiple layers at once
      riverTerrace(currentLayer) {
        const startX = Math.floor(this.rng() * this.w);
        const startZ = Math.floor(this.rng() * this.h);
        const angle = this.rng() * Math.PI * 2;
        
        // Length of the river valley
        const length = this.isGentle
          ? Math.floor(20 + this.rng() * 25) // gentle: 20-45 tiles
          : Math.floor(25 + this.rng() * 35 * this.intensity); // dramatic: 25-60 tiles
        
        // Starting width (top layer is widest)
        const startWidth = this.isGentle
          ? 8 + this.rng() * 8  // gentle: 8-16 tiles wide at top
          : 10 + this.rng() * 12 * this.intensity; // dramatic: 10-22 tiles wide
        
        // How many layers to carve down
        const numLayers = this.isGentle
          ? 3 + Math.floor(this.rng() * 4) // gentle: 3-7 layers
          : 4 + Math.floor(this.rng() * 6 * this.intensity); // dramatic: 4-10 layers
        
        // Width reduction per layer (narrows as you go down)
        const widthStep = startWidth / (numLayers + 1);
        
        let totalCarved = 0;
        let cx = startX, cz = startZ;
        
        // Generate the river path once
        const riverPath = [];
        for (let i = 0; i <= length; i++) {
          const meander = this.noise.noise(i * 0.12, currentLayer * 0.05) * startWidth * 0.4;
          const nx = Math.floor(cx + Math.cos(angle + meander * 0.3) * 1.0);
          const nz = Math.floor(cz + Math.sin(angle + meander * 0.3) * 1.0);
          riverPath.push({ x: nx, z: nz });
          cx = nx;
          cz = nz;
        }
        
        // Carve each layer with progressively narrower width
        for (let layerOffset = 0; layerOffset < numLayers; layerOffset++) {
          const targetHeight = currentLayer - layerOffset;
          if (targetHeight < 0) break;
          
          const currentWidth = startWidth - (widthStep * layerOffset);
          if (currentWidth < 1) break;
          
          // Carve this layer along the river path
          for (const { x: px, z: pz } of riverPath) {
            for (let dz = -Math.floor(currentWidth); dz <= Math.floor(currentWidth); dz++) {
              for (let dx = -Math.floor(currentWidth); dx <= Math.floor(currentWidth); dx++) {
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist <= currentWidth) {
                  const x = px + dx;
                  const z = pz + dz;
                  
                  // Carve down to target height
                  if (x >= 0 && x < this.w && z >= 0 && z < this.h) {
                    const currentHeight = this.getHeight(x, z);
                    if (currentHeight > targetHeight) {
                      this.setHeight(x, z, targetHeight);
                      totalCarved += currentHeight - targetHeight;
                    }
                  }
                }
              }
            }
          }
        }
        
        return { 
          name: 'RiverTerrace', 
          startWidth: startWidth.toFixed(1), 
          layers: numLayers,
          length, 
          carved: totalCarved 
        };
      }
      
      // Op 3: Deepen an existing low area (creates basins/lakes)
      basinDeepen() {
        // Find low points
        let minHeight = Infinity;
        const candidates = [];
        
        for (let z = 3; z < this.h - 3; z++) {
          for (let x = 3; x < this.w - 3; x++) {
            const h = this.getHeight(x, z);
            if (h > 0 && h < minHeight) {
              minHeight = h;
              candidates.length = 0;
              candidates.push([x, z]);
            } else if (h === minHeight && h > 0) {
              candidates.push([x, z]);
            }
          }
        }
        
        if (candidates.length === 0) {
          return { name: 'BasinDeepen', result: 'no candidates', carved: 0 };
        }
        
        const [cx, cz] = candidates[Math.floor(this.rng() * candidates.length)];
        
        const radius = this.isGentle
          ? 2 + this.rng() * 3  // gentle: 2-5 tiles
          : 4 + this.rng() * 6 * this.intensity; // dramatic: 4-10 tiles
        
        const depth = this.isGentle
          ? 1 + Math.floor(this.rng() * 2) // gentle: 1-3 levels
          : 2 + Math.floor(this.rng() * 3 * this.intensity); // dramatic: 2-5 levels
        
        let carved = 0;
        
        for (let dz = -Math.floor(radius); dz <= Math.floor(radius); dz++) {
          for (let dx = -Math.floor(radius); dx <= Math.floor(radius); dx++) {
            const dist = Math.sqrt(dx * dx + dz * dz);
            if (dist <= radius) {
              // Parabolic profile for natural basin shape
              const t = dist / radius;
              const localDepth = Math.max(1, Math.floor(depth * (1 - t * t)));
              carved += this.carve(cx + dx, cz + dz, localDepth);
            }
          }
        }
        
        return { name: 'BasinDeepen', center: `${cx},${cz}`, radius: radius.toFixed(1), depth, carved };
      }
      
      // Op 4: Create a plateau by lowering everything around a region
      plateauKeep() {
        const cx = Math.floor(3 + this.rng() * (this.w - 6));
        const cz = Math.floor(3 + this.rng() * (this.h - 6));
        
        const radius = this.isGentle
          ? 3 + this.rng() * 4  // gentle: 3-7 tiles
          : 5 + this.rng() * 8 * this.intensity; // dramatic: 5-13 tiles
        
        const dropAmount = this.isGentle
          ? 1 // gentle: 1 level
          : 1 + Math.floor(this.rng() * 2 * this.intensity); // dramatic: 1-3 levels
        
        let carved = 0;
        
        for (let z = 0; z < this.h; z++) {
          for (let x = 0; x < this.w; x++) {
            const dist = Math.sqrt((x - cx) ** 2 + (z - cz) ** 2);
            if (dist > radius) {
              carved += this.carve(x, z, dropAmount);
            }
          }
        }
        
        return { name: 'PlateauKeep', center: `${cx},${cz}`, radius: radius.toFixed(1), drop: dropAmount, carved };
      }
      
      // Op 5: Carve a gentle ridge or valley line
      ridgeCarve() {
        const startX = Math.floor(this.rng() * this.w);
        const startZ = Math.floor(this.rng() * this.h);
        const angle = this.rng() * Math.PI * 2;
        const length = this.isGentle
          ? Math.floor(10 + this.rng() * 15) // gentle: 10-25 tiles
          : Math.floor(15 + this.rng() * 25 * this.intensity); // dramatic: 15-40 tiles
        
        const width = this.isGentle
          ? 2 + this.rng() * 2  // gentle: 2-4 tiles
          : 3 + this.rng() * 4 * this.intensity; // dramatic: 3-7 tiles
        
        const depth = this.isGentle
          ? 1 // gentle: 1 level
          : 1 + Math.floor(this.rng() * 2 * this.intensity); // dramatic: 1-3 levels
        
        let carved = 0;
        
        for (let i = 0; i <= length; i++) {
          const x = Math.floor(startX + Math.cos(angle) * i);
          const z = Math.floor(startZ + Math.sin(angle) * i);
          
          // V-shaped profile
          for (let dz = -Math.floor(width); dz <= Math.floor(width); dz++) {
            for (let dx = -Math.floor(width); dx <= Math.floor(width); dx++) {
              const dist = Math.sqrt(dx * dx + dz * dz);
              if (dist <= width) {
                const localDepth = Math.max(1, Math.floor(depth * (dist / width)));
                carved += this.carve(x + dx, z + dz, localDepth);
              }
            }
          }
        }
        
        return { name: 'RidgeCarve', length, width: width.toFixed(1), depth, carved };
      }
      
      // Op 6: Smooth random areas (wind erosion effect)
      windSmooth() {
        const cx = Math.floor(this.rng() * this.w);
        const cz = Math.floor(this.rng() * this.h);
        const radius = this.isGentle
          ? 3 + this.rng() * 4
          : 4 + this.rng() * 6 * this.intensity;
        
        const heights = [];
        for (let dz = -Math.floor(radius); dz <= Math.floor(radius); dz++) {
          for (let dx = -Math.floor(radius); dx <= Math.floor(radius); dx++) {
            const dist = Math.sqrt(dx * dx + dz * dz);
            if (dist <= radius) {
              const h = this.getHeight(cx + dx, cz + dz);
              if (h > 0) heights.push(h);
            }
          }
        }
        
        if (heights.length === 0) {
          return { name: 'WindSmooth', result: 'no heights', carved: 0 };
        }
        
        const avgHeight = Math.floor(heights.reduce((a, b) => a + b, 0) / heights.length);
        let carved = 0;
        
        for (let dz = -Math.floor(radius); dz <= Math.floor(radius); dz++) {
          for (let dx = -Math.floor(radius); dx <= Math.floor(radius); dx++) {
            const dist = Math.sqrt(dx * dx + dz * dz);
            if (dist <= radius) {
              const current = this.getHeight(cx + dx, cz + dz);
              if (current > avgHeight) {
                const diff = current - avgHeight;
                carved += this.carve(cx + dx, cz + dz, Math.ceil(diff * 0.5));
              }
            }
          }
        }
        
        return { name: 'WindSmooth', center: `${cx},${cz}`, radius: radius.toFixed(1), carved };
      }
    }

    // Generate terrain using layer-by-layer sculpting
    function generateSculptedTerrain({ seed, w, h, maxLevel, minOps, maxOps, intensity, isGentle, groundLayer }) {
      const rng = makeRng(seed + "::sculpt");
      const noise = new Noise2D(rng);
      
      // Start with solid block
      const levels = new Int16Array(w * h);
      levels.fill(maxLevel);
      
      // Check which operations are enabled via checkboxes
      const enabledOps = {
        riverValley: $("opRiverValley").checked,
        riverTerrace: $("opRiverTerrace").checked,
        basinDeepen: $("opBasinDeepen").checked,
        windSmooth: $("opWindSmooth").checked,
        ridgeCarve: $("opRidgeCarve").checked,
        surfaceLower: $("opSurfaceLower").checked,
        plateauKeep: $("opPlateauKeep").checked
      };
      
      // Operation weights (different for gentle vs dramatic)
      const gentleWeights = [
        ['riverValley', 8],   // lots of gentle valleys
        ['riverTerrace', 10], // ‚≠ê terraced valleys are great for gentle hills
        ['basinDeepen', 5],   // some basins
        ['windSmooth', 6],    // smoothing is common
        ['ridgeCarve', 4],    // some ridges
        ['surfaceLower', 3],  // occasional overall lowering
        ['plateauKeep', 2],   // rare plateaus
      ];
      
      const dramaticWeights = [
        ['riverValley', 5],
        ['riverTerrace', 6], // ‚≠ê also good for dramatic terrain
        ['basinDeepen', 5],
        ['plateauKeep', 4],
        ['ridgeCarve', 5],
        ['surfaceLower', 4],
        ['windSmooth', 3],
      ];
      
      const weights = isGentle ? gentleWeights : dramaticWeights;
      
      // Filter operations based on checkboxes
      const opList = [];
      for (const [op, weight] of weights) {
        if (enabledOps[op]) {  // Only include if checkbox is checked
          for (let i = 0; i < weight * 10; i++) {
            opList.push(op);
          }
        }
      }
      
      // If no operations enabled, use all of them
      if (opList.length === 0) {
        for (const [op, weight] of weights) {
          for (let i = 0; i < weight * 10; i++) {
            opList.push(op);
          }
        }
      }
      
      const sculptOps = new SculptOps(levels, w, h, rng, noise, intensity, isGentle);
      const opLog = [];
      
      // Process layer by layer from top to bottom, but stop before ground layer
      const stopLayer = groundLayer;
      
      for (let layer = maxLevel - 1; layer >= stopLayer; layer--) {
        const numOps = Math.floor(minOps + rng() * (maxOps - minOps + 1));
        
        for (let i = 0; i < numOps; i++) {
          const opName = opList[Math.floor(rng() * opList.length)];
          let result;
          
          switch(opName) {
            case 'surfaceLower': result = sculptOps.surfaceLower(); break;
            case 'riverValley': result = sculptOps.riverValley(); break;
            case 'riverTerrace': result = sculptOps.riverTerrace(layer); break; // ‚≠ê pass current layer
            case 'basinDeepen': result = sculptOps.basinDeepen(); break;
            case 'plateauKeep': result = sculptOps.plateauKeep(); break;
            case 'ridgeCarve': result = sculptOps.ridgeCarve(); break;
            case 'windSmooth': result = sculptOps.windSmooth(); break;
          }
          
          if (result) {
            opLog.push({ layer, ...result });
          }
        }
      }
      
      // Ensure ground layer is always solid
      for (let i = 0; i < levels.length; i++) {
        if (levels[i] < groundLayer) {
          levels[i] = groundLayer;
        }
      }
      
      return {
        levels,
        vertDir: new Int8Array(w * h),  // no ramps/walls in sculpt mode
        vertType: new Int8Array(w * h),
        vertPlaced: 0,
        spanTotal: 0,
        spanSelected: 0,
        spanRamp: 0,
        spanRock: 0,
        spanEdgesStamped: 0,
        opLog
      };
    }

    // =========================================================================
    // WATER SYSTEM - Animated water shader and plane generation
    // =========================================================================

    // Create water shader material
    function createWaterMaterial() {
      const waterColor = new THREE.Color($("waterColor").value);
      
      // Full noise functions from the preview
      const GLSL_COMMON = `
        float hash1(float n){ return fract(sin(n) * 43758.5453123); }
        float hash3(vec3 p){ return hash1(dot(p, vec3(127.1, 311.7, 74.7))); }
        float noise3(vec3 x){
          vec3 i=floor(x), f=fract(x);
          f=f*f*(3.0-2.0*f);
          float n000=hash3(i+vec3(0,0,0));
          float n100=hash3(i+vec3(1,0,0));
          float n010=hash3(i+vec3(0,1,0));
          float n110=hash3(i+vec3(1,1,0));
          float n001=hash3(i+vec3(0,0,1));
          float n101=hash3(i+vec3(1,0,1));
          float n011=hash3(i+vec3(0,1,1));
          float n111=hash3(i+vec3(1,1,1));
          float nx00=mix(n000,n100,f.x);
          float nx10=mix(n010,n110,f.x);
          float nx01=mix(n001,n101,f.x);
          float nx11=mix(n011,n111,f.x);
          float nxy0=mix(nx00,nx10,f.y);
          float nxy1=mix(nx01,nx11,f.y);
          return mix(nxy0,nxy1,f.z);
        }
        float signedNoise(vec3 p){ return (noise3(p)-0.5)*2.0; }
      `;
      
      const waterVertexShader = `
        uniform float time;
        uniform vec3 flowDir;
        uniform float flowSpeed;
        uniform float waveScale;
        uniform float waveAmp;
        uniform float silhouetteAmp;

        attribute float aWaterMask;
        attribute float aWaterDepth;

        varying vec3 vPosObj;
        varying vec3 vNormalWorld;
        varying vec3 vPosWorld;
        varying float vWaterMask;
        varying float vWaterDepth;
        varying float vRim;

        ${GLSL_COMMON}

        void main(){
          vec3 posObj = position;
          vec3 nObj = normal;

          vec3 fDir = normalize(flowDir + vec3(1e-6));
          vec3 p = posObj + fDir * (time * flowSpeed);

          // Two bands of 3D noise moving along flow direction
          float w1 = signedNoise(p * waveScale);
          float w2 = signedNoise((p + vec3(1.7, 0.3, -0.9)) * (waveScale * 1.9));
          float wave = (w1 + w2 * 0.45) * waveAmp;

          // View-dependent "silhouette trouble": stronger near rim so motion reads in outline
          vec4 posView4_pre = modelViewMatrix * vec4(posObj, 1.0);
          vec3 posView_pre = posView4_pre.xyz;
          vec3 vDir_pre = normalize(-posView_pre);
          vec3 nView_pre = normalize((modelViewMatrix * vec4(nObj, 0.0)).xyz);
          float ndv = abs(dot(nView_pre, vDir_pre));
          float rim = 1.0 - ndv; // 0 front-facing, 1 at silhouette

          float tNoise = signedNoise((p * (waveScale * 0.65)) + vec3(0.0, time * 0.85, 0.0));
          float trouble = tNoise * silhouetteAmp * smoothstep(0.15, 0.95, rim);

          // Apply displacement: mostly normal, with a small tangential shove aligned to flow
          vec3 tangent = normalize(cross(nObj, fDir) + vec3(1e-6));
          vec3 deformedObj = posObj + nObj * (wave + trouble) + tangent * (trouble * 0.55);

          vPosObj = deformedObj;
          vec4 worldPos = modelMatrix * vec4(deformedObj, 1.0);
          vPosWorld = worldPos.xyz;
          vNormalWorld = normalize(normalMatrix * nObj);
          vRim = rim;
          vWaterMask = aWaterMask;
          vWaterDepth = aWaterDepth;

          gl_Position = projectionMatrix * viewMatrix * worldPos;
        }
      `;

      const waterFragmentShader = `
        uniform float time;
        uniform vec3 flowDir;
        uniform float flowSpeed;
        uniform float waveScale;
        uniform float waterOpacity;
        uniform vec3 waterTint;
        uniform float waterExtrasMix;

        varying vec3 vPosObj;
        varying vec3 vNormalWorld;
        varying vec3 vPosWorld;
        varying float vRim;
        varying float vWaterMask;
        varying float vWaterDepth;

        ${GLSL_COMMON}

        void main(){
          vec3 nW = normalize(vNormalWorld);
          vec3 vW = normalize(cameraPosition - vPosWorld);
          float ndv = clamp(abs(dot(nW, vW)), 0.0, 1.0);

          // Fresnel-ish edge brightening (stylized)
          float fres = pow(1.0 - ndv, 2.4);
          fres *= waterExtrasMix;

          vec3 fDir = normalize(flowDir + vec3(1e-6));
          vec3 p = vPosObj + fDir * (time * flowSpeed);

          // "Foam" bands: animated noise, strongest near silhouette
          float n = signedNoise(p * (waveScale * 1.35));
          float foam = smoothstep(0.35, 0.85, n) * smoothstep(0.10, 0.95, (1.0 - ndv));
          // Near-shore boost (depth close to 0) so shore reads even without the outline pass
          float shore = 1.0 - smoothstep(0.0, 1.25, vWaterDepth);
          foam = mix(foam, clamp(foam + shore * 0.35, 0.0, 1.0), waterExtrasMix);
          foam *= waterExtrasMix;

          // Subtle internal shading (darker when facing away) + fresnel highlight
          vec3 deep = waterTint * 0.72;
          vec3 col = mix(deep, waterTint, pow(ndv, 0.6));
          col = mix(col, vec3(1.0), fres * 0.35);
          col = mix(col, vec3(1.0), foam * 0.25);

                    // Alpha: base opacity with fresnel lift + a touch of foam
          float aFancy = clamp(waterOpacity * (0.75 + fres * 0.40) + foam * 0.10, 0.0, 1.0);
          float a = mix(waterOpacity, aFancy, waterExtrasMix);

          gl_FragColor = vec4(col, a);
        }
      `;

      const flowDirStr = $("flowDir") ? $("flowDir").value : "0.7,0,0.7";
      const flowDir = flowDirStr.split(',').map(v => parseFloat(v));

      const mat = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0.0 },
          waterTint: { value: new THREE.Vector3(waterColor.r, waterColor.g, waterColor.b) },
          waterExtrasMix: { value: ($('waterFancy') && $('waterFancy').checked) ? 1.0 : 0.0 }, // toggles foam/fresnel shading (default OFF)
          waterOpacity: { value: $("waterOpacity") ? parseFloat($("waterOpacity").value) : 1.0 },
          flowDir: { value: new THREE.Vector3(flowDir[0], flowDir[1], flowDir[2]) },
          flowSpeed: { value: $("waveSpeed") ? parseFloat($("waveSpeed").value) : 1.25 },
          waveScale: { value: $("waveScale") ? parseFloat($("waveScale").value) : 4.5 },
          waveAmp: { value: $("waveAmp") ? parseFloat($("waveAmp").value) : 0.10 },
          silhouetteAmp: { value: 0.14 }  // Silhouette motion effect
        },
        vertexShader: waterVertexShader,
        fragmentShader: waterFragmentShader,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });

      
      // If the user wants fully opaque water (opacity >= 0.999) and extras are off,
      // treat it as an opaque pass for stable depth + sorting on mobile GPUs.
      try{
        const op = mat.uniforms.waterOpacity.value;
        const ex = mat.uniforms.waterExtrasMix.value;
        if (op >= 0.999 && ex < 0.5){
          mat.transparent = false;
          mat.depthWrite = true;
        }
      }catch(e){}
(globalThis.__waterMaterials = globalThis.__waterMaterials || new Set()).add(mat);
      return mat;

    }

    // Generate water plane at specified level
        function generateWaterPlane(levels, w, h, tileSize, waterLevel) {
      if (!$("enableWater").checked) return { geometry: null, hadAny: false };

      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const masks    = [];
      const depths   = [];
      const indices  = [];

      // Subdivisions per tile for better waves / smoother shore ramps (keep modest for mobile)
      const resolution = 3;

      // "Minecraft rules but less awkward":
      // When a wet tile borders a dry/higher tile, we slope the water surface up along that edge.
      // This avoids a harsh vertical gap at shorelines and cliff cuts.
      const bankWidthFrac = 0.50; // 0..1 portion of tile used for the ramp (0.5 = half-tile ramp)

      let hadAny = false;

      function hAt(x, z){
        if (x < 0 || x >= w || z < 0 || z >= h) return waterLevel; // outside treated as same level (no ramp)
        return levels[z * w + x];
      }

      for (let z = 0; z < h; z++) {
        for (let x = 0; x < w; x++) {
          const terrainHeight = levels[z * w + x];

          const isWet = terrainHeight < waterLevel;
          if (isWet) hadAny = true;

          // If we're clipping, skip tiles that aren't wet.
          if ($("waterClip").checked && !isWet) continue;

          const hn = hAt(x, z - 1);
          const hs = hAt(x, z + 1);
          const hw = hAt(x - 1, z);
          const he = hAt(x + 1, z);

          // If not clipping, keep perfectly flat (user can force an always-visible plane).
          const doBanks = $("waterClip").checked && isWet;

          const x0 = x * tileSize;
          const z0 = z * tileSize;
          const x1 = (x + 1) * tileSize;
          const z1 = (z + 1) * tileSize;

          function yForUV(u, v){
            let y = waterLevel;

            if (!doBanks) return y;

            // Edge ramp targets: only ramp up when neighbor is dry (>= waterLevel).
            // We ramp toward the neighbor terrain height so the surface visually connects.
            if ((hn - waterLevel) >= 0.99 && (hn - waterLevel) <= 1.01 && v <= bankWidthFrac){
              const t = Math.min(1, Math.max(0, v / bankWidthFrac));
              y = Math.max(y, (hn * (1 - t)) + (waterLevel * t));
            }
            if ((hs - waterLevel) >= 0.99 && (hs - waterLevel) <= 1.01 && v >= (1 - bankWidthFrac)){
              const t = Math.min(1, Math.max(0, (1 - v) / bankWidthFrac));
              y = Math.max(y, (hs * (1 - t)) + (waterLevel * t));
            }
            if ((hw - waterLevel) >= 0.99 && (hw - waterLevel) <= 1.01 && u <= bankWidthFrac){
              const t = Math.min(1, Math.max(0, u / bankWidthFrac));
              y = Math.max(y, (hw * (1 - t)) + (waterLevel * t));
            }
            if ((he - waterLevel) >= 0.99 && (he - waterLevel) <= 1.01 && u >= (1 - bankWidthFrac)){
              const t = Math.min(1, Math.max(0, (1 - u) / bankWidthFrac));
              y = Math.max(y, (he * (1 - t)) + (waterLevel * t));
            }

            return y;
          }

          // Create subdivided quads for this tile
          for (let sz = 0; sz < resolution; sz++) {
            for (let sx = 0; sx < resolution; sx++) {
              const u0 = sx / resolution;
              const u1 = (sx + 1) / resolution;
              const v0 = sz / resolution;
              const v1 = (sz + 1) / resolution;

              const tx0 = x0 + (x1 - x0) * u0;
              const tx1 = x0 + (x1 - x0) * u1;
              const tz0 = z0 + (z1 - z0) * v0;
              const tz1 = z0 + (z1 - z0) * v1;

              const baseIdx = vertices.length / 3;

              // 4 verts (with shore ramp shaping)
              vertices.push(tx0, yForUV(u0, v0), tz0);
              vertices.push(tx1, yForUV(u1, v0), tz0);
              vertices.push(tx1, yForUV(u1, v1), tz1);
              vertices.push(tx0, yForUV(u0, v1), tz1);

              // Mask/Depth: drive alpha + near-shore styling
              const mask = isWet ? 1.0 : 0.0;
              const depth = waterLevel - terrainHeight; // >0 means submerged amount in "height units"
              for (let i = 0; i < 4; i++) {
                masks.push(mask);
                depths.push(depth);
              }

              // 2 tris
              indices.push(baseIdx, baseIdx + 1, baseIdx + 2);
              indices.push(baseIdx, baseIdx + 2, baseIdx + 3);
            }
          }
        }
      }

      if (vertices.length === 0) return { geometry: null, hadAny };

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('aWaterMask', new THREE.Float32BufferAttribute(masks, 1));
      geometry.setAttribute('aWaterDepth', new THREE.Float32BufferAttribute(depths, 1));
      geometry.setIndex(indices);

      // Compute normals so the sloped banks light correctly.
      geometry.computeVertexNormals();

      return { geometry, hadAny };
    }

    // Update water in scene


// Count key voxel types in importedVoxelGrid for mobile-visible debugging.
function countImportedVoxelTypes(){
  if (!importedVoxelGrid || !importedVoxelGridDims) return null;
  const { w, h, depth } = importedVoxelGridDims;
  const WH = w * h;

  let roadRamps = 0, roadFlats = 0;
  let grassRamps = 0, grassFlats = 0;
  let river = 0;

  for (let y = 0; y < depth; y++){
    const base = y * WH;
    for (let i = 0; i < WH; i++){
      const t = importedVoxelGrid[base + i] || 0;
      if (t >= VOXEL_TYPES.ROAD_NS && t <= VOXEL_TYPES.ROAD_CROSS) roadFlats++;
      else if (t >= VOXEL_TYPES.ROAD_RAMP_N && t <= VOXEL_TYPES.ROAD_RAMP_W) roadRamps++;
      else if (t >= VOXEL_TYPES.RIVER_N && t <= VOXEL_TYPES.RIVER_SW) river++;
      else if (t === VOXEL_TYPES.GRASS_FLAT) grassFlats++;
      else if (t === VOXEL_TYPES.GRASS_RAMP_N || t === VOXEL_TYPES.GRASS_RAMP_E || t === VOXEL_TYPES.GRASS_RAMP_S || t === VOXEL_TYPES.GRASS_RAMP_W) grassRamps++;
    }
  }

  return { roadFlats, roadRamps, grassFlats, grassRamps, river };
}

function updateWater() {
      // Safety check - don't run if elements aren't ready yet
      if (!$("enableWater") || !$("waterLevel")) return;
      
      // Remove old water
      if (waterMesh) {
        scene.remove(waterMesh);
        if (waterMesh.geometry) waterMesh.geometry.dispose();
        if (waterMesh.material) waterMesh.material.dispose();
        waterMesh = null;
      }
      
      if (!$("enableWater").checked || !levels) return;
      
      const p = readParams();
      const waterLevel = parseFloat($("waterLevel").value);
      
      const waterPlaneResult = generateWaterPlane(levels, p.w, p.h, p.tileSize, waterLevel);

      const waterGeometry = waterPlaneResult && waterPlaneResult.geometry ? waterPlaneResult.geometry : null;

      if (!waterGeometry) {
        if ($("waterClip") && $("waterClip").checked && waterPlaneResult && waterPlaneResult.hadAny === false) {
          log("No terrain is below the current Water Level. Raise Water Level or uncheck 'Clip Water To Low Areas'.");
        }
        return;
      }

      {
        const waterMaterial = createWaterMaterial();
        waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
waterMesh.name = 'GlobalWaterPlane';
        waterMesh.layers.set(0);
        waterMesh.layers.enable(WATER_LAYER);
        waterMesh.renderOrder = 1; // Render after terrain
        scene.add(waterMesh);
        try{
          waterMesh.geometry.computeBoundingBox();
          const bb = waterMesh.geometry.boundingBox;
          if (bb) {
            const __posAttr = waterMesh.geometry.getAttribute('position');
            log(`Water spawned: verts=${__posAttr ? __posAttr.count : '?'} bboxY=[${bb.min.y.toFixed(2)}, ${bb.max.y.toFixed(2)}] layers=0x${waterMesh.layers.mask.toString(16)}`);
} else {
            log(`Water spawned: verts=${waterMesh.geometry.getAttribute('position')?.count ?? '?'} (no bbox) layers=0x${waterMesh.layers.mask.toString(16)}`);
          }
        }catch(e){ log('Water spawned (debug bbox failed): ' + (e && e.message ? e.message : e)); }
        __updateWaterBBoxHelper?.();
      }
    }


    // ----------------------------------------------------------------------------
    // WATER VISIBILITY DEBUG
    // ----------------------------------------------------------------------------
    var __waterBBoxHelper = null;
    var __waterAxesHelper = null;
    var __waterTestQuad = null;

    function __ensureWaterHelpers(){
      const scene = globalThis.scene;
      if (!scene) return;

      // Axes helper at world origin (helps detect if the whole scene is off-screen / camera is broken)
      if (!__waterAxesHelper){
        __waterAxesHelper = new THREE.AxesHelper(12);
        __waterAxesHelper.name = "DBG_Axes";
        __waterAxesHelper.visible = false;
        scene.add(__waterAxesHelper);
      }

      // A small always-visible test quad (helps confirm rendering + scale)
      if (!__waterTestQuad){
        const g = new THREE.PlaneGeometry(6, 6, 1, 1);
        const m = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.85, depthTest: false });
        __waterTestQuad = new THREE.Mesh(g, m);
        __waterTestQuad.name = "DBG_TestQuad";
        __waterTestQuad.rotation.x = -Math.PI * 0.5;
        __waterTestQuad.position.set(0, 12, 0);
        __waterTestQuad.renderOrder = 9999;
        __waterTestQuad.visible = false;
        scene.add(__waterTestQuad);
      }
    }

    function __updateWaterBBoxHelper(){
      const scene = globalThis.scene;
      if (!scene) return;

      if (__waterBBoxHelper){
        scene.remove(__waterBBoxHelper);
        __waterBBoxHelper = null;
      }
      if (!waterMesh) return;

      waterMesh.geometry.computeBoundingBox();
      const bb = waterMesh.geometry.boundingBox ? waterMesh.geometry.boundingBox.clone() : null;
      if (!bb) return;

      // Convert local bbox -> world bbox
      const worldBB = new THREE.Box3();
      worldBB.copy(bb).applyMatrix4(waterMesh.matrixWorld);

      __waterBBoxHelper = new THREE.Box3Helper(worldBB, 0xffff00);
      __waterBBoxHelper.name = "DBG_WaterBBox";
      __waterBBoxHelper.visible = false;
      scene.add(__waterBBoxHelper);
    }

    function __dumpWaterDebug(){
      const log = globalThis.__uiLog || ((m)=>console.log(m));
      const cam = globalThis.__hhCamera;
      const ctl = globalThis.__hhControls;

      log("=== WATER DEBUG DUMP ===");
      if (!cam) log("Camera: (missing globalThis.__hhCamera)");
      else {
        log(`Camera pos: ${cam.position.x.toFixed(2)}, ${cam.position.y.toFixed(2)}, ${cam.position.z.toFixed(2)}`);
        const dir = new THREE.Vector3();
        cam.getWorldDirection(dir);
        log(`Camera dir: ${dir.x.toFixed(3)}, ${dir.y.toFixed(3)}, ${dir.z.toFixed(3)}`);
        log(`Camera layers mask: 0x${(cam.layers && cam.layers.mask ? cam.layers.mask : 0).toString(16)}`);
        log(`Near/Far: ${cam.near} / ${cam.far}`);
      }

      let __wm = null;
      let geom = null;

      if (!waterMesh){
        log("waterMesh: NULL (not spawned or removed).");
      } else {
        __wm = waterMesh;
        const wm = __wm;
        log(`waterMesh: exists name=${wm.name || "(none)"}`);
        log(`waterMesh visible=${wm.visible} pos=${wm.position.x.toFixed(2)},${wm.position.y.toFixed(2)},${wm.position.z.toFixed(2)}`);
        log(`waterMesh layers mask: 0x${wm.layers.mask.toString(16)} (should include 0x1 for main view)`);
        geom = wm.geometry;
        if (geom){
          const posAttr = geom.getAttribute("position");
          log(`waterGeom verts=${posAttr ? posAttr.count : "?"} indexed=${!!geom.index}`);
          geom.computeBoundingBox();
          const bb = geom.boundingBox;
          if (bb){
            log(`waterGeom local bbox min=${bb.min.x.toFixed(2)},${bb.min.y.toFixed(2)},${bb.min.z.toFixed(2)} max=${bb.max.x.toFixed(2)},${bb.max.y.toFixed(2)},${bb.max.z.toFixed(2)}`);
          } else {
            log("waterGeom bbox: (missing)");
          }
        } else {
          log("waterGeom: NULL");
        }

        const mat = wm.material;
        if (mat && mat.uniforms){
          const u = mat.uniforms;
          const op = u.waterOpacity ? u.waterOpacity.value : "(no uniform)";
          const tint = u.waterTint ? u.waterTint.value : null;
          const extras = u.waterExtrasMix ? u.waterExtrasMix.value : "(no uniform)";
          log(`waterMat uniforms: opacity=${op} extrasMix=${extras} tint=${tint ? `${tint.x.toFixed(2)},${tint.y.toFixed(2)},${tint.z.toFixed(2)}` : "(none)"}`);
          log(`waterMat transparent=${!!mat.transparent} depthWrite=${!!mat.depthWrite}`);
        } else {
          log("waterMat: missing uniforms (not ShaderMaterial?)");
        }
      }


      // Voxel river surface meshes (if present) ‚Äì helpful when water appears to be "missing".
      try{
        const sc = globalThis.scene;
        const camMask = (cam && cam.layers && typeof cam.layers.mask === "number") ? cam.layers.mask : 0;
        if (sc){
          const rivers = sc.getObjectByName("Rivers");
          if (rivers){
            const kids = (rivers.children || []).filter(n => n && n.isMesh);
            log(`Rivers group: meshes=${kids.length}`);
            if (kids.length){
              let inCam = 0;
              for (const k of kids){
                const msk = (k.layers && typeof k.layers.mask === "number") ? k.layers.mask : 0;
                if ((msk & camMask) !== 0) inCam++;
              }
              log(`Rivers visible to camera layers: ${inCam}/${kids.length} (camMask=0x${camMask.toString(16)})`);
              if (inCam === 0){
                log("Hint: River meshes may be only on WATER_LAYER. They should also include layer 0 to render normally.");
              }
            }
          } else {
            log("Rivers group: (none)");
          }

          // Voxel water walls (vertical faces of river voxels)
          const waterWalls = sc.getObjectByName("WaterWalls");
          if (waterWalls){
            const kidsW = (waterWalls.children || []).filter(n => n && n.isMesh);
            log(`WaterWalls group: meshes=${kidsW.length}`);
            if (kidsW.length){
              let inCamW = 0;
              for (const k of kidsW){
                const msk = (k.layers && typeof k.layers.mask === "number") ? k.layers.mask : 0;
                if ((msk & camMask) !== 0) inCamW++;
              }
              log(`WaterWalls visible to camera layers: ${inCamW}/${kidsW.length} (camMask=0x${camMask.toString(16)})`);
            }
          } else {
            log("WaterWalls group: (none)");
          }
        }
      }catch(e){
        log("Rivers debug failed: " + (e && e.message ? e.message : e));
      }
// If the camera is far away, offer a hint
      if (cam && geom && geom.boundingBox){
        const center = geom.boundingBox.getCenter(new THREE.Vector3()).applyMatrix4(wm.matrixWorld);
        const dist = cam.position.distanceTo(center);
        log(`Camera->water center dist: ${dist.toFixed(2)}`);
      }
    }

    function __frameWater(){
      const log = globalThis.__uiLog || ((m)=>console.log(m));
      const cam = globalThis.__hhCamera;
      const ctl = globalThis.__hhControls;
      if (!cam) { log("Frame Water: missing camera"); return; }
      if (!waterMesh || !waterMesh.geometry){ log("Frame Water: waterMesh missing"); return; }

      waterMesh.geometry.computeBoundingBox();
      const bb = waterMesh.geometry.boundingBox;
      if (!bb){ log("Frame Water: missing bbox"); return; }

      const worldBB = new THREE.Box3().copy(bb).applyMatrix4(waterMesh.matrixWorld);
      const center = worldBB.getCenter(new THREE.Vector3());
      const size = worldBB.getSize(new THREE.Vector3());
      const radius = Math.max(size.x, size.y, size.z) * 0.65 + 2.0;

      // Place camera at an isometric-ish offset
      cam.position.set(center.x + radius, center.y + radius * 0.9, center.z + radius);
      cam.near = 0.1;
      cam.far = Math.max(500, radius * 20);
      cam.updateProjectionMatrix();

      if (ctl && ctl.target){
        ctl.target.copy(center);
        ctl.update?.();
      } else {
        cam.lookAt(center);
      }

      log(`Framed water: center=${center.x.toFixed(2)},${center.y.toFixed(2)},${center.z.toFixed(2)} radius‚âà${radius.toFixed(2)}`);
    }

    function __wireWaterDebugUI(){
      const dumpBtn = document.getElementById("waterDumpBtn");
      const frameBtn = document.getElementById("waterFrameBtn");
      const showHelpers = document.getElementById("waterShowHelpers");
      const showTestQuad = document.getElementById("waterShowTestQuad");
      if (dumpBtn && !dumpBtn.__wired){
        dumpBtn.__wired = true;
        dumpBtn.addEventListener("click", ()=>{ __ensureWaterHelpers(); __updateWaterBBoxHelper(); __dumpWaterDebug(); });
      }
      if (frameBtn && !frameBtn.__wired){
        frameBtn.__wired = true;
        frameBtn.addEventListener("click", ()=>{ __ensureWaterHelpers(); __updateWaterBBoxHelper(); __frameWater(); });
      }
      if (showHelpers && !showHelpers.__wired){
        showHelpers.__wired = true;
        showHelpers.addEventListener("change", ()=>{
          __ensureWaterHelpers();
          __updateWaterBBoxHelper();
          const v = !!showHelpers.checked;
          if (__waterAxesHelper) __waterAxesHelper.visible = v;
          if (__waterBBoxHelper) __waterBBoxHelper.visible = v;
          (globalThis.__uiLog || console.log)(`Water helpers ${v ? "ON" : "OFF"}.`);
        });
      }
      if (showTestQuad && !showTestQuad.__wired){
        showTestQuad.__wired = true;
        showTestQuad.addEventListener("change", ()=>{
          __ensureWaterHelpers();
          const v = !!showTestQuad.checked;
          if (__waterTestQuad) __waterTestQuad.visible = v;
          (globalThis.__uiLog || console.log)(`Test quad ${v ? "ON" : "OFF"}.`);
        });
      }
    }


    // Update water shader uniforms each frame
    function updateWaterUniforms(time) {
      const mats = [];
      if (waterMesh && waterMesh.material) mats.push(waterMesh.material);
      const set = globalThis.__waterMaterials;
      if (set && typeof set.forEach === "function") set.forEach(m=>{ if (m) mats.push(m); });
      if (!mats.length) return;
      if (!$("waterColor")) return; // Safety check

      for (const mat of mats){
        if (!mat || !mat.uniforms) continue;
        mat.uniforms.time.value = time;
        if (mat.uniforms.waterExtrasMix) mat.uniforms.waterExtrasMix.value = ($('waterFancy') && $('waterFancy').checked) ? 1.0 : 0.0;
        
        // Update color if changed
        if ($("waterColor")) {
          const color = new THREE.Color($("waterColor").value);
          mat.uniforms.waterTint.value.set(color.r, color.g, color.b);
        }
        if ($("waterOpacity")) mat.uniforms.waterOpacity.value = parseFloat($("waterOpacity").value);
        if ($("waveSpeed")) mat.uniforms.flowSpeed.value = parseFloat($("waveSpeed").value);
        if ($("waveScale")) mat.uniforms.waveScale.value = parseFloat($("waveScale").value);
        if ($("waveAmp")) mat.uniforms.waveAmp.value = parseFloat($("waveAmp").value);
        
        if ($("flowDir")) {
          const flowDir = $("flowDir").value.split(',').map(v => parseFloat(v));
          mat.uniforms.flowDir.value.set(flowDir[0], flowDir[1], flowDir[2]);
        }
      }

      // UI pills for water-outline controls (mobile friendly)
      if ($("waterOutlineThickVal") && $("waterOutlineThick")) $("waterOutlineThickVal").textContent = (parseFloat($("waterOutlineThick").value) || 0).toFixed(1);
      if ($("waterOutlineStrengthVal") && $("waterOutlineStrength")) $("waterOutlineStrengthVal").textContent = (parseFloat($("waterOutlineStrength").value) || 0).toFixed(2);

      // UI pills for material-outline controls (mobile friendly)
      if ($("materialOutlineThickVal") && $("materialOutlineThick")) $("materialOutlineThickVal").textContent = (parseFloat($("materialOutlineThick").value) || 0).toFixed(1);
      if ($("materialOutlineStrengthVal") && $("materialOutlineStrength")) $("materialOutlineStrengthVal").textContent = (parseFloat($("materialOutlineStrength").value) || 0).toFixed(2);

      }

    // Wire up water controls
    ['waterLevel', 'waterOpacity', 'waveSpeed', 'waveScale', 'waveAmp'].forEach(id => {
      const input = $(id);
      const display = $(id + 'Val');
      if (input && display) {
        input.addEventListener('input', () => {
          display.textContent = parseFloat(input.value).toFixed(2);
          updateWater();
        });
      }
    });

    $("enableWater").addEventListener('change', updateWater);
    $("waterClip").addEventListener('change', updateWater);
    $("waterColor").addEventListener('change', updateWater);
    $("flowDir").addEventListener('change', updateWater);

    // Wire up tree size controls
    const treeControls = [
      { id: 'treeUnitScale', decimals: 2, suffix: '' },
      { id: 'treeScaleJitterFrac', decimals: 2, suffix: '' },
      { id: 'treeRotJitterDeg', decimals: 0, suffix: '¬∞' },
      { id: 'treeSpawnOffsetFrac', decimals: 2, suffix: '' }
    ];
    
    treeControls.forEach(ctrl => {
      const input = $(ctrl.id);
      const display = $(ctrl.id + 'Val');
      if (input && display) {
        input.addEventListener('input', () => {
          const val = parseFloat(input.value);
          display.textContent = val.toFixed(ctrl.decimals) + ctrl.suffix;
          // Auto-rebuild tree preview if it's currently enabled
          if (treePreviewEnabled) {
            const p = readParams();
            rebuildTreePreview(p);
          }
        });
      }
    });

    // Wire up road bricks controls
    const roadBricksControls = [
      { id: 'roadBricksDensity', decimals: 2, suffix: '' },
      { id: 'roadBricksSizeFrac', decimals: 2, suffix: '' },
      { id: 'roadBricksYLift', decimals: 3, suffix: '' }
    ];

    roadBricksControls.forEach(ctrl => {
      const input = $(ctrl.id);
      const display = $(ctrl.id + 'Val');
      if (input && display) {
        input.addEventListener('input', () => {
          const val = parseFloat(input.value);
          display.textContent = val.toFixed(ctrl.decimals) + ctrl.suffix;
        });
        input.addEventListener('change', () => {
          // Rebuild only on change to avoid heavy work while scrubbing
          const p = readParams();
          if (roadBricksEnabled) rebuildRoadBricks(p);
          if (roadDebugEnabled) rebuildRoadDebug(p);
        });
      }
    });

    // Wire up generation mode switching
    $("genMode").addEventListener("change", () => {
      const mode = $("genMode").value;
      const isSculpt = mode.startsWith("sculpt");
      $("sculptOpsField").style.display = isSculpt ? "flex" : "none";
      $("groundLayerField").style.display = isSculpt ? "flex" : "none";
      $("sculptNote").style.display = isSculpt ? "block" : "none";
      $("sculptOpsCheckboxes").style.display = isSculpt ? "block" : "none";
      $("maxLvlNote").style.display = isSculpt ? "inline" : "none";
      
      // Adjust defaults based on mode
      if (mode === "sculpt-gentle") {
        $("sculptOpsMin").value = 1;
        $("sculptOpsMax").value = 2;
        $("groundLayer").value = 2;
        // Suggest taller block for sculpting
        if (parseInt($("maxLvl").value) < 16) {
          $("maxLvl").value = 20;
        }
      } else if (mode === "sculpt-dramatic") {
        $("sculptOpsMin").value = 2;
        $("sculptOpsMax").value = 3;
        $("groundLayer").value = 1;
        // Suggest taller block for dramatic sculpting
        if (parseInt($("maxLvl").value) < 20) {
          $("maxLvl").value = 24;
        }
      } else if (mode === "procedural") {
        // Reset to normal procedural defaults if it was changed
        if (parseInt($("maxLvl").value) > 10) {
          $("maxLvl").value = 6;
        }
      }
    });

  </script></body>
</html>
